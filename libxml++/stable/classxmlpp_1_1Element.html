<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8"></meta><link rel="stylesheet" href="../../skin/doxygen.css" type="text/css"></link><link rel="stylesheet" type="text/css" media="all" href="https://static.gnome.org/css/grass-theme-style.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/lgo2010.css"></link><link rel="icon" type="image/png" href="../../skin/gnome-16.png"></link><link rel="SHORTCUT ICON" type="image/png" href="../../skin/gnome-16.png"></link><link rel="search" type="application/opensearchdescription+xml" href="../../gnome-library-search.xml" title="GNOME Library Search"></link><link rel="stylesheet" type="text/css" href="../../skin/jquery.autocomplete.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script><title>libxml++: xmlpp::Element Class Reference</title><link rel="stylesheet" type="text/css" media="all" href="../../skin/jquery.autocomplete.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/960_24_col.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="https://developer-old.gnome.org/js/jquery.jcarousel.min.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script></head><body><div id="accessibility_access"><ul><li><a href="classxmlpp_1_1Element.html#container">Go to page content</a></li><li><a href="classxmlpp_1_1Element.html#top_bar">Go to main menu</a></li><li><a href="classxmlpp_1_1Element.html#s" onclick="$('#s').focus(); return false;">Go to the search field</a></li></ul></div><div id="global_domain_bar"><div class="maxwidth"><div class="tab"><a class="root" href="https://www.gnome.org/">GNOME.org</a></div></div></div><div id="header" class="container_12"><div id="logo" class="grid_3"><a title="Go to home page" href="../../index.html"><img alt="GNOME: The Free Software Desktop Project" src="../../skin/gnome-logo-devcenter.png"></img></a></div><div id="top_bar" class="grid_9"><div class="left"><div class="menu-globalnav-container"><ul id="menu-globalnav" class="menu"><li class="menu-item menu-item-type-post_type menu-item-6"><a href="../../about/index.html">About</a></li><li class="menu-item menu-item-type-post_type menu-item-23"><a href="https://help.gnome.org/users/">Users</a></li><li class="menu-item menu-item-type-post_type menu-item-40"><a href="https://help.gnome.org/admin/">Administrators</a></li><li class="current-menu-item"><a href="https://developer.gnome.org/">Developers</a></li></ul></div></div><div class="right"><form role="search" method="get" id="searchform" action="https://developer-old.gnome.org/symbols/"><div><label class="hidden" for="q">Search:
                        </label><input type="text" value="" name="q" id="s" placeholder="Search"></input></div></form><script type="text/javascript">
$('#s').autocomplete('/symbols/lookup/',
        { minChars:3, matchSubset:1, matchContains:1, cacheLength:10,
          selectOnly:1, rowsLimit:25 });
              </script></div></div></div><div class="clearfix"></div><div id="container" class="gtkmm"><div class="content"><h1 class="lgotitle">libxml++: xmlpp::Element Class Reference</h1><div id="content"><div class="tabs" id="navrow1">
    <ul class="tablist">
      <li><a href="index.html"><span>Main Page</span></a></li>
      <li><a href="pages.html"><span>Related Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div><div class="contents">

<p>Element nodes have attributes as well as child nodes.  
 <a href="classxmlpp_1_1Element.html#details">More...</a></p>

<p><code>#include &lt;libxml++/nodes/element.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xmlpp::Element:</div>
<div class="dyncontent">
<div class="center"><img alt="Inheritance graph" border="0" src="classxmlpp_1_1Element__inherit__graph.png" usemap="#xmlpp_1_1Element_inherit__map"></img></div>
<map id="xmlpp_1_1Element_inherit__map" name="xmlpp_1_1Element_inherit__map">
<area alt="" coords="32,80,137,107" href="classxmlpp_1_1Node.html" id="node2" shape="rect" title="Represents XML Nodes. "></area>
<area alt="" coords="5,5,164,32" href="classxmlpp_1_1NonCopyable.html" id="node3" shape="rect" title="A base for classes which cannot be copied or moved. "></area>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a74581b2c25aaa277cf0153af74fcbc31"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a74581b2c25aaa277cf0153af74fcbc31">AttributeList</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt; <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* &gt;</td></tr>
<tr class="separator:a74581b2c25aaa277cf0153af74fcbc31"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afb2a056f183f2c3ddeb1ddf5a9316006"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#afb2a056f183f2c3ddeb1ddf5a9316006">const_AttributeList</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt; const <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* &gt;</td></tr>
<tr class="separator:afb2a056f183f2c3ddeb1ddf5a9316006"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_types_classxmlpp_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxmlpp_1_1Node')"><img alt="-" src="closed.png"></img> Public Types inherited from <a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a></td></tr>
<tr class="memitem:a97f19f7f19c763f616eadb702680826f inherit pub_types_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt; const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* &gt;</td></tr>
<tr class="separator:a97f19f7f19c763f616eadb702680826f inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a57dba85e747dbe53ff768955bc3ca46b inherit pub_types_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* &gt;</td></tr>
<tr class="separator:a57dba85e747dbe53ff768955bc3ca46b inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec484e80254d11ae0f7046e011287a18 inherit pub_types_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt; <a class="el" href="classxmlpp_1_1Node.html">Node</a>* &gt;</td></tr>
<tr class="separator:aec484e80254d11ae0f7046e011287a18 inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aabbb1903a13e213fa94898a76518ebc6 inherit pub_types_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="el" href="classxmlpp_1_1Node.html">Node</a>* &gt;</td></tr>
<tr class="separator:aabbb1903a13e213fa94898a76518ebc6 inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a17584286cf6aea618a6d0878add65450 inherit pub_types_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06720.html">std::map</a>&lt; <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>, <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &gt;</td></tr>
<tr class="memdesc:a17584286cf6aea618a6d0878add65450 inherit pub_types_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">A map of namespace prefixes to namespace URIs.  <a href="classxmlpp_1_1Element.html#a17584286cf6aea618a6d0878add65450">More...</a><br></br></td></tr>
<tr class="separator:a17584286cf6aea618a6d0878add65450 inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:addce07f26b8ca52beb583d942375a756"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#addce07f26b8ca52beb583d942375a756">Element</a> (_xmlNode* node)</td></tr>
<tr class="separator:addce07f26b8ca52beb583d942375a756"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2cdba1990c4620a4b02b4fcd4a4afa2d"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a2cdba1990c4620a4b02b4fcd4a4afa2d">~Element</a> () override</td></tr>
<tr class="separator:a2cdba1990c4620a4b02b4fcd4a4afa2d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a45b7f4040d66fc847a1040ae961b923d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1CdataNode.html">CdataNode</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a45b7f4040d66fc847a1040ae961b923d">add_child_cdata</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; content)</td></tr>
<tr class="memdesc:a45b7f4040d66fc847a1040ae961b923d"><td class="mdescLeft"> </td><td class="mdescRight">Append a new CDATA node.  <a href="classxmlpp_1_1Element.html#a45b7f4040d66fc847a1040ae961b923d">More...</a><br></br></td></tr>
<tr class="separator:a45b7f4040d66fc847a1040ae961b923d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee69d63061e05c765d32a686a4434d9d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1CommentNode.html">CommentNode</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#aee69d63061e05c765d32a686a4434d9d">add_child_comment</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; content)</td></tr>
<tr class="memdesc:aee69d63061e05c765d32a686a4434d9d"><td class="mdescLeft"> </td><td class="mdescRight">Append a new comment node.  <a href="classxmlpp_1_1Element.html#aee69d63061e05c765d32a686a4434d9d">More...</a><br></br></td></tr>
<tr class="separator:aee69d63061e05c765d32a686a4434d9d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec3e495a0766d81b5a83e7a3146da683"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#aec3e495a0766d81b5a83e7a3146da683">add_child_element</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:aec3e495a0766d81b5a83e7a3146da683"><td class="mdescLeft"> </td><td class="mdescRight">Add a child element to this node.  <a href="classxmlpp_1_1Element.html#aec3e495a0766d81b5a83e7a3146da683">More...</a><br></br></td></tr>
<tr class="separator:aec3e495a0766d81b5a83e7a3146da683"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ada475bd91e7deb727aba6fa99f9d1a1b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ada475bd91e7deb727aba6fa99f9d1a1b">add_child_element</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* previous_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:ada475bd91e7deb727aba6fa99f9d1a1b"><td class="mdescLeft"> </td><td class="mdescRight">Add a child element to this node after the specified existing child node.  <a href="classxmlpp_1_1Element.html#ada475bd91e7deb727aba6fa99f9d1a1b">More...</a><br></br></td></tr>
<tr class="separator:ada475bd91e7deb727aba6fa99f9d1a1b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab5ecc3e0312fc29a49aa9b471a947a19"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ab5ecc3e0312fc29a49aa9b471a947a19">add_child_element_before</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* next_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:ab5ecc3e0312fc29a49aa9b471a947a19"><td class="mdescLeft"> </td><td class="mdescRight">Add a child element to this node before the specified existing child node.  <a href="classxmlpp_1_1Element.html#ab5ecc3e0312fc29a49aa9b471a947a19">More...</a><br></br></td></tr>
<tr class="separator:ab5ecc3e0312fc29a49aa9b471a947a19"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a853ac21a9510bbdef9d829dfb6d14dfd"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a853ac21a9510bbdef9d829dfb6d14dfd">add_child_element_before_with_new_ns</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* next_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_uri, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a853ac21a9510bbdef9d829dfb6d14dfd"><td class="mdescLeft"> </td><td class="mdescRight">Add a child element to this node before the specified existing child node.  <a href="classxmlpp_1_1Element.html#a853ac21a9510bbdef9d829dfb6d14dfd">More...</a><br></br></td></tr>
<tr class="separator:a853ac21a9510bbdef9d829dfb6d14dfd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a04d344410c6deb3eee2a1bb9bc478375"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a04d344410c6deb3eee2a1bb9bc478375">add_child_element_with_new_ns</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_uri, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a04d344410c6deb3eee2a1bb9bc478375"><td class="mdescLeft"> </td><td class="mdescRight">Add a child element to this node.  <a href="classxmlpp_1_1Element.html#a04d344410c6deb3eee2a1bb9bc478375">More...</a><br></br></td></tr>
<tr class="separator:a04d344410c6deb3eee2a1bb9bc478375"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad850fef0eb9000bc858e5b2dc0e55092"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ad850fef0eb9000bc858e5b2dc0e55092">add_child_element_with_new_ns</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* previous_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_uri, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:ad850fef0eb9000bc858e5b2dc0e55092"><td class="mdescLeft"> </td><td class="mdescRight">Add a child element to this node after the specified existing child node.  <a href="classxmlpp_1_1Element.html#ad850fef0eb9000bc858e5b2dc0e55092">More...</a><br></br></td></tr>
<tr class="separator:ad850fef0eb9000bc858e5b2dc0e55092"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a775c3a4b5da4d168376b0a61a1ad2040"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1EntityReference.html">EntityReference</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a775c3a4b5da4d168376b0a61a1ad2040">add_child_entity_reference</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name)</td></tr>
<tr class="memdesc:a775c3a4b5da4d168376b0a61a1ad2040"><td class="mdescLeft"> </td><td class="mdescRight">Append a new entity reference node.  <a href="classxmlpp_1_1Element.html#a775c3a4b5da4d168376b0a61a1ad2040">More...</a><br></br></td></tr>
<tr class="separator:a775c3a4b5da4d168376b0a61a1ad2040"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a180c2e543c9ad54d352f364ad8241622"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1ProcessingInstructionNode.html">ProcessingInstructionNode</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a180c2e543c9ad54d352f364ad8241622">add_child_processing_instruction</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; content)</td></tr>
<tr class="memdesc:a180c2e543c9ad54d352f364ad8241622"><td class="mdescLeft"> </td><td class="mdescRight">Append a new processing instruction node.  <a href="classxmlpp_1_1Element.html#a180c2e543c9ad54d352f364ad8241622">More...</a><br></br></td></tr>
<tr class="separator:a180c2e543c9ad54d352f364ad8241622"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a29128571895c5f7b77382ed69c18726c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a29128571895c5f7b77382ed69c18726c">add_child_text</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; content=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a29128571895c5f7b77382ed69c18726c"><td class="mdescLeft"> </td><td class="mdescRight">Append a new text node.  <a href="classxmlpp_1_1Element.html#a29128571895c5f7b77382ed69c18726c">More...</a><br></br></td></tr>
<tr class="separator:a29128571895c5f7b77382ed69c18726c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe27ad61606dac9da274c8b43c5708aa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#afe27ad61606dac9da274c8b43c5708aa">add_child_text</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* previous_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; content=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:afe27ad61606dac9da274c8b43c5708aa"><td class="mdescLeft"> </td><td class="mdescRight">Add a new text node after the specified existing child node.  <a href="classxmlpp_1_1Element.html#afe27ad61606dac9da274c8b43c5708aa">More...</a><br></br></td></tr>
<tr class="separator:afe27ad61606dac9da274c8b43c5708aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67870433ece791c1204aef49d4348319"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a67870433ece791c1204aef49d4348319">add_child_text_before</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* next_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; content=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a67870433ece791c1204aef49d4348319"><td class="mdescLeft"> </td><td class="mdescRight">Add a new text node before the specified existing child node.  <a href="classxmlpp_1_1Element.html#a67870433ece791c1204aef49d4348319">More...</a><br></br></td></tr>
<tr class="separator:a67870433ece791c1204aef49d4348319"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5786c9bbdcb50b0defe8cfb4e51c1fca"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a5786c9bbdcb50b0defe8cfb4e51c1fca">get_attribute</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a5786c9bbdcb50b0defe8cfb4e51c1fca"><td class="mdescLeft"> </td><td class="mdescRight">Get the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#a5786c9bbdcb50b0defe8cfb4e51c1fca">More...</a><br></br></td></tr>
<tr class="separator:a5786c9bbdcb50b0defe8cfb4e51c1fca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7d8d3bda27e628deaefafdab09364682"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a7d8d3bda27e628deaefafdab09364682">get_attribute</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const </td></tr>
<tr class="memdesc:a7d8d3bda27e628deaefafdab09364682"><td class="mdescLeft"> </td><td class="mdescRight">Get the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#a7d8d3bda27e628deaefafdab09364682">More...</a><br></br></td></tr>
<tr class="separator:a7d8d3bda27e628deaefafdab09364682"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06075836e638906ae78a79916e50ff02"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a06075836e638906ae78a79916e50ff02">get_attribute_value</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const </td></tr>
<tr class="memdesc:a06075836e638906ae78a79916e50ff02"><td class="mdescLeft"> </td><td class="mdescRight">Get the value of the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#a06075836e638906ae78a79916e50ff02">More...</a><br></br></td></tr>
<tr class="separator:a06075836e638906ae78a79916e50ff02"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8fbb85e7ecabc5a8b9b39638f94e4fb7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html#a74581b2c25aaa277cf0153af74fcbc31">AttributeList</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a8fbb85e7ecabc5a8b9b39638f94e4fb7">get_attributes</a> ()</td></tr>
<tr class="memdesc:a8fbb85e7ecabc5a8b9b39638f94e4fb7"><td class="mdescLeft"> </td><td class="mdescRight">Obtain the list of explicitly set attributes for this element.  <a href="classxmlpp_1_1Element.html#a8fbb85e7ecabc5a8b9b39638f94e4fb7">More...</a><br></br></td></tr>
<tr class="separator:a8fbb85e7ecabc5a8b9b39638f94e4fb7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d5a989b12ce69467ebbf1e51eab45fe"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html#afb2a056f183f2c3ddeb1ddf5a9316006">const_AttributeList</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a4d5a989b12ce69467ebbf1e51eab45fe">get_attributes</a> () const </td></tr>
<tr class="memdesc:a4d5a989b12ce69467ebbf1e51eab45fe"><td class="mdescLeft"> </td><td class="mdescRight">Obtain the list of explicitly set attributes for this element.  <a href="classxmlpp_1_1Element.html#a4d5a989b12ce69467ebbf1e51eab45fe">More...</a><br></br></td></tr>
<tr class="separator:a4d5a989b12ce69467ebbf1e51eab45fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab69d8c22b51bcfddebc1b52d0739db8c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ab69d8c22b51bcfddebc1b52d0739db8c">get_first_child_text</a> ()</td></tr>
<tr class="memdesc:ab69d8c22b51bcfddebc1b52d0739db8c"><td class="mdescLeft"> </td><td class="mdescRight">Get the first child text content node.  <a href="classxmlpp_1_1Element.html#ab69d8c22b51bcfddebc1b52d0739db8c">More...</a><br></br></td></tr>
<tr class="separator:ab69d8c22b51bcfddebc1b52d0739db8c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9004391ab8e39387919bef0626e2c57e"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a9004391ab8e39387919bef0626e2c57e">get_first_child_text</a> () const </td></tr>
<tr class="memdesc:a9004391ab8e39387919bef0626e2c57e"><td class="mdescLeft"> </td><td class="mdescRight">Get the first child text content node.  <a href="classxmlpp_1_1Element.html#a9004391ab8e39387919bef0626e2c57e">More...</a><br></br></td></tr>
<tr class="separator:a9004391ab8e39387919bef0626e2c57e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40d1299122bd9921fcb544ca1236aa95"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a40d1299122bd9921fcb544ca1236aa95">has_child_text</a> () const </td></tr>
<tr class="memdesc:a40d1299122bd9921fcb544ca1236aa95"><td class="mdescLeft"> </td><td class="mdescRight">Discover whether one of the child nodes is a text node.  <a href="classxmlpp_1_1Element.html#a40d1299122bd9921fcb544ca1236aa95">More...</a><br></br></td></tr>
<tr class="separator:a40d1299122bd9921fcb544ca1236aa95"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9959d2eba5aaaf5f98086a6f560a7469"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a9959d2eba5aaaf5f98086a6f560a7469">remove_attribute</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a9959d2eba5aaaf5f98086a6f560a7469"><td class="mdescLeft"> </td><td class="mdescRight">Remove the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#a9959d2eba5aaaf5f98086a6f560a7469">More...</a><br></br></td></tr>
<tr class="separator:a9959d2eba5aaaf5f98086a6f560a7469"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac9b29402f1d61113d8a8929f28d106d8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ac9b29402f1d61113d8a8929f28d106d8">set_attribute</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; value, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:ac9b29402f1d61113d8a8929f28d106d8"><td class="mdescLeft"> </td><td class="mdescRight">Set the value of the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#ac9b29402f1d61113d8a8929f28d106d8">More...</a><br></br></td></tr>
<tr class="separator:ac9b29402f1d61113d8a8929f28d106d8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16b60b87a98064e053c75098c74887e7"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a16b60b87a98064e053c75098c74887e7">set_first_child_text</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; content)</td></tr>
<tr class="memdesc:a16b60b87a98064e053c75098c74887e7"><td class="mdescLeft"> </td><td class="mdescRight">Set the text of the first text node, adding one if necessary.  <a href="classxmlpp_1_1Element.html#a16b60b87a98064e053c75098c74887e7">More...</a><br></br></td></tr>
<tr class="separator:a16b60b87a98064e053c75098c74887e7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ff97d55a647c9d3ac8ea77b978124d1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a4ff97d55a647c9d3ac8ea77b978124d1">set_namespace_declaration</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_uri, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a4ff97d55a647c9d3ac8ea77b978124d1"><td class="mdescLeft"> </td><td class="mdescRight">Add a namespace declaration to this node which will apply to this node and all children.  <a href="classxmlpp_1_1Element.html#a4ff97d55a647c9d3ac8ea77b978124d1">More...</a><br></br></td></tr>
<tr class="separator:a4ff97d55a647c9d3ac8ea77b978124d1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_classxmlpp_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxmlpp_1_1Node')"><img alt="-" src="closed.png"></img> Public Member Functions inherited from <a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a></td></tr>
<tr class="memitem:a215d8c01b6b01596c4ea853f99dce8e7 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a215d8c01b6b01596c4ea853f99dce8e7">Node</a> (_xmlNode* node)</td></tr>
<tr class="separator:a215d8c01b6b01596c4ea853f99dce8e7 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aed8dc1eea15e3e1ac42b43a49c3016ba inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aed8dc1eea15e3e1ac42b43a49c3016ba">~Node</a> () override</td></tr>
<tr class="memdesc:aed8dc1eea15e3e1ac42b43a49c3016ba inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Destructor.  <a href="classxmlpp_1_1Element.html#aed8dc1eea15e3e1ac42b43a49c3016ba">More...</a><br></br></td></tr>
<tr class="separator:aed8dc1eea15e3e1ac42b43a49c3016ba inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a648a236bfd53dcf4405446c8569d71b5 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">_xmlNode* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a648a236bfd53dcf4405446c8569d71b5">cobj</a> () noexcept</td></tr>
<tr class="memdesc:a648a236bfd53dcf4405446c8569d71b5 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Access the underlying libxml implementation.  <a href="classxmlpp_1_1Element.html#a648a236bfd53dcf4405446c8569d71b5">More...</a><br></br></td></tr>
<tr class="separator:a648a236bfd53dcf4405446c8569d71b5 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a24634a9fb4e22a08db72ab8278cfef8c inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">const _xmlNode* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a24634a9fb4e22a08db72ab8278cfef8c">cobj</a> () const  noexcept</td></tr>
<tr class="memdesc:a24634a9fb4e22a08db72ab8278cfef8c inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Access the underlying libxml implementation.  <a href="classxmlpp_1_1Element.html#a24634a9fb4e22a08db72ab8278cfef8c">More...</a><br></br></td></tr>
<tr class="separator:a24634a9fb4e22a08db72ab8278cfef8c inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aea96d8b3936718d76c192170cb188657 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aea96d8b3936718d76c192170cb188657">eval_to_boolean</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:aea96d8b3936718d76c192170cb188657 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Element.html#aea96d8b3936718d76c192170cb188657">More...</a><br></br></td></tr>
<tr class="separator:aea96d8b3936718d76c192170cb188657 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a152fac56e2454d14ad2b864502a75cc3 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a152fac56e2454d14ad2b864502a75cc3">eval_to_boolean</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:a152fac56e2454d14ad2b864502a75cc3 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Element.html#a152fac56e2454d14ad2b864502a75cc3">More...</a><br></br></td></tr>
<tr class="separator:a152fac56e2454d14ad2b864502a75cc3 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a27bad1d610b852ef56f6efde9e904bdf inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a27bad1d610b852ef56f6efde9e904bdf">eval_to_number</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:a27bad1d610b852ef56f6efde9e904bdf inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Element.html#a27bad1d610b852ef56f6efde9e904bdf">More...</a><br></br></td></tr>
<tr class="separator:a27bad1d610b852ef56f6efde9e904bdf inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afa5dae05fccb14a0183fddf4ae2be0c2 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#afa5dae05fccb14a0183fddf4ae2be0c2">eval_to_number</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:afa5dae05fccb14a0183fddf4ae2be0c2 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Element.html#afa5dae05fccb14a0183fddf4ae2be0c2">More...</a><br></br></td></tr>
<tr class="separator:afa5dae05fccb14a0183fddf4ae2be0c2 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0d615473aa53d49a8bb6beba3b0d7fb2 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a0d615473aa53d49a8bb6beba3b0d7fb2">eval_to_string</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:a0d615473aa53d49a8bb6beba3b0d7fb2 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Element.html#a0d615473aa53d49a8bb6beba3b0d7fb2">More...</a><br></br></td></tr>
<tr class="separator:a0d615473aa53d49a8bb6beba3b0d7fb2 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64bc8672f8ccf4cf4617b18822e5418e inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a64bc8672f8ccf4cf4617b18822e5418e">eval_to_string</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:a64bc8672f8ccf4cf4617b18822e5418e inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Element.html#a64bc8672f8ccf4cf4617b18822e5418e">More...</a><br></br></td></tr>
<tr class="separator:a64bc8672f8ccf4cf4617b18822e5418e inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a49686535bafb0f17cac3a3b12b8ce769 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a49686535bafb0f17cac3a3b12b8ce769">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath)</td></tr>
<tr class="memdesc:a49686535bafb0f17cac3a3b12b8ce769 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Element.html#a49686535bafb0f17cac3a3b12b8ce769">More...</a><br></br></td></tr>
<tr class="separator:a49686535bafb0f17cac3a3b12b8ce769 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af4b41249618df1df9d78302b5c41c604 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#af4b41249618df1df9d78302b5c41c604">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath) const </td></tr>
<tr class="memdesc:af4b41249618df1df9d78302b5c41c604 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Element.html#af4b41249618df1df9d78302b5c41c604">More...</a><br></br></td></tr>
<tr class="separator:af4b41249618df1df9d78302b5c41c604 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab4676913f9287edf6ff7615ef9e7b611 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ab4676913f9287edf6ff7615ef9e7b611">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces)</td></tr>
<tr class="memdesc:ab4676913f9287edf6ff7615ef9e7b611 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Element.html#ab4676913f9287edf6ff7615ef9e7b611">More...</a><br></br></td></tr>
<tr class="separator:ab4676913f9287edf6ff7615ef9e7b611 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7220f2c7e914afd0b9ed56aee83715d inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa7220f2c7e914afd0b9ed56aee83715d">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces) const </td></tr>
<tr class="memdesc:aa7220f2c7e914afd0b9ed56aee83715d inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Element.html#aa7220f2c7e914afd0b9ed56aee83715d">More...</a><br></br></td></tr>
<tr class="separator:aa7220f2c7e914afd0b9ed56aee83715d inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85ddea4c2314e086ef28d89436ab72a0 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a85ddea4c2314e086ef28d89436ab72a0">get_children</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a85ddea4c2314e086ef28d89436ab72a0 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Obtain the list of child nodes.  <a href="classxmlpp_1_1Element.html#a85ddea4c2314e086ef28d89436ab72a0">More...</a><br></br></td></tr>
<tr class="separator:a85ddea4c2314e086ef28d89436ab72a0 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee03540179478788353a0c584465aaf1 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aee03540179478788353a0c584465aaf1">get_children</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const </td></tr>
<tr class="memdesc:aee03540179478788353a0c584465aaf1 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Obtain the list of child nodes.  <a href="classxmlpp_1_1Element.html#aee03540179478788353a0c584465aaf1">More...</a><br></br></td></tr>
<tr class="separator:aee03540179478788353a0c584465aaf1 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a76dab825b8a4871cf7898ce0030143e6 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a76dab825b8a4871cf7898ce0030143e6">get_first_child</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const </td></tr>
<tr class="memdesc:a76dab825b8a4871cf7898ce0030143e6 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the first child of this node.  <a href="classxmlpp_1_1Element.html#a76dab825b8a4871cf7898ce0030143e6">More...</a><br></br></td></tr>
<tr class="separator:a76dab825b8a4871cf7898ce0030143e6 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee68120e2ec8e345098461b7f9ead6b0 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aee68120e2ec8e345098461b7f9ead6b0">get_first_child</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:aee68120e2ec8e345098461b7f9ead6b0 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the first child of this node.  <a href="classxmlpp_1_1Element.html#aee68120e2ec8e345098461b7f9ead6b0">More...</a><br></br></td></tr>
<tr class="separator:aee68120e2ec8e345098461b7f9ead6b0 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e21f3a9996e25bd2df5ec8ce9906575 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a5e21f3a9996e25bd2df5ec8ce9906575">get_line</a> () const </td></tr>
<tr class="memdesc:a5e21f3a9996e25bd2df5ec8ce9906575 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Discover at what line number this node occurs in the XML file.  <a href="classxmlpp_1_1Element.html#a5e21f3a9996e25bd2df5ec8ce9906575">More...</a><br></br></td></tr>
<tr class="separator:a5e21f3a9996e25bd2df5ec8ce9906575 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad0d08faf3bb0992a879e1d939a472832 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ad0d08faf3bb0992a879e1d939a472832">get_name</a> () const </td></tr>
<tr class="memdesc:ad0d08faf3bb0992a879e1d939a472832 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the name of this node.  <a href="classxmlpp_1_1Element.html#ad0d08faf3bb0992a879e1d939a472832">More...</a><br></br></td></tr>
<tr class="separator:ad0d08faf3bb0992a879e1d939a472832 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a110d1aa0735fcaeb43c8ee50138bfbb0 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a110d1aa0735fcaeb43c8ee50138bfbb0">get_namespace_prefix</a> () const </td></tr>
<tr class="memdesc:a110d1aa0735fcaeb43c8ee50138bfbb0 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the namespace prefix of this node.  <a href="classxmlpp_1_1Element.html#a110d1aa0735fcaeb43c8ee50138bfbb0">More...</a><br></br></td></tr>
<tr class="separator:a110d1aa0735fcaeb43c8ee50138bfbb0 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4e4da02db8954f4d82d08840b9c45604 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a4e4da02db8954f4d82d08840b9c45604">get_namespace_uri</a> () const </td></tr>
<tr class="memdesc:a4e4da02db8954f4d82d08840b9c45604 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the namespace URI of this node.  <a href="classxmlpp_1_1Element.html#a4e4da02db8954f4d82d08840b9c45604">More...</a><br></br></td></tr>
<tr class="separator:a4e4da02db8954f4d82d08840b9c45604 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a59a3e52fd752c243654a2cb58b1b0e18 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a59a3e52fd752c243654a2cb58b1b0e18">get_next_sibling</a> () const </td></tr>
<tr class="memdesc:a59a3e52fd752c243654a2cb58b1b0e18 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the next sibling for this node.  <a href="classxmlpp_1_1Element.html#a59a3e52fd752c243654a2cb58b1b0e18">More...</a><br></br></td></tr>
<tr class="separator:a59a3e52fd752c243654a2cb58b1b0e18 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2576ce35a6a3dd13b49e857524360ac4 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a2576ce35a6a3dd13b49e857524360ac4">get_next_sibling</a> ()</td></tr>
<tr class="memdesc:a2576ce35a6a3dd13b49e857524360ac4 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the next sibling for this node.  <a href="classxmlpp_1_1Element.html#a2576ce35a6a3dd13b49e857524360ac4">More...</a><br></br></td></tr>
<tr class="separator:a2576ce35a6a3dd13b49e857524360ac4 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa8a68ac1887a33e44e3af365bd02db1b inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa8a68ac1887a33e44e3af365bd02db1b">get_parent</a> () const </td></tr>
<tr class="memdesc:aa8a68ac1887a33e44e3af365bd02db1b inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the parent element for this node.  <a href="classxmlpp_1_1Element.html#aa8a68ac1887a33e44e3af365bd02db1b">More...</a><br></br></td></tr>
<tr class="separator:aa8a68ac1887a33e44e3af365bd02db1b inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a998e8cb924bd04abf72e57b68d2817f4 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a998e8cb924bd04abf72e57b68d2817f4">get_parent</a> ()</td></tr>
<tr class="memdesc:a998e8cb924bd04abf72e57b68d2817f4 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the parent element for this node.  <a href="classxmlpp_1_1Element.html#a998e8cb924bd04abf72e57b68d2817f4">More...</a><br></br></td></tr>
<tr class="separator:a998e8cb924bd04abf72e57b68d2817f4 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b41fa3ed33c91ccece3d56f97fad519 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a3b41fa3ed33c91ccece3d56f97fad519">get_path</a> () const </td></tr>
<tr class="memdesc:a3b41fa3ed33c91ccece3d56f97fad519 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the XPath of this node.  <a href="classxmlpp_1_1Element.html#a3b41fa3ed33c91ccece3d56f97fad519">More...</a><br></br></td></tr>
<tr class="separator:a3b41fa3ed33c91ccece3d56f97fad519 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa3ca83ba6e10ff21060be5d0441fa6ac inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa3ca83ba6e10ff21060be5d0441fa6ac">get_previous_sibling</a> () const </td></tr>
<tr class="memdesc:aa3ca83ba6e10ff21060be5d0441fa6ac inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the previous sibling for this node .  <a href="classxmlpp_1_1Element.html#aa3ca83ba6e10ff21060be5d0441fa6ac">More...</a><br></br></td></tr>
<tr class="separator:aa3ca83ba6e10ff21060be5d0441fa6ac inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a567be4ebaffb2cd3dd2ae602c8df4a29 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a567be4ebaffb2cd3dd2ae602c8df4a29">get_previous_sibling</a> ()</td></tr>
<tr class="memdesc:a567be4ebaffb2cd3dd2ae602c8df4a29 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Get the previous sibling for this node.  <a href="classxmlpp_1_1Element.html#a567be4ebaffb2cd3dd2ae602c8df4a29">More...</a><br></br></td></tr>
<tr class="separator:a567be4ebaffb2cd3dd2ae602c8df4a29 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aea42eae72fa7901aa1fb8f5c0fd194ec inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aea42eae72fa7901aa1fb8f5c0fd194ec">import_node</a> (const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* node, bool recursive=true)</td></tr>
<tr class="memdesc:aea42eae72fa7901aa1fb8f5c0fd194ec inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Import node(s) from another document under this node, without affecting the source node.  <a href="classxmlpp_1_1Element.html#aea42eae72fa7901aa1fb8f5c0fd194ec">More...</a><br></br></td></tr>
<tr class="separator:aea42eae72fa7901aa1fb8f5c0fd194ec inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab57a323ddd24a12707e27efa26b2b7c1 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ab57a323ddd24a12707e27efa26b2b7c1">set_name</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name)</td></tr>
<tr class="memdesc:ab57a323ddd24a12707e27efa26b2b7c1 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Set the name of this node.  <a href="classxmlpp_1_1Element.html#ab57a323ddd24a12707e27efa26b2b7c1">More...</a><br></br></td></tr>
<tr class="separator:ab57a323ddd24a12707e27efa26b2b7c1 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac7fb69ff6ff91d88996911da31ed5976 inherit pub_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ac7fb69ff6ff91d88996911da31ed5976">set_namespace</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix)</td></tr>
<tr class="memdesc:ac7fb69ff6ff91d88996911da31ed5976 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Set the namespace prefix used by the node.  <a href="classxmlpp_1_1Element.html#ac7fb69ff6ff91d88996911da31ed5976">More...</a><br></br></td></tr>
<tr class="separator:ac7fb69ff6ff91d88996911da31ed5976 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classxmlpp_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxmlpp_1_1Node')"><img alt="-" src="closed.png"></img> Static Public Member Functions inherited from <a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a></td></tr>
<tr class="memitem:a616a872d0fbd86206c0beee0be5abee3 inherit pub_static_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a616a872d0fbd86206c0beee0be5abee3">create_wrapper</a> (_xmlNode* node)</td></tr>
<tr class="memdesc:a616a872d0fbd86206c0beee0be5abee3 inherit pub_static_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Construct the correct C++ instance for a given libxml C struct instance.  <a href="classxmlpp_1_1Element.html#a616a872d0fbd86206c0beee0be5abee3">More...</a><br></br></td></tr>
<tr class="separator:a616a872d0fbd86206c0beee0be5abee3 inherit pub_static_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa47901df78305a685fc9682cd44290d6 inherit pub_static_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa47901df78305a685fc9682cd44290d6">free_wrappers</a> (_xmlNode* node)</td></tr>
<tr class="memdesc:aa47901df78305a685fc9682cd44290d6 inherit pub_static_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Delete the C++ instance for a given libxml C struct instance, and also recursively destroy the C++ instances for any children.  <a href="classxmlpp_1_1Element.html#aa47901df78305a685fc9682cd44290d6">More...</a><br></br></td></tr>
<tr class="separator:aa47901df78305a685fc9682cd44290d6 inherit pub_static_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af3af70bdc909d8d272b3df0634fb291b inherit pub_static_methods_classxmlpp_1_1Node"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#af3af70bdc909d8d272b3df0634fb291b">remove_node</a> (<a class="el" href="classxmlpp_1_1Node.html">Node</a>* node)</td></tr>
<tr class="memdesc:af3af70bdc909d8d272b3df0634fb291b inherit pub_static_methods_classxmlpp_1_1Node"><td class="mdescLeft"> </td><td class="mdescRight">Remove a node and its children.  <a href="classxmlpp_1_1Element.html#af3af70bdc909d8d272b3df0634fb291b">More...</a><br></br></td></tr>
<tr class="separator:af3af70bdc909d8d272b3df0634fb291b inherit pub_static_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pro_methods_classxmlpp_1_1NonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classxmlpp_1_1NonCopyable')"><img alt="-" src="closed.png"></img> Protected Member Functions inherited from <a class="el" href="classxmlpp_1_1NonCopyable.html">xmlpp::NonCopyable</a></td></tr>
<tr class="memitem:a96e2e5582c5bb88b2dea2adb9f9512e2 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a96e2e5582c5bb88b2dea2adb9f9512e2">NonCopyable</a> () noexcept</td></tr>
<tr class="separator:a96e2e5582c5bb88b2dea2adb9f9512e2 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aded750a42a8acdd5ed63827c158f7763 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#aded750a42a8acdd5ed63827c158f7763">NonCopyable</a> (const <a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp;)=delete</td></tr>
<tr class="separator:aded750a42a8acdd5ed63827c158f7763 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a537645a43274a8d742eed00a35ffb917 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a537645a43274a8d742eed00a35ffb917">NonCopyable</a> (<a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp;&amp;)=delete</td></tr>
<tr class="separator:a537645a43274a8d742eed00a35ffb917 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a14e2e0391beb4b8f20f5d51e8a253d63 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top">virtual </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a14e2e0391beb4b8f20f5d51e8a253d63">~NonCopyable</a> ()</td></tr>
<tr class="separator:a14e2e0391beb4b8f20f5d51e8a253d63 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adef35c286da3c2b8c90da9bb50aaddf1 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#adef35c286da3c2b8c90da9bb50aaddf1">operator=</a> (const <a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp;)=delete</td></tr>
<tr class="separator:adef35c286da3c2b8c90da9bb50aaddf1 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9888c9e5345760386ac57ff6439a30e4 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a9888c9e5345760386ac57ff6439a30e4">operator=</a> (<a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp;&amp;)=delete</td></tr>
<tr class="separator:a9888c9e5345760386ac57ff6439a30e4 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Element nodes have attributes as well as child nodes. </p>
<p>This will be instantiated by the parser. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a74581b2c25aaa277cf0153af74fcbc31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Element.html#a74581b2c25aaa277cf0153af74fcbc31">xmlpp::Element::AttributeList</a> =  <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt;<a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>*&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afb2a056f183f2c3ddeb1ddf5a9316006"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Element.html#afb2a056f183f2c3ddeb1ddf5a9316006">xmlpp::Element::const_AttributeList</a> =  <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt;const <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>*&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="addce07f26b8ca52beb583d942375a756"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">xmlpp::Element::Element </td>
          <td>(</td>
          <td class="paramtype">_xmlNode * </td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2cdba1990c4620a4b02b4fcd4a4afa2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">xmlpp::Element::~Element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a45b7f4040d66fc847a1040ae961b923d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1CdataNode.html">CdataNode</a>* xmlpp::Element::add_child_cdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Append a new CDATA node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">content</td><td>The raw text. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new CDATA node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee69d63061e05c765d32a686a4434d9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1CommentNode.html">CommentNode</a>* xmlpp::Element::add_child_comment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Append a new comment node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node. ">ContentNode::set_content()</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new comment node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec3e495a0766d81b5a83e7a3146da683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a child element to this node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000011">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The new node name </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The namespace prefix. If the prefix has not been declared then this method will throw an exception. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If a namespace prefix is specified, but has not been declared. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node cannot be created. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada475bd91e7deb727aba6fa99f9d1a1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* </td>
          <td class="paramname"><em>previous_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a child element to this node after the specified existing child node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000012">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">previous_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">name</td><td>The new node name </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The namespace prefix. If the prefix has not been declared then this method will throw an exception. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If a namespace prefix is specified, but has not been declared. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node cannot be created. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5ecc3e0312fc29a49aa9b471a947a19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* </td>
          <td class="paramname"><em>next_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a child element to this node before the specified existing child node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000013">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child_before()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">next_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">name</td><td>The new node name </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The namespace prefix. If the prefix has not been declared then this method will throw an exception. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If a namespace prefix is specified, but has not been declared. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node cannot be created. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a853ac21a9510bbdef9d829dfb6d14dfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element_before_with_new_ns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* </td>
          <td class="paramname"><em>next_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a child element to this node before the specified existing child node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000016">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child_before_with_new_ns()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">next_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">name</td><td>The new node name. </td></tr>
    <tr><td class="paramname">ns_uri</td><td>The namespace to associate with the prefix, or to use as the default namespace if no prefix is specified. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The prefix of the node's namespace. If no prefix is specified then the namespace URI will be the default namespace. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node or the namespace node cannot be created. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04d344410c6deb3eee2a1bb9bc478375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element_with_new_ns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a child element to this node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000014">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child_with_new_ns()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The new node name. </td></tr>
    <tr><td class="paramname">ns_uri</td><td>The namespace to associate with the prefix, or to use as the default namespace if no prefix is specified. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The prefix of the node's namespace. If no prefix is specified then the namespace URI will be the default namespace. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node or the namespace node cannot be created. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad850fef0eb9000bc858e5b2dc0e55092"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element_with_new_ns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* </td>
          <td class="paramname"><em>previous_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a child element to this node after the specified existing child node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000015">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child_with_new_ns()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">previous_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">name</td><td>The new node name. </td></tr>
    <tr><td class="paramname">ns_uri</td><td>The namespace to associate with the prefix, or to use as the default namespace if no prefix is specified. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The prefix of the node's namespace. If no prefix is specified then the namespace URI will be the default namespace. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node or the namespace node cannot be created. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a775c3a4b5da4d168376b0a61a1ad2040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1EntityReference.html">EntityReference</a>* xmlpp::Element::add_child_entity_reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Append a new entity reference node. </p>
<p>The reference can be either an entity reference ("name" or "&amp;name;") or a character reference ("#dec", "#xhex", "&amp;#dec;", or "&amp;#xhex;").</p>
<p>'&amp;' and ';' are optional. If they exist, they are stripped from the stored copy of the name. <a class="el" href="classxmlpp_1_1Node.html#ad0d08faf3bb0992a879e1d939a472832" title="Get the name of this node. ">Node::get_name()</a> returns the name without '&amp;' and ';'. If the <a class="el" href="classxmlpp_1_1Document.html" title="Represents an XML document in the DOM model. ">Document</a> is written to an XML file, '&amp;' and ';' are written.</p>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000007">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The name of the entity. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new entity reference node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a180c2e543c9ad54d352f364ad8241622"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1ProcessingInstructionNode.html">ProcessingInstructionNode</a>* xmlpp::Element::add_child_processing_instruction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>content</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Append a new processing instruction node. </p>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000008">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The name of the application to which the instruction is directed. </td></tr>
    <tr><td class="paramname">content</td><td>The content of the instruction. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node. ">ContentNode::set_content()</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new processing instruction node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29128571895c5f7b77382ed69c18726c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::add_child_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Append a new text node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node. ">ContentNode::set_content()</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new text node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe27ad61606dac9da274c8b43c5708aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::add_child_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* </td>
          <td class="paramname"><em>previous_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a new text node after the specified existing child node. </p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000001">Since libxml++ 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">previous_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node. ">ContentNode::set_content()</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new text node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67870433ece791c1204aef49d4348319"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::add_child_text_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a>* </td>
          <td class="paramname"><em>next_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a new text node before the specified existing child node. </p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000002">Since libxml++ 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">next_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node. ">ContentNode::set_content()</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new text node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5786c9bbdcb50b0defe8cfb4e51c1fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* xmlpp::Element::get_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the attribute with this name, and optionally with this namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The name of the attribute that will be retrieved. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute, or <code>nullptr</code> if no suitable <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration. ">Attribute</a> was found. Is either an AttributeNode*, pointing to an explicitly set attribute, or an AttributeDeclaration*, pointing to the declaration of an attribute with a default value. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d8d3bda27e628deaefafdab09364682"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* xmlpp::Element::get_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the attribute with this name, and optionally with this namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The name of the attribute that will be retrieved. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute, or <code>nullptr</code> if no suitable <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration. ">Attribute</a> was found. Is either an AttributeNode*, pointing to an explicitly set attribute, or an AttributeDeclaration*, pointing to the declaration of an attribute with a default value. </dd></dl>

</div>
</div>
<a class="anchor" id="a06075836e638906ae78a79916e50ff02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Element::get_attribute_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the value of the attribute with this name, and optionally with this namespace. </p>
<p>For finer control, you might use <a class="el" href="classxmlpp_1_1Element.html#a5786c9bbdcb50b0defe8cfb4e51c1fca" title="Get the attribute with this name, and optionally with this namespace. ">get_attribute()</a> and use the methods of the <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration. ">Attribute</a> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The name of the attribute whose value will be retrieved. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The text value of the attribute, or an empty string if no such attribute was found.</dd></dl>
<dl class="since_2_20"><dt><b><a class="el" href="since_2_20.html#_since_2_20000001">Since libxml++ 2.20:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8fbb85e7ecabc5a8b9b39638f94e4fb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html#a74581b2c25aaa277cf0153af74fcbc31">AttributeList</a> xmlpp::Element::get_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtain the list of explicitly set attributes for this element. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of explicitly set attributes. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d5a989b12ce69467ebbf1e51eab45fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html#afb2a056f183f2c3ddeb1ddf5a9316006">const_AttributeList</a> xmlpp::Element::get_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtain the list of explicitly set attributes for this element. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of explicitly set attributes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab69d8c22b51bcfddebc1b52d0739db8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::get_first_child_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the first child text content node. </p>
<p>This is a convenience method, meant as an alternative to iterating over all the child nodes to find the first suitable node and then getting the text directly. </p><dl class="section return"><dt>Returns</dt><dd>The first text node, if any.</dd></dl>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000017">Since libxml++ 3.0:</a></b></dt><dd>Replaces get_child_text(). </dd></dl>

</div>
</div>
<a class="anchor" id="a9004391ab8e39387919bef0626e2c57e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::get_first_child_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the first child text content node. </p>
<p>This is a convenience method, meant as an alternative to iterating over all the child nodes to find the first suitable node and then getting the text directly. </p><dl class="section return"><dt>Returns</dt><dd>The first text node, if any.</dd></dl>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000018">Since libxml++ 3.0:</a></b></dt><dd>Replaces get_child_text(). </dd></dl>

</div>
</div>
<a class="anchor" id="a40d1299122bd9921fcb544ca1236aa95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool xmlpp::Element::has_child_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Discover whether one of the child nodes is a text node. </p>
<p>This is a convenience method, meant as an alternative to iterating over all the child nodes and examining them directly. </p><dl class="section return"><dt>Returns</dt><dd>Whether this node has a child text node. </dd></dl>

</div>
</div>
<a class="anchor" id="a9959d2eba5aaaf5f98086a6f560a7469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void xmlpp::Element::remove_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Remove the attribute with this name, and optionally with this namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The name of the attribute to be removed </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. If specified, the attribute will be removed only if the attribute has this namespace. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9b29402f1d61113d8a8929f28d106d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* xmlpp::Element::set_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Set the value of the attribute with this name, and optionally with this namespace. </p>
<p>A matching attribute will be added if no matching attribute already exists. For finer control, you might want to use <a class="el" href="classxmlpp_1_1Element.html#a5786c9bbdcb50b0defe8cfb4e51c1fca" title="Get the attribute with this name, and optionally with this namespace. ">get_attribute()</a> and use the methods of the <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration. ">Attribute</a> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The name of the attribute whose value will change. </td></tr>
    <tr><td class="paramname">value</td><td>The new value for the attribute </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. If the prefix has not been declared then this method will throw an exception. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute that was changed, or <code>nullptr</code> is no suitable <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration. ">Attribute</a> was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16b60b87a98064e053c75098c74887e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void xmlpp::Element::set_first_child_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Set the text of the first text node, adding one if necessary. </p>
<p>This is a convenience method, meant as an alternative to iterating over all the child nodes to find the first suitable node and then setting the text directly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node. ">ContentNode::set_content()</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000019">Since libxml++ 3.0:</a></b></dt><dd>Replaces set_child_text(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4ff97d55a647c9d3ac8ea77b978124d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void xmlpp::Element::set_namespace_declaration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Add a namespace declaration to this node which will apply to this node and all children. </p>
<p>If the added namespace prefix is equal to the prefix associated to the node, the associated namespace of the node itself is updated, but child nodes are not updated. If you use this method on a node after children have been added, it may be necessary to save the XML document and reparse it to get correct namespaces on all nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ns_uri</td><td>The namespace to associate with the prefix, or to use as the default namespace if no prefix is specified. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The namespace prefix. If no prefix is specified then the namespace URI will be the default namespace. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If a new namespace node cannot be created, e.g. because a namespace with the same prefix but another URI already exists. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
</div></div></div><div id="footer_art" class="default"> </div></div><div class="clearfix"></div><div id="footer_grass">   </div><div id="footer"><div class="container_12"><div class="links grid_9"><div class="menu-footer-1-container"><ul id="menu-footer-1" class="menu"><li id="menu-item-88" class="menu-item menu-item-type-custom menu-item-home menu-item-88"><a href="https://www.gnome.org/">The GNOME Project</a><ul class="sub-menu"><li id="menu-item-89" class="menu-item menu-item-type-post_type menu-item-89"><a href="https://www.gnome.org/about/">About Us</a></li><li id="menu-item-90" class="menu-item menu-item-type-custom menu-item-90"><a href="https://www.gnome.org/get-involved/">Get Involved</a></li><li id="menu-item-91" class="menu-item menu-item-type-custom menu-item-91"><a href="https://www.gnome.org/teams/">Teams</a></li><li id="menu-item-92" class="menu-item menu-item-type-custom menu-item-92"><a href="https://foundation.gnome.org">The GNOME Foundation</a></li><li><a href="https://www.gnome.org/support-gnome/">Support GNOME</a></li><li><a href="https://www.gnome.org/contact/">Contact</a></li></ul></li></ul></div><div class="menu-footer-2-container"><ul id="menu-footer-2" class="menu"><li id="menu-item-99" class="menu-item menu-item-type-post_type current-menu-item page_item page-item-20 current_page_item menu-item-99"><a href="classxmlpp_1_1Element.html#">Resources</a><ul class="sub-menu"><li><a href="https://help.gnome.org">Documentation</a></li><li><a href="https://wiki.gnome.org">Wiki</a></li><li><a href="https://mail.gnome.org/mailman/listinfo">Mailing Lists</a></li><li><a href="https://wiki.gnome.org/GnomeIrcChannels">IRC Channels</a></li><li><a href="https://gitlab.gnome.org/">Bug Tracker</a></li><li><a href="https://gitlab.gnome.org/">Development Code</a></li><li><a href="https://wiki.gnome.org/Jhbuild">Build Tool</a></li></ul></li></ul></div><div class="menu-footer-4-container"><ul id="menu-footer-4" class="menu"><li id="menu-item-104" class="menu-item menu-item-type-custom menu-item-104"><a href="http://www.gnome.org/news/">News</a><ul class="sub-menu"><li><a href="https://www.gnome.org/start/stable">Latest Release</a></li><li><a href="https://planet.gnome.org">Planet GNOME</a></li><li><a href="https://news.gnome.org">Development News</a></li><li><a href="https://twitter.com/gnome">Twitter</a></li></ul></li></ul></div></div><div class="links grid_3 right"><div><ul class="menu available_languages"><li><strong>This website is available in many languages</strong><ul class="sub-menu"><li><a href="../../languages.html" title="Switching Language">Switch Language</a></li></ul></li></ul><script type="text/javascript" src="../../js/language.js"></script></div></div><div id="footnotes" class="grid_9">
                Copyright © 2005‒2014 <strong class="gnome_logo">The GNOME Project</strong><br></br><small>Optimised for standards. Hosted by <a href="http://redhat.com">Red Hat</a>.</small></div><div class="clear"></div></div></div><script type="text/javascript">
$(document).ready(function() {
    // Get browser
    $.each($.browser, function(i) {
        $('body').addClass(i);
        return false;
    });

    // Get OS and add it as class to body tag, this then allows forcing some
    // customisation in the CSS rules.
    var match = navigator.userAgent.toLowerCase().match(/(win|mac|linux)/);
    if (match) {
        $('body').addClass(match[0]);
    }
});
</script><script type="text/javascript">
      var _paq = _paq || [];
      _paq.push(['disableCookies']);
      _paq.push(["trackPageView"]);
      _paq.push(["enableLinkTracking"]);

      (function() {
        var u=(("https:" == document.location.protocol) ? "https" : "http") + "://webstats.gnome.org/";
        _paq.push(["setTrackerUrl", u+"piwik.php"]);
        _paq.push(["setSiteId", "6"]);
        var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";
        g.defer=true; g.async=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);
      })();
    </script></body></html>
