<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8"></meta><link rel="stylesheet" href="../../skin/doxygen.css" type="text/css"></link><link rel="stylesheet" type="text/css" media="all" href="https://static.gnome.org/css/grass-theme-style.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/lgo2010.css"></link><link rel="icon" type="image/png" href="../../skin/gnome-16.png"></link><link rel="SHORTCUT ICON" type="image/png" href="../../skin/gnome-16.png"></link><link rel="search" type="application/opensearchdescription+xml" href="../../gnome-library-search.xml" title="GNOME Library Search"></link><link rel="stylesheet" type="text/css" href="../../skin/jquery.autocomplete.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script><title>libxml++: xmlpp::Node Class Reference</title><link rel="stylesheet" type="text/css" media="all" href="../../skin/jquery.autocomplete.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/960_24_col.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="https://developer-old.gnome.org/js/jquery.jcarousel.min.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script></head><body><div id="accessibility_access"><ul><li><a href="classxmlpp_1_1Node.html#container">Go to page content</a></li><li><a href="classxmlpp_1_1Node.html#top_bar">Go to main menu</a></li><li><a href="classxmlpp_1_1Node.html#s" onclick="$('#s').focus(); return false;">Go to the search field</a></li></ul></div><div id="global_domain_bar"><div class="maxwidth"><div class="tab"><a class="root" href="https://www.gnome.org/">GNOME.org</a></div></div></div><div id="header" class="container_12"><div id="logo" class="grid_3"><a title="Go to home page" href="../../index.html"><img alt="GNOME: The Free Software Desktop Project" src="../../skin/gnome-logo-devcenter.png"></img></a></div><div id="top_bar" class="grid_9"><div class="left"><div class="menu-globalnav-container"><ul id="menu-globalnav" class="menu"><li class="menu-item menu-item-type-post_type menu-item-6"><a href="../../about/index.html">About</a></li><li class="menu-item menu-item-type-post_type menu-item-23"><a href="https://help.gnome.org/users/">Users</a></li><li class="menu-item menu-item-type-post_type menu-item-40"><a href="https://help.gnome.org/admin/">Administrators</a></li><li class="current-menu-item"><a href="https://developer.gnome.org/">Developers</a></li></ul></div></div><div class="right"><form role="search" method="get" id="searchform" action="https://developer-old.gnome.org/symbols/"><div><label class="hidden" for="q">Search:
                        </label><input type="text" value="" name="q" id="s" placeholder="Search"></input></div></form><script type="text/javascript">
$('#s').autocomplete('/symbols/lookup/',
        { minChars:3, matchSubset:1, matchContains:1, cacheLength:10,
          selectOnly:1, rowsLimit:25 });
              </script></div></div></div><div class="clearfix"></div><div id="container" class="gtkmm"><div class="content"><h1 class="lgotitle">libxml++: xmlpp::Node Class Reference</h1><div id="content"><div class="tabs" id="navrow1">
    <ul class="tablist">
      <li><a href="index.html"><span>Main Page</span></a></li>
      <li><a href="pages.html"><span>Related Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div><div class="contents">

<p>Represents XML Nodes.  
 <a href="classxmlpp_1_1Node.html#details">More...</a></p>

<p><code>#include &lt;libxml++/nodes/node.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xmlpp::Node:</div>
<div class="dyncontent">
<div class="center"><img alt="Inheritance graph" border="0" src="classxmlpp_1_1Node__inherit__graph.png" usemap="#xmlpp_1_1Node_inherit__map"></img></div>
<map id="xmlpp_1_1Node_inherit__map" name="xmlpp_1_1Node_inherit__map">
<area alt="" coords="389,56,517,83" href="classxmlpp_1_1Attribute.html" id="node3" shape="rect" title="Represents an XML attribute node or attribute declaration. "></area>
<area alt="" coords="375,183,531,209" href="classxmlpp_1_1ContentNode.html" id="node6" shape="rect" title="Content node. "></area>
<area alt="" coords="390,233,515,260" href="classxmlpp_1_1Element.html" id="node12" shape="rect" title="Element nodes have attributes as well as child nodes. "></area>
<area alt="" coords="365,284,540,311" href="classxmlpp_1_1EntityReference.html" id="node13" shape="rect" title="Entity references refer to previously declared entities. "></area>
<area alt="" coords="377,335,528,361" href="classxmlpp_1_1XIncludeEnd.html" id="node14" shape="rect" title="XIncludeEnd node. "></area>
<area alt="" coords="373,385,532,412" href="classxmlpp_1_1XIncludeStart.html" id="node15" shape="rect" title="XIncludeStart node. "></area>
<area alt="" coords="5,259,164,285" href="classxmlpp_1_1NonCopyable.html" id="node2" shape="rect" title="A base for classes which cannot be copied or moved. "></area>
<area alt="" coords="609,5,811,32" href="classxmlpp_1_1AttributeDeclaration.html" id="node4" shape="rect" title="Represents the default value of an attribute of an XML element node. "></area>
<area alt="" coords="629,56,791,83" href="classxmlpp_1_1AttributeNode.html" id="node5" shape="rect" title="Represents an explicit attribute of an XML element node. "></area>
<area alt="" coords="639,107,781,133" href="classxmlpp_1_1CdataNode.html" id="node7" shape="rect" title="CData node. "></area>
<area alt="" coords="625,157,795,184" href="classxmlpp_1_1CommentNode.html" id="node8" shape="rect" title="Comment node. "></area>
<area alt="" coords="618,208,802,235" href="classxmlpp_1_1EntityDeclaration.html" id="node9" shape="rect" title="Entity declaration. "></area>
<area alt="" coords="588,259,832,285" href="classxmlpp_1_1ProcessingInstructionNode.html" id="node10" shape="rect" title="xmlpp::ProcessingInstructionNode"></area>
<area alt="" coords="644,309,776,336" href="classxmlpp_1_1TextNode.html" id="node11" shape="rect" title="Text node. "></area>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a97f19f7f19c763f616eadb702680826f"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt; const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* &gt;</td></tr>
<tr class="separator:a97f19f7f19c763f616eadb702680826f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a57dba85e747dbe53ff768955bc3ca46b"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* &gt;</td></tr>
<tr class="separator:a57dba85e747dbe53ff768955bc3ca46b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec484e80254d11ae0f7046e011287a18"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt; <a class="el" href="classxmlpp_1_1Node.html">Node</a>* &gt;</td></tr>
<tr class="separator:aec484e80254d11ae0f7046e011287a18"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aabbb1903a13e213fa94898a76518ebc6"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt; <a class="el" href="classxmlpp_1_1Node.html">Node</a>* &gt;</td></tr>
<tr class="separator:aabbb1903a13e213fa94898a76518ebc6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a17584286cf6aea618a6d0878add65450"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06720.html">std::map</a>&lt; <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>, <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &gt;</td></tr>
<tr class="memdesc:a17584286cf6aea618a6d0878add65450"><td class="mdescLeft"> </td><td class="mdescRight">A map of namespace prefixes to namespace URIs.  <a href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">More...</a><br></br></td></tr>
<tr class="separator:a17584286cf6aea618a6d0878add65450"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a215d8c01b6b01596c4ea853f99dce8e7"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a215d8c01b6b01596c4ea853f99dce8e7">Node</a> (_xmlNode* node)</td></tr>
<tr class="separator:a215d8c01b6b01596c4ea853f99dce8e7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aed8dc1eea15e3e1ac42b43a49c3016ba"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aed8dc1eea15e3e1ac42b43a49c3016ba">~Node</a> () override</td></tr>
<tr class="memdesc:aed8dc1eea15e3e1ac42b43a49c3016ba"><td class="mdescLeft"> </td><td class="mdescRight">Destructor.  <a href="classxmlpp_1_1Node.html#aed8dc1eea15e3e1ac42b43a49c3016ba">More...</a><br></br></td></tr>
<tr class="separator:aed8dc1eea15e3e1ac42b43a49c3016ba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a648a236bfd53dcf4405446c8569d71b5"><td align="right" class="memItemLeft" valign="top">_xmlNode* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a648a236bfd53dcf4405446c8569d71b5">cobj</a> () noexcept</td></tr>
<tr class="memdesc:a648a236bfd53dcf4405446c8569d71b5"><td class="mdescLeft"> </td><td class="mdescRight">Access the underlying libxml implementation.  <a href="classxmlpp_1_1Node.html#a648a236bfd53dcf4405446c8569d71b5">More...</a><br></br></td></tr>
<tr class="separator:a648a236bfd53dcf4405446c8569d71b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a24634a9fb4e22a08db72ab8278cfef8c"><td align="right" class="memItemLeft" valign="top">const _xmlNode* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a24634a9fb4e22a08db72ab8278cfef8c">cobj</a> () const  noexcept</td></tr>
<tr class="memdesc:a24634a9fb4e22a08db72ab8278cfef8c"><td class="mdescLeft"> </td><td class="mdescRight">Access the underlying libxml implementation.  <a href="classxmlpp_1_1Node.html#a24634a9fb4e22a08db72ab8278cfef8c">More...</a><br></br></td></tr>
<tr class="separator:a24634a9fb4e22a08db72ab8278cfef8c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aea96d8b3936718d76c192170cb188657"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aea96d8b3936718d76c192170cb188657">eval_to_boolean</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:aea96d8b3936718d76c192170cb188657"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#aea96d8b3936718d76c192170cb188657">More...</a><br></br></td></tr>
<tr class="separator:aea96d8b3936718d76c192170cb188657"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a152fac56e2454d14ad2b864502a75cc3"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a152fac56e2454d14ad2b864502a75cc3">eval_to_boolean</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:a152fac56e2454d14ad2b864502a75cc3"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a152fac56e2454d14ad2b864502a75cc3">More...</a><br></br></td></tr>
<tr class="separator:a152fac56e2454d14ad2b864502a75cc3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a27bad1d610b852ef56f6efde9e904bdf"><td align="right" class="memItemLeft" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a27bad1d610b852ef56f6efde9e904bdf">eval_to_number</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:a27bad1d610b852ef56f6efde9e904bdf"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a27bad1d610b852ef56f6efde9e904bdf">More...</a><br></br></td></tr>
<tr class="separator:a27bad1d610b852ef56f6efde9e904bdf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afa5dae05fccb14a0183fddf4ae2be0c2"><td align="right" class="memItemLeft" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#afa5dae05fccb14a0183fddf4ae2be0c2">eval_to_number</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:afa5dae05fccb14a0183fddf4ae2be0c2"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#afa5dae05fccb14a0183fddf4ae2be0c2">More...</a><br></br></td></tr>
<tr class="separator:afa5dae05fccb14a0183fddf4ae2be0c2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0d615473aa53d49a8bb6beba3b0d7fb2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a0d615473aa53d49a8bb6beba3b0d7fb2">eval_to_string</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:a0d615473aa53d49a8bb6beba3b0d7fb2"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a0d615473aa53d49a8bb6beba3b0d7fb2">More...</a><br></br></td></tr>
<tr class="separator:a0d615473aa53d49a8bb6beba3b0d7fb2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64bc8672f8ccf4cf4617b18822e5418e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a64bc8672f8ccf4cf4617b18822e5418e">eval_to_string</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* result_type=nullptr) const </td></tr>
<tr class="memdesc:a64bc8672f8ccf4cf4617b18822e5418e"><td class="mdescLeft"> </td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a64bc8672f8ccf4cf4617b18822e5418e">More...</a><br></br></td></tr>
<tr class="separator:a64bc8672f8ccf4cf4617b18822e5418e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a49686535bafb0f17cac3a3b12b8ce769"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a49686535bafb0f17cac3a3b12b8ce769">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath)</td></tr>
<tr class="memdesc:a49686535bafb0f17cac3a3b12b8ce769"><td class="mdescLeft"> </td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#a49686535bafb0f17cac3a3b12b8ce769">More...</a><br></br></td></tr>
<tr class="separator:a49686535bafb0f17cac3a3b12b8ce769"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af4b41249618df1df9d78302b5c41c604"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#af4b41249618df1df9d78302b5c41c604">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath) const </td></tr>
<tr class="memdesc:af4b41249618df1df9d78302b5c41c604"><td class="mdescLeft"> </td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#af4b41249618df1df9d78302b5c41c604">More...</a><br></br></td></tr>
<tr class="separator:af4b41249618df1df9d78302b5c41c604"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab4676913f9287edf6ff7615ef9e7b611"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ab4676913f9287edf6ff7615ef9e7b611">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces)</td></tr>
<tr class="memdesc:ab4676913f9287edf6ff7615ef9e7b611"><td class="mdescLeft"> </td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#ab4676913f9287edf6ff7615ef9e7b611">More...</a><br></br></td></tr>
<tr class="separator:ab4676913f9287edf6ff7615ef9e7b611"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7220f2c7e914afd0b9ed56aee83715d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa7220f2c7e914afd0b9ed56aee83715d">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; namespaces) const </td></tr>
<tr class="memdesc:aa7220f2c7e914afd0b9ed56aee83715d"><td class="mdescLeft"> </td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#aa7220f2c7e914afd0b9ed56aee83715d">More...</a><br></br></td></tr>
<tr class="separator:aa7220f2c7e914afd0b9ed56aee83715d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85ddea4c2314e086ef28d89436ab72a0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a85ddea4c2314e086ef28d89436ab72a0">get_children</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a85ddea4c2314e086ef28d89436ab72a0"><td class="mdescLeft"> </td><td class="mdescRight">Obtain the list of child nodes.  <a href="classxmlpp_1_1Node.html#a85ddea4c2314e086ef28d89436ab72a0">More...</a><br></br></td></tr>
<tr class="separator:a85ddea4c2314e086ef28d89436ab72a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee03540179478788353a0c584465aaf1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aee03540179478788353a0c584465aaf1">get_children</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const </td></tr>
<tr class="memdesc:aee03540179478788353a0c584465aaf1"><td class="mdescLeft"> </td><td class="mdescRight">Obtain the list of child nodes.  <a href="classxmlpp_1_1Node.html#aee03540179478788353a0c584465aaf1">More...</a><br></br></td></tr>
<tr class="separator:aee03540179478788353a0c584465aaf1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a76dab825b8a4871cf7898ce0030143e6"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a76dab825b8a4871cf7898ce0030143e6">get_first_child</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const </td></tr>
<tr class="memdesc:a76dab825b8a4871cf7898ce0030143e6"><td class="mdescLeft"> </td><td class="mdescRight">Get the first child of this node.  <a href="classxmlpp_1_1Node.html#a76dab825b8a4871cf7898ce0030143e6">More...</a><br></br></td></tr>
<tr class="separator:a76dab825b8a4871cf7898ce0030143e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee68120e2ec8e345098461b7f9ead6b0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aee68120e2ec8e345098461b7f9ead6b0">get_first_child</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:aee68120e2ec8e345098461b7f9ead6b0"><td class="mdescLeft"> </td><td class="mdescRight">Get the first child of this node.  <a href="classxmlpp_1_1Node.html#aee68120e2ec8e345098461b7f9ead6b0">More...</a><br></br></td></tr>
<tr class="separator:aee68120e2ec8e345098461b7f9ead6b0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e21f3a9996e25bd2df5ec8ce9906575"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a5e21f3a9996e25bd2df5ec8ce9906575">get_line</a> () const </td></tr>
<tr class="memdesc:a5e21f3a9996e25bd2df5ec8ce9906575"><td class="mdescLeft"> </td><td class="mdescRight">Discover at what line number this node occurs in the XML file.  <a href="classxmlpp_1_1Node.html#a5e21f3a9996e25bd2df5ec8ce9906575">More...</a><br></br></td></tr>
<tr class="separator:a5e21f3a9996e25bd2df5ec8ce9906575"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad0d08faf3bb0992a879e1d939a472832"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ad0d08faf3bb0992a879e1d939a472832">get_name</a> () const </td></tr>
<tr class="memdesc:ad0d08faf3bb0992a879e1d939a472832"><td class="mdescLeft"> </td><td class="mdescRight">Get the name of this node.  <a href="classxmlpp_1_1Node.html#ad0d08faf3bb0992a879e1d939a472832">More...</a><br></br></td></tr>
<tr class="separator:ad0d08faf3bb0992a879e1d939a472832"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a110d1aa0735fcaeb43c8ee50138bfbb0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a110d1aa0735fcaeb43c8ee50138bfbb0">get_namespace_prefix</a> () const </td></tr>
<tr class="memdesc:a110d1aa0735fcaeb43c8ee50138bfbb0"><td class="mdescLeft"> </td><td class="mdescRight">Get the namespace prefix of this node.  <a href="classxmlpp_1_1Node.html#a110d1aa0735fcaeb43c8ee50138bfbb0">More...</a><br></br></td></tr>
<tr class="separator:a110d1aa0735fcaeb43c8ee50138bfbb0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4e4da02db8954f4d82d08840b9c45604"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a4e4da02db8954f4d82d08840b9c45604">get_namespace_uri</a> () const </td></tr>
<tr class="memdesc:a4e4da02db8954f4d82d08840b9c45604"><td class="mdescLeft"> </td><td class="mdescRight">Get the namespace URI of this node.  <a href="classxmlpp_1_1Node.html#a4e4da02db8954f4d82d08840b9c45604">More...</a><br></br></td></tr>
<tr class="separator:a4e4da02db8954f4d82d08840b9c45604"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a59a3e52fd752c243654a2cb58b1b0e18"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a59a3e52fd752c243654a2cb58b1b0e18">get_next_sibling</a> () const </td></tr>
<tr class="memdesc:a59a3e52fd752c243654a2cb58b1b0e18"><td class="mdescLeft"> </td><td class="mdescRight">Get the next sibling for this node.  <a href="classxmlpp_1_1Node.html#a59a3e52fd752c243654a2cb58b1b0e18">More...</a><br></br></td></tr>
<tr class="separator:a59a3e52fd752c243654a2cb58b1b0e18"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2576ce35a6a3dd13b49e857524360ac4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a2576ce35a6a3dd13b49e857524360ac4">get_next_sibling</a> ()</td></tr>
<tr class="memdesc:a2576ce35a6a3dd13b49e857524360ac4"><td class="mdescLeft"> </td><td class="mdescRight">Get the next sibling for this node.  <a href="classxmlpp_1_1Node.html#a2576ce35a6a3dd13b49e857524360ac4">More...</a><br></br></td></tr>
<tr class="separator:a2576ce35a6a3dd13b49e857524360ac4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa8a68ac1887a33e44e3af365bd02db1b"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa8a68ac1887a33e44e3af365bd02db1b">get_parent</a> () const </td></tr>
<tr class="memdesc:aa8a68ac1887a33e44e3af365bd02db1b"><td class="mdescLeft"> </td><td class="mdescRight">Get the parent element for this node.  <a href="classxmlpp_1_1Node.html#aa8a68ac1887a33e44e3af365bd02db1b">More...</a><br></br></td></tr>
<tr class="separator:aa8a68ac1887a33e44e3af365bd02db1b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a998e8cb924bd04abf72e57b68d2817f4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a998e8cb924bd04abf72e57b68d2817f4">get_parent</a> ()</td></tr>
<tr class="memdesc:a998e8cb924bd04abf72e57b68d2817f4"><td class="mdescLeft"> </td><td class="mdescRight">Get the parent element for this node.  <a href="classxmlpp_1_1Node.html#a998e8cb924bd04abf72e57b68d2817f4">More...</a><br></br></td></tr>
<tr class="separator:a998e8cb924bd04abf72e57b68d2817f4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b41fa3ed33c91ccece3d56f97fad519"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a3b41fa3ed33c91ccece3d56f97fad519">get_path</a> () const </td></tr>
<tr class="memdesc:a3b41fa3ed33c91ccece3d56f97fad519"><td class="mdescLeft"> </td><td class="mdescRight">Get the XPath of this node.  <a href="classxmlpp_1_1Node.html#a3b41fa3ed33c91ccece3d56f97fad519">More...</a><br></br></td></tr>
<tr class="separator:a3b41fa3ed33c91ccece3d56f97fad519"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa3ca83ba6e10ff21060be5d0441fa6ac"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa3ca83ba6e10ff21060be5d0441fa6ac">get_previous_sibling</a> () const </td></tr>
<tr class="memdesc:aa3ca83ba6e10ff21060be5d0441fa6ac"><td class="mdescLeft"> </td><td class="mdescRight">Get the previous sibling for this node .  <a href="classxmlpp_1_1Node.html#aa3ca83ba6e10ff21060be5d0441fa6ac">More...</a><br></br></td></tr>
<tr class="separator:aa3ca83ba6e10ff21060be5d0441fa6ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a567be4ebaffb2cd3dd2ae602c8df4a29"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a567be4ebaffb2cd3dd2ae602c8df4a29">get_previous_sibling</a> ()</td></tr>
<tr class="memdesc:a567be4ebaffb2cd3dd2ae602c8df4a29"><td class="mdescLeft"> </td><td class="mdescRight">Get the previous sibling for this node.  <a href="classxmlpp_1_1Node.html#a567be4ebaffb2cd3dd2ae602c8df4a29">More...</a><br></br></td></tr>
<tr class="separator:a567be4ebaffb2cd3dd2ae602c8df4a29"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aea42eae72fa7901aa1fb8f5c0fd194ec"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aea42eae72fa7901aa1fb8f5c0fd194ec">import_node</a> (const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* node, bool recursive=true)</td></tr>
<tr class="memdesc:aea42eae72fa7901aa1fb8f5c0fd194ec"><td class="mdescLeft"> </td><td class="mdescRight">Import node(s) from another document under this node, without affecting the source node.  <a href="classxmlpp_1_1Node.html#aea42eae72fa7901aa1fb8f5c0fd194ec">More...</a><br></br></td></tr>
<tr class="separator:aea42eae72fa7901aa1fb8f5c0fd194ec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab57a323ddd24a12707e27efa26b2b7c1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ab57a323ddd24a12707e27efa26b2b7c1">set_name</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; name)</td></tr>
<tr class="memdesc:ab57a323ddd24a12707e27efa26b2b7c1"><td class="mdescLeft"> </td><td class="mdescRight">Set the name of this node.  <a href="classxmlpp_1_1Node.html#ab57a323ddd24a12707e27efa26b2b7c1">More...</a><br></br></td></tr>
<tr class="separator:ab57a323ddd24a12707e27efa26b2b7c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac7fb69ff6ff91d88996911da31ed5976"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ac7fb69ff6ff91d88996911da31ed5976">set_namespace</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; ns_prefix)</td></tr>
<tr class="memdesc:ac7fb69ff6ff91d88996911da31ed5976"><td class="mdescLeft"> </td><td class="mdescRight">Set the namespace prefix used by the node.  <a href="classxmlpp_1_1Node.html#ac7fb69ff6ff91d88996911da31ed5976">More...</a><br></br></td></tr>
<tr class="separator:ac7fb69ff6ff91d88996911da31ed5976"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a616a872d0fbd86206c0beee0be5abee3"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a616a872d0fbd86206c0beee0be5abee3">create_wrapper</a> (_xmlNode* node)</td></tr>
<tr class="memdesc:a616a872d0fbd86206c0beee0be5abee3"><td class="mdescLeft"> </td><td class="mdescRight">Construct the correct C++ instance for a given libxml C struct instance.  <a href="classxmlpp_1_1Node.html#a616a872d0fbd86206c0beee0be5abee3">More...</a><br></br></td></tr>
<tr class="separator:a616a872d0fbd86206c0beee0be5abee3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa47901df78305a685fc9682cd44290d6"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa47901df78305a685fc9682cd44290d6">free_wrappers</a> (_xmlNode* node)</td></tr>
<tr class="memdesc:aa47901df78305a685fc9682cd44290d6"><td class="mdescLeft"> </td><td class="mdescRight">Delete the C++ instance for a given libxml C struct instance, and also recursively destroy the C++ instances for any children.  <a href="classxmlpp_1_1Node.html#aa47901df78305a685fc9682cd44290d6">More...</a><br></br></td></tr>
<tr class="separator:aa47901df78305a685fc9682cd44290d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af3af70bdc909d8d272b3df0634fb291b"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#af3af70bdc909d8d272b3df0634fb291b">remove_node</a> (<a class="el" href="classxmlpp_1_1Node.html">Node</a>* node)</td></tr>
<tr class="memdesc:af3af70bdc909d8d272b3df0634fb291b"><td class="mdescLeft"> </td><td class="mdescRight">Remove a node and its children.  <a href="classxmlpp_1_1Node.html#af3af70bdc909d8d272b3df0634fb291b">More...</a><br></br></td></tr>
<tr class="separator:af3af70bdc909d8d272b3df0634fb291b"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classxmlpp_1_1NonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classxmlpp_1_1NonCopyable')"><img alt="-" src="closed.png"></img> Protected Member Functions inherited from <a class="el" href="classxmlpp_1_1NonCopyable.html">xmlpp::NonCopyable</a></td></tr>
<tr class="memitem:a96e2e5582c5bb88b2dea2adb9f9512e2 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a96e2e5582c5bb88b2dea2adb9f9512e2">NonCopyable</a> () noexcept</td></tr>
<tr class="separator:a96e2e5582c5bb88b2dea2adb9f9512e2 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aded750a42a8acdd5ed63827c158f7763 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#aded750a42a8acdd5ed63827c158f7763">NonCopyable</a> (const <a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp;)=delete</td></tr>
<tr class="separator:aded750a42a8acdd5ed63827c158f7763 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a537645a43274a8d742eed00a35ffb917 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a537645a43274a8d742eed00a35ffb917">NonCopyable</a> (<a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp;&amp;)=delete</td></tr>
<tr class="separator:a537645a43274a8d742eed00a35ffb917 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a14e2e0391beb4b8f20f5d51e8a253d63 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top">virtual </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a14e2e0391beb4b8f20f5d51e8a253d63">~NonCopyable</a> ()</td></tr>
<tr class="separator:a14e2e0391beb4b8f20f5d51e8a253d63 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adef35c286da3c2b8c90da9bb50aaddf1 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#adef35c286da3c2b8c90da9bb50aaddf1">operator=</a> (const <a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp;)=delete</td></tr>
<tr class="separator:adef35c286da3c2b8c90da9bb50aaddf1 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9888c9e5345760386ac57ff6439a30e4 inherit pro_methods_classxmlpp_1_1NonCopyable"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a9888c9e5345760386ac57ff6439a30e4">operator=</a> (<a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a>&amp;&amp;)=delete</td></tr>
<tr class="separator:a9888c9e5345760386ac57ff6439a30e4 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents XML Nodes. </p>
<p>You should never new and delete Nodes. The <a class="el" href="classxmlpp_1_1Parser.html" title="XML parser. ">Parser</a> will create and manage them for you. Furthermore, <a class="el" href="classxmlpp_1_1Document.html" title="Represents an XML document in the DOM model. ">Document</a> and <a class="el" href="classxmlpp_1_1Element.html" title="Element nodes have attributes as well as child nodes. ">Element</a> have methods for adding Nodes to a <a class="el" href="classxmlpp_1_1Document.html" title="Represents an XML document in the DOM model. ">Document</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a97f19f7f19c763f616eadb702680826f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">xmlpp::Node::const_NodeList</a> =  <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt;const <a class="el" href="classxmlpp_1_1Node.html">Node</a>*&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a57dba85e747dbe53ff768955bc3ca46b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">xmlpp::Node::const_NodeSet</a> =  <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt;const <a class="el" href="classxmlpp_1_1Node.html">Node</a>*&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aec484e80254d11ae0f7046e011287a18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">xmlpp::Node::NodeList</a> =  <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06712.html">std::list</a>&lt;<a class="el" href="classxmlpp_1_1Node.html">Node</a>*&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aabbb1903a13e213fa94898a76518ebc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">xmlpp::Node::NodeSet</a> =  <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06912.html">std::vector</a>&lt;<a class="el" href="classxmlpp_1_1Node.html">Node</a>*&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a17584286cf6aea618a6d0878add65450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">xmlpp::Node::PrefixNsMap</a> =  <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06720.html">std::map</a>&lt;<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>, <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A map of namespace prefixes to namespace URIs. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a215d8c01b6b01596c4ea853f99dce8e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">xmlpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype">_xmlNode * </td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If <em>node</em> is <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed8dc1eea15e3e1ac42b43a49c3016ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">xmlpp::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Does not destroy the underlying xmlNode. The xmlNode is owned by a xmlDoc document. If you want to also destroy the xmlNode, use <a class="el" href="classxmlpp_1_1Node.html#af3af70bdc909d8d272b3df0634fb291b" title="Remove a node and its children. ">remove_node()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a648a236bfd53dcf4405446c8569d71b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">_xmlNode* xmlpp::Node::cobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Access the underlying libxml implementation. </p>

</div>
</div>
<a class="anchor" id="a24634a9fb4e22a08db72ab8278cfef8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const _xmlNode* xmlpp::Node::cobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Access the underlying libxml implementation. </p>

</div>
</div>
<a class="anchor" id="a616a872d0fbd86206c0beee0be5abee3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static void xmlpp::Node::create_wrapper </td>
          <td>(</td>
          <td class="paramtype">_xmlNode * </td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Construct the correct C++ instance for a given libxml C struct instance. </p>
<p>This is only for use by the libxml++ implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">node</td><td>A pointer to an xmlNode or a "derived" struct, such as xmlDoc, xmlAttr, etc. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea96d8b3936718d76c192170cb188657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool xmlpp::Node::eval_to_boolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* </td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to boolean. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type boolean, it is converted to boolean. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000012">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a152fac56e2454d14ad2b864502a75cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool xmlpp::Node::eval_to_boolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; </td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* </td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while evaluating. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to boolean. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type boolean, it is converted to boolean. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000013">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a27bad1d610b852ef56f6efde9e904bdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">double xmlpp::Node::eval_to_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* </td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to number. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type number, it is converted to number. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000014">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afa5dae05fccb14a0183fddf4ae2be0c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">double xmlpp::Node::eval_to_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; </td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* </td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while evaluating. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to number. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type number, it is converted to number. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000015">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0d615473aa53d49a8bb6beba3b0d7fb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::eval_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* </td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to string. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type string, it is converted to string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000016">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a64bc8672f8ccf4cf4617b18822e5418e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::eval_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; </td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a>* </td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while evaluating. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to string. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type string, it is converted to string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000017">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a49686535bafb0f17cac3a3b12b8ce769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> xmlpp::Node::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Find nodes from an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">xpath</td><td>The XPath of the nodes. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting NodeSet. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If the result type is not nodeset. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4b41249618df1df9d78302b5c41c604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> xmlpp::Node::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Find nodes from an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">xpath</td><td>The XPath of the nodes. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting const_NodeSet. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If the result type is not nodeset. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4676913f9287edf6ff7615ef9e7b611"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> xmlpp::Node::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; </td>
          <td class="paramname"><em>namespaces</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Find nodes from an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">xpath</td><td>The XPath of the nodes. </td></tr>
    <tr><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while finding. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting NodeSet. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If the result type is not nodeset. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7220f2c7e914afd0b9ed56aee83715d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> xmlpp::Node::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a>&amp; </td>
          <td class="paramname"><em>namespaces</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Find nodes from an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">xpath</td><td>The XPath of the nodes. </td></tr>
    <tr><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while finding. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting const_NodeSet. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If the result type is not nodeset. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa47901df78305a685fc9682cd44290d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static void xmlpp::Node::free_wrappers </td>
          <td>(</td>
          <td class="paramtype">_xmlNode * </td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Delete the C++ instance for a given libxml C struct instance, and also recursively destroy the C++ instances for any children. </p>
<p>This is only for use by the libxml++ implementation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">node</td><td>A pointer to an xmlNode or a "derived" struct, such as xmlDoc, xmlAttr, etc. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85ddea4c2314e086ef28d89436ab72a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a> xmlpp::Node::get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtain the list of child nodes. </p>
<p>You may optionally obtain a list of only the child nodes which have a certain name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The names of the child nodes to get. If you do not specify a name, then the list will contain all nodes, regardless of their names. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of child nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="aee03540179478788353a0c584465aaf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a> xmlpp::Node::get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtain the list of child nodes. </p>
<p>You may optionally obtain a list of only the child nodes which have a certain name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The names of the child nodes to get. If you do not specify a name, then the list will contain all nodes, regardless of their names. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of child nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a76dab825b8a4871cf7898ce0030143e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_first_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the first child of this node. </p>
<p>You may optionally get the first child node which has a certain name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The name of the requested child node, or an empty string. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first child, or <code>nullptr</code> if no child node (with the specified name) exists.</dd></dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000010">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aee68120e2ec8e345098461b7f9ead6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_first_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the first child of this node. </p>
<p>You may optionally get the first child node which has a certain name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The name of the requested child node, or an empty string. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first child, or <code>nullptr</code> if no child node (with the specified name) exists.</dd></dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000011">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5e21f3a9996e25bd2df5ec8ce9906575"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int xmlpp::Node::get_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Discover at what line number this node occurs in the XML file. </p>
<dl class="section return"><dt>Returns</dt><dd>The line number. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0d08faf3bb0992a879e1d939a472832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the name of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The node's name. </dd></dl>

</div>
</div>
<a class="anchor" id="a110d1aa0735fcaeb43c8ee50138bfbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::get_namespace_prefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the namespace prefix of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The node's namespace prefix. Can be an empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e4da02db8954f4d82d08840b9c45604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::get_namespace_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the namespace URI of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The node's namespace URI. Can be an empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="a59a3e52fd752c243654a2cb58b1b0e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_next_sibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the next sibling for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The next sibling, or <code>nullptr</code> if the node has no next sibling. </dd></dl>

</div>
</div>
<a class="anchor" id="a2576ce35a6a3dd13b49e857524360ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_next_sibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the next sibling for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The next sibling, or <code>nullptr</code> if the node has no next sibling. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a68ac1887a33e44e3af365bd02db1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Node::get_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the parent element for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The parent node, or <code>nullptr</code> if the node has no parent element. </dd></dl>

</div>
</div>
<a class="anchor" id="a998e8cb924bd04abf72e57b68d2817f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Node::get_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the parent element for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The parent node, or <code>nullptr</code> if the node has no parent element. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b41fa3ed33c91ccece3d56f97fad519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::get_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the XPath of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The XPath of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3ca83ba6e10ff21060be5d0441fa6ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_previous_sibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the previous sibling for this node . </p>
<dl class="section return"><dt>Returns</dt><dd>The previous sibling, or <code>nullptr</code> if the node has no previous sibling. </dd></dl>

</div>
</div>
<a class="anchor" id="a567be4ebaffb2cd3dd2ae602c8df4a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_previous_sibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the previous sibling for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The previous sibling, or <code>nullptr</code> if the node has no previous sibling. </dd></dl>

</div>
</div>
<a class="anchor" id="aea42eae72fa7901aa1fb8f5c0fd194ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::import_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>recursive</em> = <code>true</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Import node(s) from another document under this node, without affecting the source node. </p>
<p>If the imported node is an attribute node, and this node has an attribute with the same name as the imported attribute, the existing attribute is destroyed before the imported attribute is added. Any pointer to a destroyed attribute node becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">node</td><td>The node to copy and insert under the current node. </td></tr>
    <tr><td class="paramname">recursive</td><td>Whether to import the child nodes also. Defaults to true. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Usually the newly created node, but adjacent text nodes are merged, and the old text node with merged contents is returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3af70bdc909d8d272b3df0634fb291b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static void xmlpp::Node::remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* </td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Remove a node and its children. </p>
<p>The node is disconnected from its parent. The underlying libxml xmlNode instances are also removed.</p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000020">Since libxml++ 3.0:</a></b></dt><dd>Replaces remove_child()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">node</td><td>The node to remove. This <a class="el" href="classxmlpp_1_1Node.html" title="Represents XML Nodes. ">Node</a> and all its descendants will be deleted and therefore unusable after calling this method. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab57a323ddd24a12707e27efa26b2b7c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void xmlpp::Node::set_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Set the name of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>The new name for the node. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7fb69ff6ff91d88996911da31ed5976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void xmlpp::Node::set_namespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&amp; </td>
          <td class="paramname"><em>ns_prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Set the namespace prefix used by the node. </p>
<p>If no such namespace prefix has been declared then this method will throw an exception. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ns_prefix</td><td>The namespace prefix. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions. ">xmlpp::exception</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
</div></div></div><div id="footer_art" class="default"> </div></div><div class="clearfix"></div><div id="footer_grass">   </div><div id="footer"><div class="container_12"><div class="links grid_9"><div class="menu-footer-1-container"><ul id="menu-footer-1" class="menu"><li id="menu-item-88" class="menu-item menu-item-type-custom menu-item-home menu-item-88"><a href="https://www.gnome.org/">The GNOME Project</a><ul class="sub-menu"><li id="menu-item-89" class="menu-item menu-item-type-post_type menu-item-89"><a href="https://www.gnome.org/about/">About Us</a></li><li id="menu-item-90" class="menu-item menu-item-type-custom menu-item-90"><a href="https://www.gnome.org/get-involved/">Get Involved</a></li><li id="menu-item-91" class="menu-item menu-item-type-custom menu-item-91"><a href="https://www.gnome.org/teams/">Teams</a></li><li id="menu-item-92" class="menu-item menu-item-type-custom menu-item-92"><a href="https://foundation.gnome.org">The GNOME Foundation</a></li><li><a href="https://www.gnome.org/support-gnome/">Support GNOME</a></li><li><a href="https://www.gnome.org/contact/">Contact</a></li></ul></li></ul></div><div class="menu-footer-2-container"><ul id="menu-footer-2" class="menu"><li id="menu-item-99" class="menu-item menu-item-type-post_type current-menu-item page_item page-item-20 current_page_item menu-item-99"><a href="classxmlpp_1_1Node.html#">Resources</a><ul class="sub-menu"><li><a href="https://help.gnome.org">Documentation</a></li><li><a href="https://wiki.gnome.org">Wiki</a></li><li><a href="https://mail.gnome.org/mailman/listinfo">Mailing Lists</a></li><li><a href="https://wiki.gnome.org/GnomeIrcChannels">IRC Channels</a></li><li><a href="https://gitlab.gnome.org/">Bug Tracker</a></li><li><a href="https://gitlab.gnome.org/">Development Code</a></li><li><a href="https://wiki.gnome.org/Jhbuild">Build Tool</a></li></ul></li></ul></div><div class="menu-footer-4-container"><ul id="menu-footer-4" class="menu"><li id="menu-item-104" class="menu-item menu-item-type-custom menu-item-104"><a href="http://www.gnome.org/news/">News</a><ul class="sub-menu"><li><a href="https://www.gnome.org/start/stable">Latest Release</a></li><li><a href="https://planet.gnome.org">Planet GNOME</a></li><li><a href="https://news.gnome.org">Development News</a></li><li><a href="https://twitter.com/gnome">Twitter</a></li></ul></li></ul></div></div><div class="links grid_3 right"><div><ul class="menu available_languages"><li><strong>This website is available in many languages</strong><ul class="sub-menu"><li><a href="../../languages.html" title="Switching Language">Switch Language</a></li></ul></li></ul><script type="text/javascript" src="../../js/language.js"></script></div></div><div id="footnotes" class="grid_9">
                Copyright © 2005‒2014 <strong class="gnome_logo">The GNOME Project</strong><br></br><small>Optimised for standards. Hosted by <a href="http://redhat.com">Red Hat</a>.</small></div><div class="clear"></div></div></div><script type="text/javascript">
$(document).ready(function() {
    // Get browser
    $.each($.browser, function(i) {
        $('body').addClass(i);
        return false;
    });

    // Get OS and add it as class to body tag, this then allows forcing some
    // customisation in the CSS rules.
    var match = navigator.userAgent.toLowerCase().match(/(win|mac|linux)/);
    if (match) {
        $('body').addClass(match[0]);
    }
});
</script><script type="text/javascript">
      var _paq = _paq || [];
      _paq.push(['disableCookies']);
      _paq.push(["trackPageView"]);
      _paq.push(["enableLinkTracking"]);

      (function() {
        var u=(("https:" == document.location.protocol) ? "https" : "http") + "://webstats.gnome.org/";
        _paq.push(["setTrackerUrl", u+"piwik.php"]);
        _paq.push(["setSiteId", "6"]);
        var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";
        g.defer=true; g.async=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);
      })();
    </script></body></html>
