<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8"></meta><link rel="stylesheet" href="../../skin/doxygen.css" type="text/css"></link><link rel="stylesheet" type="text/css" media="all" href="https://static.gnome.org/css/grass-theme-style.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/lgo2010.css"></link><link rel="icon" type="image/png" href="../../skin/gnome-16.png"></link><link rel="SHORTCUT ICON" type="image/png" href="../../skin/gnome-16.png"></link><link rel="search" type="application/opensearchdescription+xml" href="../../gnome-library-search.xml" title="GNOME Library Search"></link><link rel="stylesheet" type="text/css" href="../../skin/jquery.autocomplete.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script><title>glibmm: Gio::File Class Reference</title><link rel="stylesheet" type="text/css" media="all" href="../../skin/jquery.autocomplete.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/960_24_col.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="https://developer-old.gnome.org/js/jquery.jcarousel.min.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script></head><body><div id="accessibility_access"><ul><li><a href="classGio_1_1File.html#container">Go to page content</a></li><li><a href="classGio_1_1File.html#top_bar">Go to main menu</a></li><li><a href="classGio_1_1File.html#s" onclick="$('#s').focus(); return false;">Go to the search field</a></li></ul></div><div id="global_domain_bar"><div class="maxwidth"><div class="tab"><a class="root" href="https://www.gnome.org/">GNOME.org</a></div></div></div><div id="header" class="container_12"><div id="logo" class="grid_3"><a title="Go to home page" href="../../index.html"><img alt="GNOME: The Free Software Desktop Project" src="../../skin/gnome-logo-devcenter.png"></img></a></div><div id="top_bar" class="grid_9"><div class="left"><div class="menu-globalnav-container"><ul id="menu-globalnav" class="menu"><li class="menu-item menu-item-type-post_type menu-item-6"><a href="../../about/index.html">About</a></li><li class="menu-item menu-item-type-post_type menu-item-23"><a href="https://help.gnome.org/users/">Users</a></li><li class="menu-item menu-item-type-post_type menu-item-40"><a href="https://help.gnome.org/admin/">Administrators</a></li><li class="current-menu-item"><a href="https://developer.gnome.org/">Developers</a></li></ul></div></div><div class="right"><form role="search" method="get" id="searchform" action="https://developer-old.gnome.org/symbols/"><div><label class="hidden" for="q">Search:
                        </label><input type="text" value="" name="q" id="s" placeholder="Search"></input></div></form><script type="text/javascript">
$('#s').autocomplete('/symbols/lookup/',
        { minChars:3, matchSubset:1, matchContains:1, cacheLength:10,
          selectOnly:1, rowsLimit:25 });
              </script></div></div></div><div class="clearfix"></div><div id="container" class="gtkmm"><div class="content"><h1 class="lgotitle">glibmm: Gio::File Class Reference</h1><div id="content"><div class="tabs" id="navrow1">
    <ul class="tablist">
      <li><a href="index.html"><span>Main Page</span></a></li>
      <li><a href="pages.html"><span>Related Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div><div class="contents">

<p><a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> and directory handling.  
 <a href="classGio_1_1File.html#details">More...</a></p>

<p><code>#include &lt;giomm/file.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::File:</div>
<div class="dyncontent">
<div class="center"><img alt="Inheritance graph" border="0" src="classGio_1_1File__inherit__graph.png" usemap="#Gio_1_1File_inherit__map"></img></div>
<map id="Gio_1_1File_inherit__map" name="Gio_1_1File_inherit__map">
<area alt="" coords="13,229,128,256" href="classGlib_1_1Interface.html" id="node2" shape="rect" title="Glib::Interface"></area>
<area alt="" coords="5,155,136,181" href="classGlib_1_1ObjectBase.html" id="node3" shape="rect" title="Glib::ObjectBase is a common base class for Objects and Interfaces. "></area>
<area alt="" coords="13,80,129,107" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html" id="node4" shape="rect" title="sigc::trackable"></area>
<area alt="" coords="12,5,129,32" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html" id="node5" shape="rect" title="sigc::notifiable"></area>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ac8e3eb55eab168a75d934edcb2ab22"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a> = sigc::slot&lt; void(goffset, goffset)&gt;</td></tr>
<tr class="memdesc:a8ac8e3eb55eab168a75d934edcb2ab22"><td class="mdescLeft"> </td><td class="mdescRight">A signal handler would be, for instance: void on_file_progress(goffset current_num_bytes, goffset total_num_bytes);.  <a href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">More...</a><br></br></td></tr>
<tr class="separator:a8ac8e3eb55eab168a75d934edcb2ab22"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa42b589db64b478d6074a80cf2099729"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa42b589db64b478d6074a80cf2099729">SlotFileMeasureProgress</a> = sigc::slot&lt; void(bool, guint64, guint64, guint64)&gt;</td></tr>
<tr class="memdesc:aa42b589db64b478d6074a80cf2099729"><td class="mdescLeft"> </td><td class="mdescRight">This slot type is used by <a class="el" href="classGio_1_1File.html#a7841ac4282c5ae77cb70e00863083154" title="Recursively measures the disk usage of the file. ">measure_disk_usage()</a> to make periodic progress reports when measuring the amount of disk spaced used by a directory.  <a href="classGio_1_1File.html#aa42b589db64b478d6074a80cf2099729">More...</a><br></br></td></tr>
<tr class="separator:aa42b589db64b478d6074a80cf2099729"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5977e55c02f52afc78d9091cd3eab8ed"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5977e55c02f52afc78d9091cd3eab8ed">SlotReadMore</a> = sigc::slot&lt; bool(const char*, goffset)&gt;</td></tr>
<tr class="memdesc:a5977e55c02f52afc78d9091cd3eab8ed"><td class="mdescLeft"> </td><td class="mdescRight">A signal handler would be, for instance: bool on_read_more(const char* file_contents, goffset file_size);.  <a href="classGio_1_1File.html#a5977e55c02f52afc78d9091cd3eab8ed">More...</a><br></br></td></tr>
<tr class="separator:a5977e55c02f52afc78d9091cd3eab8ed"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_types_structsigc_1_1trackable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structsigc_1_1trackable')"><img alt="-" src="closed.png"></img> Public Types inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a></td></tr>
<tr class="memitem:a1721dff57885c3ff2bc409538ceb8097 inherit pub_types_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top">typedef internal::func_destroy_notify </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a1721dff57885c3ff2bc409538ceb8097">func_destroy_notify</a></td></tr>
<tr class="separator:a1721dff57885c3ff2bc409538ceb8097 inherit pub_types_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_types_structsigc_1_1notifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structsigc_1_1notifiable')"><img alt="-" src="closed.png"></img> Public Types inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html">sigc::notifiable</a></td></tr>
<tr class="memitem:a71455cae4b10ff1277e68a1729e1b8c4 inherit pub_types_structsigc_1_1notifiable"><td align="right" class="memItemLeft" valign="top">typedef internal::func_destroy_notify </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html#a71455cae4b10ff1277e68a1729e1b8c4">func_destroy_notify</a></td></tr>
<tr class="separator:a71455cae4b10ff1277e68a1729e1b8c4 inherit pub_types_structsigc_1_1notifiable"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91341a5c27005398bef11c6b232f2ec8"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a91341a5c27005398bef11c6b232f2ec8">File</a> (<a class="el" href="classGio_1_1File.html">File</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a91341a5c27005398bef11c6b232f2ec8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af4d8c21aa35f4703e0b46b04ae2f5b82"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGio_1_1File.html">File</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af4d8c21aa35f4703e0b46b04ae2f5b82">operator=</a> (<a class="el" href="classGio_1_1File.html">File</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:af4d8c21aa35f4703e0b46b04ae2f5b82"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adf1624302e7d139bbf462eb35cf6ddd0"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#adf1624302e7d139bbf462eb35cf6ddd0">~File</a> () noexcept override</td></tr>
<tr class="separator:adf1624302e7d139bbf462eb35cf6ddd0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a96552cfbaf2e5fa3659a1568db8cca91"><td align="right" class="memItemLeft" valign="top">GFile* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a96552cfbaf2e5fa3659a1568db8cca91">gobj</a> ()</td></tr>
<tr class="memdesc:a96552cfbaf2e5fa3659a1568db8cca91"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1File.html#a96552cfbaf2e5fa3659a1568db8cca91">More...</a><br></br></td></tr>
<tr class="separator:a96552cfbaf2e5fa3659a1568db8cca91"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5437bc648d8b73451e8bee0bc902cfc0"><td align="right" class="memItemLeft" valign="top">const GFile* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5437bc648d8b73451e8bee0bc902cfc0">gobj</a> () const </td></tr>
<tr class="memdesc:a5437bc648d8b73451e8bee0bc902cfc0"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1File.html#a5437bc648d8b73451e8bee0bc902cfc0">More...</a><br></br></td></tr>
<tr class="separator:a5437bc648d8b73451e8bee0bc902cfc0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9ea238062cdc317ae982ffae5c226c9b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b">dup</a> () const </td></tr>
<tr class="memdesc:a9ea238062cdc317ae982ffae5c226c9b"><td class="mdescLeft"> </td><td class="mdescRight">Duplicates a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> handle.  <a href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b">More...</a><br></br></td></tr>
<tr class="separator:a9ea238062cdc317ae982ffae5c226c9b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0320bac72ecc9ced1f894f1af696856f"><td align="right" class="memItemLeft" valign="top">guint </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0320bac72ecc9ced1f894f1af696856f">hash</a> () const </td></tr>
<tr class="memdesc:a0320bac72ecc9ced1f894f1af696856f"><td class="mdescLeft"> </td><td class="mdescRight">Creates a hash value for a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>.  <a href="classGio_1_1File.html#a0320bac72ecc9ced1f894f1af696856f">More...</a><br></br></td></tr>
<tr class="separator:a0320bac72ecc9ced1f894f1af696856f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8877115c870ea8f58b03d1d3c01a83e4"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8877115c870ea8f58b03d1d3c01a83e4">equal</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; other) const </td></tr>
<tr class="memdesc:a8877115c870ea8f58b03d1d3c01a83e4"><td class="mdescLeft"> </td><td class="mdescRight">Checks equality of two given Files.  <a href="classGio_1_1File.html#a8877115c870ea8f58b03d1d3c01a83e4">More...</a><br></br></td></tr>
<tr class="separator:a8877115c870ea8f58b03d1d3c01a83e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac731bed45bb7fcfd411eb69c49d3b883"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac731bed45bb7fcfd411eb69c49d3b883">get_basename</a> () const </td></tr>
<tr class="memdesc:ac731bed45bb7fcfd411eb69c49d3b883"><td class="mdescLeft"> </td><td class="mdescRight">Gets the base name (the last component of the path) for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>.  <a href="classGio_1_1File.html#ac731bed45bb7fcfd411eb69c49d3b883">More...</a><br></br></td></tr>
<tr class="separator:ac731bed45bb7fcfd411eb69c49d3b883"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b3edc7946b681b6db2cdcdad08d2b00"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7b3edc7946b681b6db2cdcdad08d2b00">get_path</a> () const </td></tr>
<tr class="memdesc:a7b3edc7946b681b6db2cdcdad08d2b00"><td class="mdescLeft"> </td><td class="mdescRight">Gets the local pathname for <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>, if one exists.  <a href="classGio_1_1File.html#a7b3edc7946b681b6db2cdcdad08d2b00">More...</a><br></br></td></tr>
<tr class="separator:a7b3edc7946b681b6db2cdcdad08d2b00"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d1313e4a4eb5de034b693ec1cc9fba0"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2d1313e4a4eb5de034b693ec1cc9fba0">get_uri</a> () const </td></tr>
<tr class="memdesc:a2d1313e4a4eb5de034b693ec1cc9fba0"><td class="mdescLeft"> </td><td class="mdescRight">Gets the URI for the <em>file</em>.  <a href="classGio_1_1File.html#a2d1313e4a4eb5de034b693ec1cc9fba0">More...</a><br></br></td></tr>
<tr class="separator:a2d1313e4a4eb5de034b693ec1cc9fba0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aea4a78163e3085a35cbaacde9a3a7628"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aea4a78163e3085a35cbaacde9a3a7628">get_parse_name</a> () const </td></tr>
<tr class="memdesc:aea4a78163e3085a35cbaacde9a3a7628"><td class="mdescLeft"> </td><td class="mdescRight">Gets the parse name of the <em>file</em>.  <a href="classGio_1_1File.html#aea4a78163e3085a35cbaacde9a3a7628">More...</a><br></br></td></tr>
<tr class="separator:aea4a78163e3085a35cbaacde9a3a7628"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af39bbd5013b2dd675911df322e12ff94"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94">get_parent</a> () const </td></tr>
<tr class="memdesc:af39bbd5013b2dd675911df322e12ff94"><td class="mdescLeft"> </td><td class="mdescRight">Gets the parent directory for the <em>file</em>.  <a href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94">More...</a><br></br></td></tr>
<tr class="separator:af39bbd5013b2dd675911df322e12ff94"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae0b0d16b849b2f92699ad57ee7c935d9"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae0b0d16b849b2f92699ad57ee7c935d9">has_parent</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; parent) const </td></tr>
<tr class="memdesc:ae0b0d16b849b2f92699ad57ee7c935d9"><td class="mdescLeft"> </td><td class="mdescRight">Checks if <em>file</em> has a parent, and optionally, if it is <em>parent</em>.  <a href="classGio_1_1File.html#ae0b0d16b849b2f92699ad57ee7c935d9">More...</a><br></br></td></tr>
<tr class="separator:ae0b0d16b849b2f92699ad57ee7c935d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa1daee0498c403e83ac509e6157edd1c"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa1daee0498c403e83ac509e6157edd1c">has_parent</a> () const </td></tr>
<tr class="memdesc:aa1daee0498c403e83ac509e6157edd1c"><td class="mdescLeft"> </td><td class="mdescRight">Checks if the file has any parent at all.  <a href="classGio_1_1File.html#aa1daee0498c403e83ac509e6157edd1c">More...</a><br></br></td></tr>
<tr class="separator:aa1daee0498c403e83ac509e6157edd1c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a53c533d6bbeaaadd1b5592cf1e5ef93c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c">get_child</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; name) const </td></tr>
<tr class="memdesc:a53c533d6bbeaaadd1b5592cf1e5ef93c"><td class="mdescLeft"> </td><td class="mdescRight">Gets a child of <em>file</em> with basename equal to <em>name</em>.  <a href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c">More...</a><br></br></td></tr>
<tr class="separator:a53c533d6bbeaaadd1b5592cf1e5ef93c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a479cfd632af30b29e125f904f809ed71"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a479cfd632af30b29e125f904f809ed71">get_child_for_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name) const </td></tr>
<tr class="memdesc:a479cfd632af30b29e125f904f809ed71"><td class="mdescLeft"> </td><td class="mdescRight">Gets the child of <em>file</em> for a given <em>display_name</em> (i.e. a UTF-8 version of the name).  <a href="classGio_1_1File.html#a479cfd632af30b29e125f904f809ed71">More...</a><br></br></td></tr>
<tr class="separator:a479cfd632af30b29e125f904f809ed71"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4c40ec88dfc4333f19e939d26a1e0332"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4c40ec88dfc4333f19e939d26a1e0332">has_prefix</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; prefix) const </td></tr>
<tr class="memdesc:a4c40ec88dfc4333f19e939d26a1e0332"><td class="mdescLeft"> </td><td class="mdescRight">Checks whether <em>file</em> has the prefix specified by <em>prefix</em>.  <a href="classGio_1_1File.html#a4c40ec88dfc4333f19e939d26a1e0332">More...</a><br></br></td></tr>
<tr class="separator:a4c40ec88dfc4333f19e939d26a1e0332"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a464248111fa2bc5df89c620354eb99bb"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a464248111fa2bc5df89c620354eb99bb">get_relative_path</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; descendant) const </td></tr>
<tr class="memdesc:a464248111fa2bc5df89c620354eb99bb"><td class="mdescLeft"> </td><td class="mdescRight">Gets the path for <em>descendant</em> relative to <em>parent</em>.  <a href="classGio_1_1File.html#a464248111fa2bc5df89c620354eb99bb">More...</a><br></br></td></tr>
<tr class="separator:a464248111fa2bc5df89c620354eb99bb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac5e286d421c7236df39881f8ce0a4e03"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03">resolve_relative_path</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; relative_path) const </td></tr>
<tr class="memdesc:ac5e286d421c7236df39881f8ce0a4e03"><td class="mdescLeft"> </td><td class="mdescRight">Resolves a relative path for <em>file</em> to an absolute path.  <a href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03">More...</a><br></br></td></tr>
<tr class="separator:ac5e286d421c7236df39881f8ce0a4e03"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaa3b910bc9f240d4ebd0efc70979f163"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aaa3b910bc9f240d4ebd0efc70979f163">is_native</a> () const </td></tr>
<tr class="memdesc:aaa3b910bc9f240d4ebd0efc70979f163"><td class="mdescLeft"> </td><td class="mdescRight">Checks to see if a file is native to the platform.  <a href="classGio_1_1File.html#aaa3b910bc9f240d4ebd0efc70979f163">More...</a><br></br></td></tr>
<tr class="separator:aaa3b910bc9f240d4ebd0efc70979f163"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a90d71529e5b51b9ff73914eaf90be0f1"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a90d71529e5b51b9ff73914eaf90be0f1">has_uri_scheme</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; uri_scheme) const </td></tr>
<tr class="memdesc:a90d71529e5b51b9ff73914eaf90be0f1"><td class="mdescLeft"> </td><td class="mdescRight">Checks to see if a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> has a given URI scheme.  <a href="classGio_1_1File.html#a90d71529e5b51b9ff73914eaf90be0f1">More...</a><br></br></td></tr>
<tr class="separator:a90d71529e5b51b9ff73914eaf90be0f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeecec6962f955bd72ac5595be37db7a4"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aeecec6962f955bd72ac5595be37db7a4">get_uri_scheme</a> () const </td></tr>
<tr class="memdesc:aeecec6962f955bd72ac5595be37db7a4"><td class="mdescLeft"> </td><td class="mdescRight">Gets the URI scheme for a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>.  <a href="classGio_1_1File.html#aeecec6962f955bd72ac5595be37db7a4">More...</a><br></br></td></tr>
<tr class="separator:aeecec6962f955bd72ac5595be37db7a4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3ef959c7ad7096846f26eb8b282e3c68"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3ef959c7ad7096846f26eb8b282e3c68">read</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a3ef959c7ad7096846f26eb8b282e3c68"><td class="mdescLeft"> </td><td class="mdescRight">Opens a file for reading.  <a href="classGio_1_1File.html#a3ef959c7ad7096846f26eb8b282e3c68">More...</a><br></br></td></tr>
<tr class="separator:a3ef959c7ad7096846f26eb8b282e3c68"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0395b3b0b8cec5dc1fd9953e52e5fbc1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1">read</a> ()</td></tr>
<tr class="memdesc:a0395b3b0b8cec5dc1fd9953e52e5fbc1"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="A read() convenience overload. ">read()</a> convenience overload.  <a href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1">More...</a><br></br></td></tr>
<tr class="separator:a0395b3b0b8cec5dc1fd9953e52e5fbc1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2826eed0b1e76c3771f6ad5f5b993991"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2826eed0b1e76c3771f6ad5f5b993991">read_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a2826eed0b1e76c3771f6ad5f5b993991"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously opens the file for reading.  <a href="classGio_1_1File.html#a2826eed0b1e76c3771f6ad5f5b993991">More...</a><br></br></td></tr>
<tr class="separator:a2826eed0b1e76c3771f6ad5f5b993991"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab451a182a647408e697c9115e66f6194"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab451a182a647408e697c9115e66f6194">read_async</a> (const SlotAsyncReady&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ab451a182a647408e697c9115e66f6194"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously opens the file for reading.  <a href="classGio_1_1File.html#ab451a182a647408e697c9115e66f6194">More...</a><br></br></td></tr>
<tr class="separator:ab451a182a647408e697c9115e66f6194"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3e71d2cd04c5c9c17a51fe8f1dc87c78"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3e71d2cd04c5c9c17a51fe8f1dc87c78">read_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a3e71d2cd04c5c9c17a51fe8f1dc87c78"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous file read operation started with g_file_read_async().  <a href="classGio_1_1File.html#a3e71d2cd04c5c9c17a51fe8f1dc87c78">More...</a><br></br></td></tr>
<tr class="separator:a3e71d2cd04c5c9c17a51fe8f1dc87c78"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8749bba26443b6adab85c0cf5d69a93"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8749bba26443b6adab85c0cf5d69a93">append_to</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:ad8749bba26443b6adab85c0cf5d69a93"><td class="mdescLeft"> </td><td class="mdescRight">Gets an output stream for appending data to the file.  <a href="classGio_1_1File.html#ad8749bba26443b6adab85c0cf5d69a93">More...</a><br></br></td></tr>
<tr class="separator:ad8749bba26443b6adab85c0cf5d69a93"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a25aca58f2c66dfb9de40e531aaf41256"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a25aca58f2c66dfb9de40e531aaf41256">append_to</a> (<a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a25aca58f2c66dfb9de40e531aaf41256"><td class="mdescLeft"> </td><td class="mdescRight">Gets an output stream for appending data to the file.  <a href="classGio_1_1File.html#a25aca58f2c66dfb9de40e531aaf41256">More...</a><br></br></td></tr>
<tr class="separator:a25aca58f2c66dfb9de40e531aaf41256"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2f98adc5cb353b29a5c93ec4731f50a9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2f98adc5cb353b29a5c93ec4731f50a9">create_file</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a2f98adc5cb353b29a5c93ec4731f50a9"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new file and returns an output stream for writing to it.  <a href="classGio_1_1File.html#a2f98adc5cb353b29a5c93ec4731f50a9">More...</a><br></br></td></tr>
<tr class="separator:a2f98adc5cb353b29a5c93ec4731f50a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a70511f41813ae029585c47f384356187"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a70511f41813ae029585c47f384356187">create_file</a> (<a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a70511f41813ae029585c47f384356187"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new file and returns an output stream for writing to it.  <a href="classGio_1_1File.html#a70511f41813ae029585c47f384356187">More...</a><br></br></td></tr>
<tr class="separator:a70511f41813ae029585c47f384356187"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a91d3de0fbbaf286244cd05630133d897"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a91d3de0fbbaf286244cd05630133d897">create_file_readwrite</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a91d3de0fbbaf286244cd05630133d897"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new file and returns a stream for reading and writing to it.  <a href="classGio_1_1File.html#a91d3de0fbbaf286244cd05630133d897">More...</a><br></br></td></tr>
<tr class="separator:a91d3de0fbbaf286244cd05630133d897"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7e63296c462e888ee71e582d4db5c229"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7e63296c462e888ee71e582d4db5c229">create_file_readwrite</a> (<a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a7e63296c462e888ee71e582d4db5c229"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new file and returns a stream for reading and writing to it.  <a href="classGio_1_1File.html#a7e63296c462e888ee71e582d4db5c229">More...</a><br></br></td></tr>
<tr class="separator:a7e63296c462e888ee71e582d4db5c229"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2cfa97a67aa32a044e809a1a36dbcf23"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2cfa97a67aa32a044e809a1a36dbcf23">replace</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag={}, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a2cfa97a67aa32a044e809a1a36dbcf23"><td class="mdescLeft"> </td><td class="mdescRight">Returns an output stream for overwriting the file, possibly creating a backup copy of the file first.  <a href="classGio_1_1File.html#a2cfa97a67aa32a044e809a1a36dbcf23">More...</a><br></br></td></tr>
<tr class="separator:a2cfa97a67aa32a044e809a1a36dbcf23"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a34817f33f9452734e31e251c496a0cec"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a34817f33f9452734e31e251c496a0cec">replace</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag={}, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a34817f33f9452734e31e251c496a0cec"><td class="mdescLeft"> </td><td class="mdescRight">Returns an output stream for overwriting the file, possibly creating a backup copy of the file first.  <a href="classGio_1_1File.html#a34817f33f9452734e31e251c496a0cec">More...</a><br></br></td></tr>
<tr class="separator:a34817f33f9452734e31e251c496a0cec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ea55b0e04fa8ab1ea52d9e97c634722"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4ea55b0e04fa8ab1ea52d9e97c634722">append_to_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a4ea55b0e04fa8ab1ea52d9e97c634722"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously opens the file for appending.  <a href="classGio_1_1File.html#a4ea55b0e04fa8ab1ea52d9e97c634722">More...</a><br></br></td></tr>
<tr class="separator:a4ea55b0e04fa8ab1ea52d9e97c634722"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa20bd10a0f98bba05ec3fb88e8ea8fba"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa20bd10a0f98bba05ec3fb88e8ea8fba">append_to_async</a> (const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:aa20bd10a0f98bba05ec3fb88e8ea8fba"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously opens the file for appending.  <a href="classGio_1_1File.html#aa20bd10a0f98bba05ec3fb88e8ea8fba">More...</a><br></br></td></tr>
<tr class="separator:aa20bd10a0f98bba05ec3fb88e8ea8fba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab95fdc72631ad9a07a94eac0bac50090"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab95fdc72631ad9a07a94eac0bac50090">append_to_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:ab95fdc72631ad9a07a94eac0bac50090"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous file append operation started with g_file_append_to_async().  <a href="classGio_1_1File.html#ab95fdc72631ad9a07a94eac0bac50090">More...</a><br></br></td></tr>
<tr class="separator:ab95fdc72631ad9a07a94eac0bac50090"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aafd50f29955c820e7f92af372ff7451f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aafd50f29955c820e7f92af372ff7451f">create_file_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:aafd50f29955c820e7f92af372ff7451f"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously creates a new file and returns an output stream for writing to it.  <a href="classGio_1_1File.html#aafd50f29955c820e7f92af372ff7451f">More...</a><br></br></td></tr>
<tr class="separator:aafd50f29955c820e7f92af372ff7451f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a4c4fc0a4ce0935df2f9793ff4772a0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3a4c4fc0a4ce0935df2f9793ff4772a0">create_file_async</a> (const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a3a4c4fc0a4ce0935df2f9793ff4772a0"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously creates a new file and returns an output stream for writing to it.  <a href="classGio_1_1File.html#a3a4c4fc0a4ce0935df2f9793ff4772a0">More...</a><br></br></td></tr>
<tr class="separator:a3a4c4fc0a4ce0935df2f9793ff4772a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a128001018104d45b158a27003c0c2638"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a128001018104d45b158a27003c0c2638">create_file_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a128001018104d45b158a27003c0c2638"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous file create operation started with g_file_create_async().  <a href="classGio_1_1File.html#a128001018104d45b158a27003c0c2638">More...</a><br></br></td></tr>
<tr class="separator:a128001018104d45b158a27003c0c2638"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8709e1a928621e837957e4690f284a1f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8709e1a928621e837957e4690f284a1f">create_file_readwrite_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a8709e1a928621e837957e4690f284a1f"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously creates a new file and returns a stream for reading and writing to it.  <a href="classGio_1_1File.html#a8709e1a928621e837957e4690f284a1f">More...</a><br></br></td></tr>
<tr class="separator:a8709e1a928621e837957e4690f284a1f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a81522da95f7b0dd3ed677d38e5b911e0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a81522da95f7b0dd3ed677d38e5b911e0">create_file_readwrite_async</a> (const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a81522da95f7b0dd3ed677d38e5b911e0"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously creates a new file and returns a stream for reading and writing to it.  <a href="classGio_1_1File.html#a81522da95f7b0dd3ed677d38e5b911e0">More...</a><br></br></td></tr>
<tr class="separator:a81522da95f7b0dd3ed677d38e5b911e0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a339d08bf6cafea58d9d0b0675e741d25"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a339d08bf6cafea58d9d0b0675e741d25">create_file_readwrite_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a339d08bf6cafea58d9d0b0675e741d25"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous file create operation started with g_file_create_readwrite_async().  <a href="classGio_1_1File.html#a339d08bf6cafea58d9d0b0675e741d25">More...</a><br></br></td></tr>
<tr class="separator:a339d08bf6cafea58d9d0b0675e741d25"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:add0f520fd16648261770799058427ef4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#add0f520fd16648261770799058427ef4">replace_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag={}, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:add0f520fd16648261770799058427ef4"><td class="mdescLeft"> </td><td class="mdescRight">Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first.  <a href="classGio_1_1File.html#add0f520fd16648261770799058427ef4">More...</a><br></br></td></tr>
<tr class="separator:add0f520fd16648261770799058427ef4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a91051b378a881531003702f1bac00977"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a91051b378a881531003702f1bac00977">replace_async</a> (const SlotAsyncReady&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag={}, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a91051b378a881531003702f1bac00977"><td class="mdescLeft"> </td><td class="mdescRight">Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first.  <a href="classGio_1_1File.html#a91051b378a881531003702f1bac00977">More...</a><br></br></td></tr>
<tr class="separator:a91051b378a881531003702f1bac00977"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4e5fe0438c73500d3d6ec7d0d4b39daa"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4e5fe0438c73500d3d6ec7d0d4b39daa">replace_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a4e5fe0438c73500d3d6ec7d0d4b39daa"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous file replace operation started with g_file_replace_async().  <a href="classGio_1_1File.html#a4e5fe0438c73500d3d6ec7d0d4b39daa">More...</a><br></br></td></tr>
<tr class="separator:a4e5fe0438c73500d3d6ec7d0d4b39daa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a128757d6cf7b152c82bb378a095003ef"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a128757d6cf7b152c82bb378a095003ef">open_readwrite</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a128757d6cf7b152c82bb378a095003ef"><td class="mdescLeft"> </td><td class="mdescRight">Opens an existing file for reading and writing.  <a href="classGio_1_1File.html#a128757d6cf7b152c82bb378a095003ef">More...</a><br></br></td></tr>
<tr class="separator:a128757d6cf7b152c82bb378a095003ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a456f74951f371ef5cca4282751efc66a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a">open_readwrite</a> ()</td></tr>
<tr class="memdesc:a456f74951f371ef5cca4282751efc66a"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a" title="A open_readwrite() convenience overload. ">open_readwrite()</a> convenience overload.  <a href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a">More...</a><br></br></td></tr>
<tr class="separator:a456f74951f371ef5cca4282751efc66a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a73d95a731716c7ffaa86c3af90afe8d3"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a73d95a731716c7ffaa86c3af90afe8d3">open_readwrite_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a73d95a731716c7ffaa86c3af90afe8d3"><td class="mdescLeft"> </td><td class="mdescRight">Opens an existing file for reading and writing.  <a href="classGio_1_1File.html#a73d95a731716c7ffaa86c3af90afe8d3">More...</a><br></br></td></tr>
<tr class="separator:a73d95a731716c7ffaa86c3af90afe8d3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a405af7082f531a7a39f3e7a453ab6267"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a405af7082f531a7a39f3e7a453ab6267">open_readwrite_async</a> (const SlotAsyncReady&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a405af7082f531a7a39f3e7a453ab6267"><td class="mdescLeft"> </td><td class="mdescRight">Opens an existing file for reading and writing.  <a href="classGio_1_1File.html#a405af7082f531a7a39f3e7a453ab6267">More...</a><br></br></td></tr>
<tr class="separator:a405af7082f531a7a39f3e7a453ab6267"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5fdcb54ece686c870eac69c6f93aed75"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5fdcb54ece686c870eac69c6f93aed75">open_readwrite_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a5fdcb54ece686c870eac69c6f93aed75"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous file read operation started with g_file_open_readwrite_async().  <a href="classGio_1_1File.html#a5fdcb54ece686c870eac69c6f93aed75">More...</a><br></br></td></tr>
<tr class="separator:a5fdcb54ece686c870eac69c6f93aed75"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab70699281c2125a80f54a9e142e9bcb8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab70699281c2125a80f54a9e142e9bcb8">replace_readwrite</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag={}, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:ab70699281c2125a80f54a9e142e9bcb8"><td class="mdescLeft"> </td><td class="mdescRight">Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first.  <a href="classGio_1_1File.html#ab70699281c2125a80f54a9e142e9bcb8">More...</a><br></br></td></tr>
<tr class="separator:ab70699281c2125a80f54a9e142e9bcb8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aebea81eca6fb8e180f1099bf642f8590"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aebea81eca6fb8e180f1099bf642f8590">replace_readwrite</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag={}, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:aebea81eca6fb8e180f1099bf642f8590"><td class="mdescLeft"> </td><td class="mdescRight">Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first.  <a href="classGio_1_1File.html#aebea81eca6fb8e180f1099bf642f8590">More...</a><br></br></td></tr>
<tr class="separator:aebea81eca6fb8e180f1099bf642f8590"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae6ac74357f700e5e1c3f0b657057d1cc"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae6ac74357f700e5e1c3f0b657057d1cc">replace_readwrite_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag={}, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ae6ac74357f700e5e1c3f0b657057d1cc"><td class="mdescLeft"> </td><td class="mdescRight">Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first.  <a href="classGio_1_1File.html#ae6ac74357f700e5e1c3f0b657057d1cc">More...</a><br></br></td></tr>
<tr class="separator:ae6ac74357f700e5e1c3f0b657057d1cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a470284a6c81af59a169db65131202b1f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a470284a6c81af59a169db65131202b1f">replace_readwrite_async</a> (const SlotAsyncReady&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag={}, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a470284a6c81af59a169db65131202b1f"><td class="mdescLeft"> </td><td class="mdescRight">Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first.  <a href="classGio_1_1File.html#a470284a6c81af59a169db65131202b1f">More...</a><br></br></td></tr>
<tr class="separator:a470284a6c81af59a169db65131202b1f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47d246b8ff87be3aaef635ac123d1e44"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a47d246b8ff87be3aaef635ac123d1e44">replace_readwrite_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a47d246b8ff87be3aaef635ac123d1e44"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async().  <a href="classGio_1_1File.html#a47d246b8ff87be3aaef635ac123d1e44">More...</a><br></br></td></tr>
<tr class="separator:a47d246b8ff87be3aaef635ac123d1e44"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2a2311094a75338f76d237b23774685"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685">query_info</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>) const </td></tr>
<tr class="memdesc:ac2a2311094a75338f76d237b23774685"><td class="mdescLeft"> </td><td class="mdescRight">Gets the requested information about the file.  <a href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685">More...</a><br></br></td></tr>
<tr class="separator:ac2a2311094a75338f76d237b23774685"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d65e1866fd98708495e94dc92a5ad94"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9d65e1866fd98708495e94dc92a5ad94">query_info</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>) const </td></tr>
<tr class="memdesc:a9d65e1866fd98708495e94dc92a5ad94"><td class="mdescLeft"> </td><td class="mdescRight">Gets the requested information about the file.  <a href="classGio_1_1File.html#a9d65e1866fd98708495e94dc92a5ad94">More...</a><br></br></td></tr>
<tr class="separator:a9d65e1866fd98708495e94dc92a5ad94"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8b0a75e0afdb5f6874ea5e304d55ea8"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8">query_exists</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable) const </td></tr>
<tr class="memdesc:ad8b0a75e0afdb5f6874ea5e304d55ea8"><td class="mdescLeft"> </td><td class="mdescRight">Utility function to check if a particular file exists.  <a href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8">More...</a><br></br></td></tr>
<tr class="separator:ad8b0a75e0afdb5f6874ea5e304d55ea8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab4cfdbf4fedacd364e40a72c71ab341a"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab4cfdbf4fedacd364e40a72c71ab341a">query_exists</a> () const </td></tr>
<tr class="memdesc:ab4cfdbf4fedacd364e40a72c71ab341a"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8" title="Utility function to check if a particular file exists. ">query_exists()</a> convenience overload.  <a href="classGio_1_1File.html#ab4cfdbf4fedacd364e40a72c71ab341a">More...</a><br></br></td></tr>
<tr class="separator:ab4cfdbf4fedacd364e40a72c71ab341a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa27c5b271c8f7667ce117cfc6118262e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa27c5b271c8f7667ce117cfc6118262e">query_file_type</a> (<a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable) const </td></tr>
<tr class="memdesc:aa27c5b271c8f7667ce117cfc6118262e"><td class="mdescLeft"> </td><td class="mdescRight">Utility function to inspect the FileType of a file.  <a href="classGio_1_1File.html#aa27c5b271c8f7667ce117cfc6118262e">More...</a><br></br></td></tr>
<tr class="separator:aa27c5b271c8f7667ce117cfc6118262e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae7910ee8c894c337644d54b793b8bb68"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae7910ee8c894c337644d54b793b8bb68">query_file_type</a> (<a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>) const </td></tr>
<tr class="memdesc:ae7910ee8c894c337644d54b793b8bb68"><td class="mdescLeft"> </td><td class="mdescRight">Utility function to inspect the FileType of a file.  <a href="classGio_1_1File.html#ae7910ee8c894c337644d54b793b8bb68">More...</a><br></br></td></tr>
<tr class="separator:ae7910ee8c894c337644d54b793b8bb68"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa86c313589bb9679be7ce780642f17fd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa86c313589bb9679be7ce780642f17fd">query_info_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr class="memdesc:aa86c313589bb9679be7ce780642f17fd"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously gets the requested information about specified file.  <a href="classGio_1_1File.html#aa86c313589bb9679be7ce780642f17fd">More...</a><br></br></td></tr>
<tr class="separator:aa86c313589bb9679be7ce780642f17fd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad24a796507738e0b263555314e074eb1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad24a796507738e0b263555314e074eb1">query_info_async</a> (const SlotAsyncReady&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr class="memdesc:ad24a796507738e0b263555314e074eb1"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously gets the requested information about specified file.  <a href="classGio_1_1File.html#ad24a796507738e0b263555314e074eb1">More...</a><br></br></td></tr>
<tr class="separator:ad24a796507738e0b263555314e074eb1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a33eadfff77c93a77ecde795307728e52"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a33eadfff77c93a77ecde795307728e52">query_info_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a33eadfff77c93a77ecde795307728e52"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous file info query.  <a href="classGio_1_1File.html#a33eadfff77c93a77ecde795307728e52">More...</a><br></br></td></tr>
<tr class="separator:a33eadfff77c93a77ecde795307728e52"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40486bc2f0c8758ef8a705b6b8b57e57"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57">query_filesystem_info</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*")</td></tr>
<tr class="memdesc:a40486bc2f0c8758ef8a705b6b8b57e57"><td class="mdescLeft"> </td><td class="mdescRight">Similar to <a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685" title="Gets the requested information about the file. ">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself.  <a href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57">More...</a><br></br></td></tr>
<tr class="separator:a40486bc2f0c8758ef8a705b6b8b57e57"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac737012f8df97d90e2447d94d30b817d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac737012f8df97d90e2447d94d30b817d">query_filesystem_info</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*")</td></tr>
<tr class="memdesc:ac737012f8df97d90e2447d94d30b817d"><td class="mdescLeft"> </td><td class="mdescRight">Similar to <a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685" title="Gets the requested information about the file. ">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself.  <a href="classGio_1_1File.html#ac737012f8df97d90e2447d94d30b817d">More...</a><br></br></td></tr>
<tr class="separator:ac737012f8df97d90e2447d94d30b817d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a45b881926b8d58c49d3baa1f51f2ee5d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a45b881926b8d58c49d3baa1f51f2ee5d">find_enclosing_mount</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a45b881926b8d58c49d3baa1f51f2ee5d"><td class="mdescLeft"> </td><td class="mdescRight">Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts. ">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>.  <a href="classGio_1_1File.html#a45b881926b8d58c49d3baa1f51f2ee5d">More...</a><br></br></td></tr>
<tr class="separator:a45b881926b8d58c49d3baa1f51f2ee5d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6eb675267c7ea1c2a0d40e2e754d8333"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333">find_enclosing_mount</a> ()</td></tr>
<tr class="memdesc:a6eb675267c7ea1c2a0d40e2e754d8333"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="A find_enclosing_mount() convenience overload. ">find_enclosing_mount()</a> convenience overload.  <a href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333">More...</a><br></br></td></tr>
<tr class="separator:a6eb675267c7ea1c2a0d40e2e754d8333"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39184ff9c9437259df4b9a9e2f283a0b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a39184ff9c9437259df4b9a9e2f283a0b">query_filesystem_info_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr class="memdesc:a39184ff9c9437259df4b9a9e2f283a0b"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously gets the requested information about the filesystem that the file is on.  <a href="classGio_1_1File.html#a39184ff9c9437259df4b9a9e2f283a0b">More...</a><br></br></td></tr>
<tr class="separator:a39184ff9c9437259df4b9a9e2f283a0b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4557ab16a50337f73d8a4649cf60fe70"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4557ab16a50337f73d8a4649cf60fe70">query_filesystem_info_async</a> (const SlotAsyncReady&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr class="memdesc:a4557ab16a50337f73d8a4649cf60fe70"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously gets the requested information about the filesystem that the file is on.  <a href="classGio_1_1File.html#a4557ab16a50337f73d8a4649cf60fe70">More...</a><br></br></td></tr>
<tr class="separator:a4557ab16a50337f73d8a4649cf60fe70"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af986512a5b8cb8acf75afd7206b09be1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af986512a5b8cb8acf75afd7206b09be1">query_filesystem_info_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:af986512a5b8cb8acf75afd7206b09be1"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous filesystem info query.  <a href="classGio_1_1File.html#af986512a5b8cb8acf75afd7206b09be1">More...</a><br></br></td></tr>
<tr class="separator:af986512a5b8cb8acf75afd7206b09be1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a78c95d4fa47157f7757b686677dec018"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a78c95d4fa47157f7757b686677dec018">find_enclosing_mount_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a78c95d4fa47157f7757b686677dec018"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously gets the mount for the file.  <a href="classGio_1_1File.html#a78c95d4fa47157f7757b686677dec018">More...</a><br></br></td></tr>
<tr class="separator:a78c95d4fa47157f7757b686677dec018"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67458be57c5687e7469bc26e2594f4be"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a67458be57c5687e7469bc26e2594f4be">find_enclosing_mount_async</a> (const SlotAsyncReady&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a67458be57c5687e7469bc26e2594f4be"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously gets the mount for the file.  <a href="classGio_1_1File.html#a67458be57c5687e7469bc26e2594f4be">More...</a><br></br></td></tr>
<tr class="separator:a67458be57c5687e7469bc26e2594f4be"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4b415b02053e16a92cabb6a48368733"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad4b415b02053e16a92cabb6a48368733">find_enclosing_mount_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:ad4b415b02053e16a92cabb6a48368733"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous find mount request.  <a href="classGio_1_1File.html#ad4b415b02053e16a92cabb6a48368733">More...</a><br></br></td></tr>
<tr class="separator:ad4b415b02053e16a92cabb6a48368733"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab7909a4bc1ab980ae9ebfbd995dea375"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab7909a4bc1ab980ae9ebfbd995dea375">enumerate_children</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>)</td></tr>
<tr class="memdesc:ab7909a4bc1ab980ae9ebfbd995dea375"><td class="mdescLeft"> </td><td class="mdescRight">Gets the requested information about the files in a directory.  <a href="classGio_1_1File.html#ab7909a4bc1ab980ae9ebfbd995dea375">More...</a><br></br></td></tr>
<tr class="separator:ab7909a4bc1ab980ae9ebfbd995dea375"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6bf7abcd4773dfeb827227289184a87b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6bf7abcd4773dfeb827227289184a87b">enumerate_children</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>)</td></tr>
<tr class="memdesc:a6bf7abcd4773dfeb827227289184a87b"><td class="mdescLeft"> </td><td class="mdescRight">Gets the requested information about the files in a directory.  <a href="classGio_1_1File.html#a6bf7abcd4773dfeb827227289184a87b">More...</a><br></br></td></tr>
<tr class="separator:a6bf7abcd4773dfeb827227289184a87b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a945576cd1d0a78164705c26d54e7d1cc"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a945576cd1d0a78164705c26d54e7d1cc">enumerate_children_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a945576cd1d0a78164705c26d54e7d1cc"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously gets the requested information about the files in a directory.  <a href="classGio_1_1File.html#a945576cd1d0a78164705c26d54e7d1cc">More...</a><br></br></td></tr>
<tr class="separator:a945576cd1d0a78164705c26d54e7d1cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d6c273e02e5c23bdb8df482cdbbb409"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4d6c273e02e5c23bdb8df482cdbbb409">enumerate_children_async</a> (const SlotAsyncReady&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes="*", <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a4d6c273e02e5c23bdb8df482cdbbb409"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously gets the requested information about the files in a directory.  <a href="classGio_1_1File.html#a4d6c273e02e5c23bdb8df482cdbbb409">More...</a><br></br></td></tr>
<tr class="separator:a4d6c273e02e5c23bdb8df482cdbbb409"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acdabb80157c69c01479e0b89821c1299"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acdabb80157c69c01479e0b89821c1299">enumerate_children_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:acdabb80157c69c01479e0b89821c1299"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an async enumerate children operation.  <a href="classGio_1_1File.html#acdabb80157c69c01479e0b89821c1299">More...</a><br></br></td></tr>
<tr class="separator:acdabb80157c69c01479e0b89821c1299"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3dd75810d7c9ebafac398288f5afc018"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018">set_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a3dd75810d7c9ebafac398288f5afc018"><td class="mdescLeft"> </td><td class="mdescRight">Renames <em>file</em> to the specified display name.  <a href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018">More...</a><br></br></td></tr>
<tr class="separator:a3dd75810d7c9ebafac398288f5afc018"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8c2aa80b2d0ecdd22f0222c8ce42d177"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8c2aa80b2d0ecdd22f0222c8ce42d177">set_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name)</td></tr>
<tr class="memdesc:a8c2aa80b2d0ecdd22f0222c8ce42d177"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name. ">set_display_name()</a> convenience overload.  <a href="classGio_1_1File.html#a8c2aa80b2d0ecdd22f0222c8ce42d177">More...</a><br></br></td></tr>
<tr class="separator:a8c2aa80b2d0ecdd22f0222c8ce42d177"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0ac539d7758b9c0de809f8c83e0bba79"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0ac539d7758b9c0de809f8c83e0bba79">set_display_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a0ac539d7758b9c0de809f8c83e0bba79"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>.  <a href="classGio_1_1File.html#a0ac539d7758b9c0de809f8c83e0bba79">More...</a><br></br></td></tr>
<tr class="separator:a0ac539d7758b9c0de809f8c83e0bba79"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a74d219d321dca3d438f876256dee82d2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a74d219d321dca3d438f876256dee82d2">set_display_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const SlotAsyncReady&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a74d219d321dca3d438f876256dee82d2"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>.  <a href="classGio_1_1File.html#a74d219d321dca3d438f876256dee82d2">More...</a><br></br></td></tr>
<tr class="separator:a74d219d321dca3d438f876256dee82d2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2abb19573076b426434f7d8d2d5a0cdb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2abb19573076b426434f7d8d2d5a0cdb">set_display_name_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a2abb19573076b426434f7d8d2d5a0cdb"><td class="mdescLeft"> </td><td class="mdescRight">Finishes setting a display name started with g_file_set_display_name_async().  <a href="classGio_1_1File.html#a2abb19573076b426434f7d8d2d5a0cdb">More...</a><br></br></td></tr>
<tr class="separator:a2abb19573076b426434f7d8d2d5a0cdb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aded971b0cf84801f6684ad4bd5dc66c5"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aded971b0cf84801f6684ad4bd5dc66c5">remove</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:aded971b0cf84801f6684ad4bd5dc66c5"><td class="mdescLeft"> </td><td class="mdescRight">Deletes a file.  <a href="classGio_1_1File.html#aded971b0cf84801f6684ad4bd5dc66c5">More...</a><br></br></td></tr>
<tr class="separator:aded971b0cf84801f6684ad4bd5dc66c5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a14f34508dea523cbf889b7193e513ca4"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a14f34508dea523cbf889b7193e513ca4">remove</a> ()</td></tr>
<tr class="memdesc:a14f34508dea523cbf889b7193e513ca4"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a14f34508dea523cbf889b7193e513ca4" title="A remove() convenience overload. ">remove()</a> convenience overload.  <a href="classGio_1_1File.html#a14f34508dea523cbf889b7193e513ca4">More...</a><br></br></td></tr>
<tr class="separator:a14f34508dea523cbf889b7193e513ca4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8499cabde1f50f1cbd5d928d63e73fb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8499cabde1f50f1cbd5d928d63e73fb">remove_async</a> (const SlotAsyncReady&amp; slot_ready, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ad8499cabde1f50f1cbd5d928d63e73fb"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously delete a file.  <a href="classGio_1_1File.html#ad8499cabde1f50f1cbd5d928d63e73fb">More...</a><br></br></td></tr>
<tr class="separator:ad8499cabde1f50f1cbd5d928d63e73fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a21198001203267126de9a24a8e91b0d1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a21198001203267126de9a24a8e91b0d1">remove_async</a> (const SlotAsyncReady&amp; slot_ready, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a21198001203267126de9a24a8e91b0d1"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously delete a file.  <a href="classGio_1_1File.html#a21198001203267126de9a24a8e91b0d1">More...</a><br></br></td></tr>
<tr class="separator:a21198001203267126de9a24a8e91b0d1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0240c85a3ec46e107666e65da9b92c54"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0240c85a3ec46e107666e65da9b92c54">remove_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a0240c85a3ec46e107666e65da9b92c54"><td class="mdescLeft"> </td><td class="mdescRight">Finishes deleting a file started with g_file_delete_async().  <a href="classGio_1_1File.html#a0240c85a3ec46e107666e65da9b92c54">More...</a><br></br></td></tr>
<tr class="separator:a0240c85a3ec46e107666e65da9b92c54"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acae5ecd962e832cf8d538877f4118da8"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acae5ecd962e832cf8d538877f4118da8">trash</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:acae5ecd962e832cf8d538877f4118da8"><td class="mdescLeft"> </td><td class="mdescRight">Sends <em>file</em> to the "Trashcan", if possible.  <a href="classGio_1_1File.html#acae5ecd962e832cf8d538877f4118da8">More...</a><br></br></td></tr>
<tr class="separator:acae5ecd962e832cf8d538877f4118da8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1925736f9af338eaf9942468b4d6d65e"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1925736f9af338eaf9942468b4d6d65e">trash</a> ()</td></tr>
<tr class="memdesc:a1925736f9af338eaf9942468b4d6d65e"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a1925736f9af338eaf9942468b4d6d65e" title="A trash() convenience overload. ">trash()</a> convenience overload.  <a href="classGio_1_1File.html#a1925736f9af338eaf9942468b4d6d65e">More...</a><br></br></td></tr>
<tr class="separator:a1925736f9af338eaf9942468b4d6d65e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afab15e7d88376d144253bce7bfba2730"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afab15e7d88376d144253bce7bfba2730">trash_async</a> (const SlotAsyncReady&amp; slot_ready, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:afab15e7d88376d144253bce7bfba2730"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously sends the file to the Trash location, if possible.  <a href="classGio_1_1File.html#afab15e7d88376d144253bce7bfba2730">More...</a><br></br></td></tr>
<tr class="separator:afab15e7d88376d144253bce7bfba2730"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5cb6f01422a66c141ba721fc8790f10a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5cb6f01422a66c141ba721fc8790f10a">trash_async</a> (const SlotAsyncReady&amp; slot_ready, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a5cb6f01422a66c141ba721fc8790f10a"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously sends the file to the Trash location, if possible.  <a href="classGio_1_1File.html#a5cb6f01422a66c141ba721fc8790f10a">More...</a><br></br></td></tr>
<tr class="separator:a5cb6f01422a66c141ba721fc8790f10a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7ee78bd712cb24661335cee8e3d29344"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7ee78bd712cb24661335cee8e3d29344">trash_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a7ee78bd712cb24661335cee8e3d29344"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous file trashing operation, started with g_file_trash_async().  <a href="classGio_1_1File.html#a7ee78bd712cb24661335cee8e3d29344">More...</a><br></br></td></tr>
<tr class="separator:a7ee78bd712cb24661335cee8e3d29344"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a14f3429c51dd8af76d56c73e148321d2"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a14f3429c51dd8af76d56c73e148321d2">copy</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>)</td></tr>
<tr class="memdesc:a14f3429c51dd8af76d56c73e148321d2"><td class="mdescLeft"> </td><td class="mdescRight">Copies the file source to the location specified by destination.  <a href="classGio_1_1File.html#a14f3429c51dd8af76d56c73e148321d2">More...</a><br></br></td></tr>
<tr class="separator:a14f3429c51dd8af76d56c73e148321d2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a294ad252c16999322da80a2b7af3926a"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a294ad252c16999322da80a2b7af3926a">copy</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>)</td></tr>
<tr class="memdesc:a294ad252c16999322da80a2b7af3926a"><td class="mdescLeft"> </td><td class="mdescRight">Copies the file source to the location specified by destination.  <a href="classGio_1_1File.html#a294ad252c16999322da80a2b7af3926a">More...</a><br></br></td></tr>
<tr class="separator:a294ad252c16999322da80a2b7af3926a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a10eb6824d2430e3e4806df10f385fa46"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a10eb6824d2430e3e4806df10f385fa46">copy</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>)</td></tr>
<tr class="memdesc:a10eb6824d2430e3e4806df10f385fa46"><td class="mdescLeft"> </td><td class="mdescRight">Copies the file source to the location specified by destination.  <a href="classGio_1_1File.html#a10eb6824d2430e3e4806df10f385fa46">More...</a><br></br></td></tr>
<tr class="separator:a10eb6824d2430e3e4806df10f385fa46"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8bf6e7a24bf7b50df3daba3d587ded31"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8bf6e7a24bf7b50df3daba3d587ded31">copy_async</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; slot_progress, const SlotAsyncReady&amp; slot_ready, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a8bf6e7a24bf7b50df3daba3d587ded31"><td class="mdescLeft"> </td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously.  <a href="classGio_1_1File.html#a8bf6e7a24bf7b50df3daba3d587ded31">More...</a><br></br></td></tr>
<tr class="separator:a8bf6e7a24bf7b50df3daba3d587ded31"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a497af04aad912b3ad816530d1ac31f4d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a497af04aad912b3ad816530d1ac31f4d">copy_async</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const SlotAsyncReady&amp; slot_ready, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a497af04aad912b3ad816530d1ac31f4d"><td class="mdescLeft"> </td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously.  <a href="classGio_1_1File.html#a497af04aad912b3ad816530d1ac31f4d">More...</a><br></br></td></tr>
<tr class="separator:a497af04aad912b3ad816530d1ac31f4d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af25073f3374aae4bbf697c6ed0c880fb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af25073f3374aae4bbf697c6ed0c880fb">copy_async</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; slot_progress, const SlotAsyncReady&amp; slot_ready, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:af25073f3374aae4bbf697c6ed0c880fb"><td class="mdescLeft"> </td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously.  <a href="classGio_1_1File.html#af25073f3374aae4bbf697c6ed0c880fb">More...</a><br></br></td></tr>
<tr class="separator:af25073f3374aae4bbf697c6ed0c880fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a789c836e27f41e70ce8378c59b1fe5e5"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a789c836e27f41e70ce8378c59b1fe5e5">copy_async</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const SlotAsyncReady&amp; slot_ready, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a789c836e27f41e70ce8378c59b1fe5e5"><td class="mdescLeft"> </td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously.  <a href="classGio_1_1File.html#a789c836e27f41e70ce8378c59b1fe5e5">More...</a><br></br></td></tr>
<tr class="separator:a789c836e27f41e70ce8378c59b1fe5e5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab16cd89db6cd5bb0c8dfdd4b635002d7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7">copy_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:ab16cd89db6cd5bb0c8dfdd4b635002d7"><td class="mdescLeft"> </td><td class="mdescRight">Finishes copying the file started with g_file_copy_async().  <a href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7">More...</a><br></br></td></tr>
<tr class="separator:ab16cd89db6cd5bb0c8dfdd4b635002d7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab73995a83642bbd0768157b1985128b6"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab73995a83642bbd0768157b1985128b6">move</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>)</td></tr>
<tr class="memdesc:ab73995a83642bbd0768157b1985128b6"><td class="mdescLeft"> </td><td class="mdescRight">Tries to move the file or directory source to the location specified by destination.  <a href="classGio_1_1File.html#ab73995a83642bbd0768157b1985128b6">More...</a><br></br></td></tr>
<tr class="separator:ab73995a83642bbd0768157b1985128b6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1012301ae63714d41b7ce49b57c94d23"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1012301ae63714d41b7ce49b57c94d23">move</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; slot, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>)</td></tr>
<tr class="separator:a1012301ae63714d41b7ce49b57c94d23"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afa50d1739a4e4a9b5645c8292f62cf26"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afa50d1739a4e4a9b5645c8292f62cf26">move</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>)</td></tr>
<tr class="separator:afa50d1739a4e4a9b5645c8292f62cf26"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abfa05e23e95e77cabac289ab4e294a58"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abfa05e23e95e77cabac289ab4e294a58">make_directory</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:abfa05e23e95e77cabac289ab4e294a58"><td class="mdescLeft"> </td><td class="mdescRight">Creates a directory.  <a href="classGio_1_1File.html#abfa05e23e95e77cabac289ab4e294a58">More...</a><br></br></td></tr>
<tr class="separator:abfa05e23e95e77cabac289ab4e294a58"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa1e9aa5f58a76a8562fd00a13434f554"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa1e9aa5f58a76a8562fd00a13434f554">make_directory</a> ()</td></tr>
<tr class="memdesc:aa1e9aa5f58a76a8562fd00a13434f554"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#aa1e9aa5f58a76a8562fd00a13434f554" title="A make_directory() convenience overload. ">make_directory()</a> convenience overload.  <a href="classGio_1_1File.html#aa1e9aa5f58a76a8562fd00a13434f554">More...</a><br></br></td></tr>
<tr class="separator:aa1e9aa5f58a76a8562fd00a13434f554"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a60cf2bf09420aec99766fa132d8ae0a8"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a60cf2bf09420aec99766fa132d8ae0a8">make_directory_async</a> (const SlotAsyncReady&amp; slot_ready, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a60cf2bf09420aec99766fa132d8ae0a8"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously creates a directory.  <a href="classGio_1_1File.html#a60cf2bf09420aec99766fa132d8ae0a8">More...</a><br></br></td></tr>
<tr class="separator:a60cf2bf09420aec99766fa132d8ae0a8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad7facff532924459948de0031396f9b5"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad7facff532924459948de0031396f9b5">make_directory_async</a> (const SlotAsyncReady&amp; slot_ready, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ad7facff532924459948de0031396f9b5"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously creates a directory.  <a href="classGio_1_1File.html#ad7facff532924459948de0031396f9b5">More...</a><br></br></td></tr>
<tr class="separator:ad7facff532924459948de0031396f9b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0758295d049fe070dd235786775f777e"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0758295d049fe070dd235786775f777e">make_directory_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a0758295d049fe070dd235786775f777e"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous directory creation, started with g_file_make_directory_async().  <a href="classGio_1_1File.html#a0758295d049fe070dd235786775f777e">More...</a><br></br></td></tr>
<tr class="separator:a0758295d049fe070dd235786775f777e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afb0b5b094339057b4b15952eb73e08d6"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afb0b5b094339057b4b15952eb73e08d6">make_directory_with_parents</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:afb0b5b094339057b4b15952eb73e08d6"><td class="mdescLeft"> </td><td class="mdescRight">Creates a directory and any parent directories that may not exist similar to 'mkdir -p'.  <a href="classGio_1_1File.html#afb0b5b094339057b4b15952eb73e08d6">More...</a><br></br></td></tr>
<tr class="separator:afb0b5b094339057b4b15952eb73e08d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a874a487551d49ca62b31a3e5cf32fee6"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6">make_directory_with_parents</a> ()</td></tr>
<tr class="memdesc:a874a487551d49ca62b31a3e5cf32fee6"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6" title="A make_directory_with_parents() convenience overload. ">make_directory_with_parents()</a> convenience overload.  <a href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6">More...</a><br></br></td></tr>
<tr class="separator:a874a487551d49ca62b31a3e5cf32fee6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2709318e1f24dfd0cd498d28f5e1b8fe"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe">make_symbolic_link</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; symlink_value, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a2709318e1f24dfd0cd498d28f5e1b8fe"><td class="mdescLeft"> </td><td class="mdescRight">Creates a symbolic link.  <a href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe">More...</a><br></br></td></tr>
<tr class="separator:a2709318e1f24dfd0cd498d28f5e1b8fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8a9a3d060c2675ff9ac1c758f0b2c024"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8a9a3d060c2675ff9ac1c758f0b2c024">make_symbolic_link</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; symlink_value)</td></tr>
<tr class="memdesc:a8a9a3d060c2675ff9ac1c758f0b2c024"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe" title="Creates a symbolic link. ">make_symbolic_link()</a> convenience overload.  <a href="classGio_1_1File.html#a8a9a3d060c2675ff9ac1c758f0b2c024">More...</a><br></br></td></tr>
<tr class="separator:a8a9a3d060c2675ff9ac1c758f0b2c024"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a543339b58cff6a7e5ddd840df0e69e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4a543339b58cff6a7e5ddd840df0e69e">query_settable_attributes</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a4a543339b58cff6a7e5ddd840df0e69e"><td class="mdescLeft"> </td><td class="mdescRight">Obtain the list of settable attributes for the file.  <a href="classGio_1_1File.html#a4a543339b58cff6a7e5ddd840df0e69e">More...</a><br></br></td></tr>
<tr class="separator:a4a543339b58cff6a7e5ddd840df0e69e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ae03d0652bcfbad2f47409b8f815bc4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1ae03d0652bcfbad2f47409b8f815bc4">query_settable_attributes</a> ()</td></tr>
<tr class="memdesc:a1ae03d0652bcfbad2f47409b8f815bc4"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a1ae03d0652bcfbad2f47409b8f815bc4" title="A query_settable_attributes() convenience overload. ">query_settable_attributes()</a> convenience overload.  <a href="classGio_1_1File.html#a1ae03d0652bcfbad2f47409b8f815bc4">More...</a><br></br></td></tr>
<tr class="separator:a1ae03d0652bcfbad2f47409b8f815bc4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af5c7463b92e2887597486e7b195ca12f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af5c7463b92e2887597486e7b195ca12f">query_writable_namespaces</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:af5c7463b92e2887597486e7b195ca12f"><td class="mdescLeft"> </td><td class="mdescRight">Obtain the list of attribute namespaces where new attributes can be created by a user.  <a href="classGio_1_1File.html#af5c7463b92e2887597486e7b195ca12f">More...</a><br></br></td></tr>
<tr class="separator:af5c7463b92e2887597486e7b195ca12f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa0278acd7d09ed292359004defb742b0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa0278acd7d09ed292359004defb742b0">query_writable_namespaces</a> ()</td></tr>
<tr class="memdesc:aa0278acd7d09ed292359004defb742b0"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#aa0278acd7d09ed292359004defb742b0" title="A query_writable_namespaces() convenience overload. ">query_writable_namespaces()</a> convenience overload.  <a href="classGio_1_1File.html#aa0278acd7d09ed292359004defb742b0">More...</a><br></br></td></tr>
<tr class="separator:aa0278acd7d09ed292359004defb742b0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3dc7af767076fedea902b53be909d6b4"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3dc7af767076fedea902b53be909d6b4">set_attributes_from_info</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>)</td></tr>
<tr class="memdesc:a3dc7af767076fedea902b53be909d6b4"><td class="mdescLeft"> </td><td class="mdescRight">Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> on the target values, not stopping on the first error.  <a href="classGio_1_1File.html#a3dc7af767076fedea902b53be909d6b4">More...</a><br></br></td></tr>
<tr class="separator:a3dc7af767076fedea902b53be909d6b4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a70dd6d0f7cbb3fd10ca6af2d7843423c"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a70dd6d0f7cbb3fd10ca6af2d7843423c">set_attributes_from_info</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>)</td></tr>
<tr class="memdesc:a70dd6d0f7cbb3fd10ca6af2d7843423c"><td class="mdescLeft"> </td><td class="mdescRight">Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> on the target values, not stopping on the first error.  <a href="classGio_1_1File.html#a70dd6d0f7cbb3fd10ca6af2d7843423c">More...</a><br></br></td></tr>
<tr class="separator:a70dd6d0f7cbb3fd10ca6af2d7843423c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ac22907ff66821a965828f59b115d35"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4ac22907ff66821a965828f59b115d35">set_attributes_async</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a4ac22907ff66821a965828f59b115d35"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously sets the attributes of file with info.  <a href="classGio_1_1File.html#a4ac22907ff66821a965828f59b115d35">More...</a><br></br></td></tr>
<tr class="separator:a4ac22907ff66821a965828f59b115d35"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9f5748b2f96bd7b47b122a463e193b4d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9f5748b2f96bd7b47b122a463e193b4d">set_attributes_async</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a9f5748b2f96bd7b47b122a463e193b4d"><td class="mdescLeft"> </td><td class="mdescRight">Asynchronously sets the attributes of file with info.  <a href="classGio_1_1File.html#a9f5748b2f96bd7b47b122a463e193b4d">More...</a><br></br></td></tr>
<tr class="separator:a9f5748b2f96bd7b47b122a463e193b4d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aefd45aed7b975b6e204e67927de2817a"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info)</td></tr>
<tr class="separator:aefd45aed7b975b6e204e67927de2817a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a37c39d7392c7324daa8e6d0597ced146"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a37c39d7392c7324daa8e6d0597ced146">set_attribute_string</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a37c39d7392c7324daa8e6d0597ced146"><td class="mdescLeft"> </td><td class="mdescRight">Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>.  <a href="classGio_1_1File.html#a37c39d7392c7324daa8e6d0597ced146">More...</a><br></br></td></tr>
<tr class="separator:a37c39d7392c7324daa8e6d0597ced146"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8091652bb139428d2d8525aad84d2952"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8091652bb139428d2d8525aad84d2952">set_attribute_string</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a8091652bb139428d2d8525aad84d2952"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a37c39d7392c7324daa8e6d0597ced146" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_STRING to value. ">set_attribute_string()</a> convenience overload.  <a href="classGio_1_1File.html#a8091652bb139428d2d8525aad84d2952">More...</a><br></br></td></tr>
<tr class="separator:a8091652bb139428d2d8525aad84d2952"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4f4373b8694c346a6908195f1f2644f3"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3">set_attribute_byte_string</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a4f4373b8694c346a6908195f1f2644f3"><td class="mdescLeft"> </td><td class="mdescRight">Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>.  <a href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3">More...</a><br></br></td></tr>
<tr class="separator:a4f4373b8694c346a6908195f1f2644f3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a09f574259052186e1b516bdcbe696710"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a09f574259052186e1b516bdcbe696710">set_attribute_byte_string</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a09f574259052186e1b516bdcbe696710"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to value. ">set_attribute_byte_string()</a> convenience overload.  <a href="classGio_1_1File.html#a09f574259052186e1b516bdcbe696710">More...</a><br></br></td></tr>
<tr class="separator:a09f574259052186e1b516bdcbe696710"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae53b0f4d2214e050a290c8e35cac0f27"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27">set_attribute_uint32</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint32 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:ae53b0f4d2214e050a290c8e35cac0f27"><td class="mdescLeft"> </td><td class="mdescRight">Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>.  <a href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27">More...</a><br></br></td></tr>
<tr class="separator:ae53b0f4d2214e050a290c8e35cac0f27"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7f769f140143f2e96a7587a10b6792a9"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7f769f140143f2e96a7587a10b6792a9">set_attribute_uint32</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint32 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a7f769f140143f2e96a7587a10b6792a9"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT32 to value. ">set_attribute_uint32()</a> convenience overload.  <a href="classGio_1_1File.html#a7f769f140143f2e96a7587a10b6792a9">More...</a><br></br></td></tr>
<tr class="separator:a7f769f140143f2e96a7587a10b6792a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab0290ecba7b06ccf7736e2292708667e"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e">set_attribute_int32</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint32 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:ab0290ecba7b06ccf7736e2292708667e"><td class="mdescLeft"> </td><td class="mdescRight">Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>.  <a href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e">More...</a><br></br></td></tr>
<tr class="separator:ab0290ecba7b06ccf7736e2292708667e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a707084a3c0a963548a21d17d0ec0b5"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4a707084a3c0a963548a21d17d0ec0b5">set_attribute_int32</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint32 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a4a707084a3c0a963548a21d17d0ec0b5"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT32 to value. ">set_attribute_int32()</a> convenience overload.  <a href="classGio_1_1File.html#a4a707084a3c0a963548a21d17d0ec0b5">More...</a><br></br></td></tr>
<tr class="separator:a4a707084a3c0a963548a21d17d0ec0b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a48638081fd7af772a39af59a558b17f7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7">set_attribute_uint64</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint64 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a48638081fd7af772a39af59a558b17f7"><td class="mdescLeft"> </td><td class="mdescRight">Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>.  <a href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7">More...</a><br></br></td></tr>
<tr class="separator:a48638081fd7af772a39af59a558b17f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4aa77b3580df88cfd3d7231af78155c7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4aa77b3580df88cfd3d7231af78155c7">set_attribute_uint64</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint64 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a4aa77b3580df88cfd3d7231af78155c7"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT64 to value. ">set_attribute_uint64()</a> convenience overload.  <a href="classGio_1_1File.html#a4aa77b3580df88cfd3d7231af78155c7">More...</a><br></br></td></tr>
<tr class="separator:a4aa77b3580df88cfd3d7231af78155c7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a111d73a2d003e5a5a4c5f86c7c3d2fb7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7">set_attribute_int64</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint64 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a111d73a2d003e5a5a4c5f86c7c3d2fb7"><td class="mdescLeft"> </td><td class="mdescRight">Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>.  <a href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7">More...</a><br></br></td></tr>
<tr class="separator:a111d73a2d003e5a5a4c5f86c7c3d2fb7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4477b0063110951b26c855696ec34802"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4477b0063110951b26c855696ec34802">set_attribute_int64</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint64 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a4477b0063110951b26c855696ec34802"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT64 to value. ">set_attribute_int64()</a> convenience overload.  <a href="classGio_1_1File.html#a4477b0063110951b26c855696ec34802">More...</a><br></br></td></tr>
<tr class="separator:a4477b0063110951b26c855696ec34802"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ace75bca82febb0a6a0ab95a7dcf6b1fb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ace75bca82febb0a6a0ab95a7dcf6b1fb">mount_enclosing_volume</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a>)</td></tr>
<tr class="memdesc:ace75bca82febb0a6a0ab95a7dcf6b1fb"><td class="mdescLeft"> </td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file.  <a href="classGio_1_1File.html#ace75bca82febb0a6a0ab95a7dcf6b1fb">More...</a><br></br></td></tr>
<tr class="separator:ace75bca82febb0a6a0ab95a7dcf6b1fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acea9e8e1c493c30ae2dd8c1657137320"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acea9e8e1c493c30ae2dd8c1657137320">mount_enclosing_volume</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a>)</td></tr>
<tr class="memdesc:acea9e8e1c493c30ae2dd8c1657137320"><td class="mdescLeft"> </td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file.  <a href="classGio_1_1File.html#acea9e8e1c493c30ae2dd8c1657137320">More...</a><br></br></td></tr>
<tr class="separator:acea9e8e1c493c30ae2dd8c1657137320"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4238e62b6dffc31a67cb55bbd79be289"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4238e62b6dffc31a67cb55bbd79be289">mount_enclosing_volume</a> (const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a4238e62b6dffc31a67cb55bbd79be289"><td class="mdescLeft"> </td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file.  <a href="classGio_1_1File.html#a4238e62b6dffc31a67cb55bbd79be289">More...</a><br></br></td></tr>
<tr class="separator:a4238e62b6dffc31a67cb55bbd79be289"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a374d9646586506e697a686846d5376a2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a374d9646586506e697a686846d5376a2">mount_enclosing_volume</a> (<a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a374d9646586506e697a686846d5376a2"><td class="mdescLeft"> </td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file.  <a href="classGio_1_1File.html#a374d9646586506e697a686846d5376a2">More...</a><br></br></td></tr>
<tr class="separator:a374d9646586506e697a686846d5376a2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aefd44b1b3467bcc474b345ff98b4aa6d"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d">mount_enclosing_volume_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:aefd44b1b3467bcc474b345ff98b4aa6d"><td class="mdescLeft"> </td><td class="mdescRight">Finishes a mount operation started by g_file_mount_enclosing_volume().  <a href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d">More...</a><br></br></td></tr>
<tr class="separator:aefd44b1b3467bcc474b345ff98b4aa6d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae12349a4620fa8936824eb894eaea08f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae12349a4620fa8936824eb894eaea08f">mount_mountable</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a>)</td></tr>
<tr class="memdesc:ae12349a4620fa8936824eb894eaea08f"><td class="mdescLeft"> </td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE.  <a href="classGio_1_1File.html#ae12349a4620fa8936824eb894eaea08f">More...</a><br></br></td></tr>
<tr class="separator:ae12349a4620fa8936824eb894eaea08f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a03d0a86006debd8d517b5d3c9b4f32b9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a03d0a86006debd8d517b5d3c9b4f32b9">mount_mountable</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a03d0a86006debd8d517b5d3c9b4f32b9"><td class="mdescLeft"> </td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE.  <a href="classGio_1_1File.html#a03d0a86006debd8d517b5d3c9b4f32b9">More...</a><br></br></td></tr>
<tr class="separator:a03d0a86006debd8d517b5d3c9b4f32b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab0c85ada254ecee87b66bb3c3f51d663"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab0c85ada254ecee87b66bb3c3f51d663">mount_mountable</a> (const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a>)</td></tr>
<tr class="memdesc:ab0c85ada254ecee87b66bb3c3f51d663"><td class="mdescLeft"> </td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction.  <a href="classGio_1_1File.html#ab0c85ada254ecee87b66bb3c3f51d663">More...</a><br></br></td></tr>
<tr class="separator:ab0c85ada254ecee87b66bb3c3f51d663"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a975050008b7dea5bd7b758c8d99ef62b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a975050008b7dea5bd7b758c8d99ef62b">mount_mountable</a> (<a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a975050008b7dea5bd7b758c8d99ef62b"><td class="mdescLeft"> </td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction.  <a href="classGio_1_1File.html#a975050008b7dea5bd7b758c8d99ef62b">More...</a><br></br></td></tr>
<tr class="separator:a975050008b7dea5bd7b758c8d99ef62b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae15d36a7969c55122b9f85a1690a46e8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8">mount_mountable_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:ae15d36a7969c55122b9f85a1690a46e8"><td class="mdescLeft"> </td><td class="mdescRight">Finishes a mount operation.  <a href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8">More...</a><br></br></td></tr>
<tr class="separator:ae15d36a7969c55122b9f85a1690a46e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad59907320badc6d075f81d867a5b45c8"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad59907320badc6d075f81d867a5b45c8">unmount_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:ad59907320badc6d075f81d867a5b45c8"><td class="mdescLeft"> </td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="classGio_1_1File.html#ad59907320badc6d075f81d867a5b45c8">More...</a><br></br></td></tr>
<tr class="separator:ad59907320badc6d075f81d867a5b45c8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa5fbc336d4236169ada5106bd4cf6cc0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa5fbc336d4236169ada5106bd4cf6cc0">unmount_mountable</a> (const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:aa5fbc336d4236169ada5106bd4cf6cc0"><td class="mdescLeft"> </td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="classGio_1_1File.html#aa5fbc336d4236169ada5106bd4cf6cc0">More...</a><br></br></td></tr>
<tr class="separator:aa5fbc336d4236169ada5106bd4cf6cc0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a50d5cad0c2b6ec64a264b4b3c1535c6c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a50d5cad0c2b6ec64a264b4b3c1535c6c">unmount_mountable</a> (<a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a50d5cad0c2b6ec64a264b4b3c1535c6c"><td class="mdescLeft"> </td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="classGio_1_1File.html#a50d5cad0c2b6ec64a264b4b3c1535c6c">More...</a><br></br></td></tr>
<tr class="separator:a50d5cad0c2b6ec64a264b4b3c1535c6c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a345e1e3328a523516fe5799e4ac3d9da"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a345e1e3328a523516fe5799e4ac3d9da">unmount_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a345e1e3328a523516fe5799e4ac3d9da"><td class="mdescLeft"> </td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="classGio_1_1File.html#a345e1e3328a523516fe5799e4ac3d9da">More...</a><br></br></td></tr>
<tr class="separator:a345e1e3328a523516fe5799e4ac3d9da"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af2e42dca3b08784ca01c805fdc57f386"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af2e42dca3b08784ca01c805fdc57f386">unmount_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:af2e42dca3b08784ca01c805fdc57f386"><td class="mdescLeft"> </td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="classGio_1_1File.html#af2e42dca3b08784ca01c805fdc57f386">More...</a><br></br></td></tr>
<tr class="separator:af2e42dca3b08784ca01c805fdc57f386"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2b2907e2be71adb781363e211095ab50"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2b2907e2be71adb781363e211095ab50">unmount_mountable</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a2b2907e2be71adb781363e211095ab50"><td class="mdescLeft"> </td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="classGio_1_1File.html#a2b2907e2be71adb781363e211095ab50">More...</a><br></br></td></tr>
<tr class="separator:a2b2907e2be71adb781363e211095ab50"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a51458cf04ad25e4a784a3ebcb906155d"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d">unmount_mountable_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a51458cf04ad25e4a784a3ebcb906155d"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details.  <a href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d">More...</a><br></br></td></tr>
<tr class="separator:a51458cf04ad25e4a784a3ebcb906155d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5586b39859cc0c0a42a649de41c878da"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5586b39859cc0c0a42a649de41c878da">eject_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a5586b39859cc0c0a42a649de41c878da"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="classGio_1_1File.html#a5586b39859cc0c0a42a649de41c878da">More...</a><br></br></td></tr>
<tr class="separator:a5586b39859cc0c0a42a649de41c878da"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7de2dbb85ff2e81f9c52424f1e1874d5"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7de2dbb85ff2e81f9c52424f1e1874d5">eject_mountable</a> (const SlotAsyncReady&amp; slot, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a7de2dbb85ff2e81f9c52424f1e1874d5"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="classGio_1_1File.html#a7de2dbb85ff2e81f9c52424f1e1874d5">More...</a><br></br></td></tr>
<tr class="separator:a7de2dbb85ff2e81f9c52424f1e1874d5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a117264f558f4399324293ec55241eda5"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a117264f558f4399324293ec55241eda5">eject_mountable</a> (<a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a117264f558f4399324293ec55241eda5"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="classGio_1_1File.html#a117264f558f4399324293ec55241eda5">More...</a><br></br></td></tr>
<tr class="separator:a117264f558f4399324293ec55241eda5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a51269c0ab9db0c07508b9fae8da08171"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a51269c0ab9db0c07508b9fae8da08171">eject_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a51269c0ab9db0c07508b9fae8da08171"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="classGio_1_1File.html#a51269c0ab9db0c07508b9fae8da08171">More...</a><br></br></td></tr>
<tr class="separator:a51269c0ab9db0c07508b9fae8da08171"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4f1794967577da586a6701670e2dd12e"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4f1794967577da586a6701670e2dd12e">eject_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a4f1794967577da586a6701670e2dd12e"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="classGio_1_1File.html#a4f1794967577da586a6701670e2dd12e">More...</a><br></br></td></tr>
<tr class="separator:a4f1794967577da586a6701670e2dd12e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9ced1df033473c1f89d3bb82fd88fdf"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa9ced1df033473c1f89d3bb82fd88fdf">eject_mountable</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:aa9ced1df033473c1f89d3bb82fd88fdf"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="classGio_1_1File.html#aa9ced1df033473c1f89d3bb82fd88fdf">More...</a><br></br></td></tr>
<tr class="separator:aa9ced1df033473c1f89d3bb82fd88fdf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a5124de7c55e9dc5e85ffcb9d3dd14f"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f">eject_mountable_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a6a5124de7c55e9dc5e85ffcb9d3dd14f"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation().  <a href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f">More...</a><br></br></td></tr>
<tr class="separator:a6a5124de7c55e9dc5e85ffcb9d3dd14f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af57515546dd8c73044d8226f4d73d7f7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af57515546dd8c73044d8226f4d73d7f7">copy_attributes</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>)</td></tr>
<tr class="memdesc:af57515546dd8c73044d8226f4d73d7f7"><td class="mdescLeft"> </td><td class="mdescRight">Copies the file attributes from <em>source</em> to <em>destination</em>.  <a href="classGio_1_1File.html#af57515546dd8c73044d8226f4d73d7f7">More...</a><br></br></td></tr>
<tr class="separator:af57515546dd8c73044d8226f4d73d7f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47a2fb66ac1b20d831e8e6830543e5b9"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a47a2fb66ac1b20d831e8e6830543e5b9">copy_attributes</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> flags=<a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a>)</td></tr>
<tr class="memdesc:a47a2fb66ac1b20d831e8e6830543e5b9"><td class="mdescLeft"> </td><td class="mdescRight">Copies the file attributes from <em>source</em> to <em>destination</em>.  <a href="classGio_1_1File.html#a47a2fb66ac1b20d831e8e6830543e5b9">More...</a><br></br></td></tr>
<tr class="separator:a47a2fb66ac1b20d831e8e6830543e5b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a44a980b923daf347f160797762ba3815"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a44a980b923daf347f160797762ba3815">monitor_directory</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a>)</td></tr>
<tr class="memdesc:a44a980b923daf347f160797762ba3815"><td class="mdescLeft"> </td><td class="mdescRight">Obtains a directory monitor for the given file.  <a href="classGio_1_1File.html#a44a980b923daf347f160797762ba3815">More...</a><br></br></td></tr>
<tr class="separator:a44a980b923daf347f160797762ba3815"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2f57c06f9f9e6ac30a6b38180c1721f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac2f57c06f9f9e6ac30a6b38180c1721f">monitor_directory</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a>)</td></tr>
<tr class="memdesc:ac2f57c06f9f9e6ac30a6b38180c1721f"><td class="mdescLeft"> </td><td class="mdescRight">Obtains a directory monitor for the given file.  <a href="classGio_1_1File.html#ac2f57c06f9f9e6ac30a6b38180c1721f">More...</a><br></br></td></tr>
<tr class="separator:ac2f57c06f9f9e6ac30a6b38180c1721f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4050ecb4732101b921605ada858ffbe7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4050ecb4732101b921605ada858ffbe7">monitor_file</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a>)</td></tr>
<tr class="memdesc:a4050ecb4732101b921605ada858ffbe7"><td class="mdescLeft"> </td><td class="mdescRight">Obtains a file monitor for the given file.  <a href="classGio_1_1File.html#a4050ecb4732101b921605ada858ffbe7">More...</a><br></br></td></tr>
<tr class="separator:a4050ecb4732101b921605ada858ffbe7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a514c5a0b152e61e2df4646f0db9c5e3b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a514c5a0b152e61e2df4646f0db9c5e3b">monitor_file</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a>)</td></tr>
<tr class="memdesc:a514c5a0b152e61e2df4646f0db9c5e3b"><td class="mdescLeft"> </td><td class="mdescRight">Obtains a file monitor for the given file.  <a href="classGio_1_1File.html#a514c5a0b152e61e2df4646f0db9c5e3b">More...</a><br></br></td></tr>
<tr class="separator:a514c5a0b152e61e2df4646f0db9c5e3b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad266a4cf02e3d0c3b094cdaf64098b47"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad266a4cf02e3d0c3b094cdaf64098b47">monitor</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a>)</td></tr>
<tr class="memdesc:ad266a4cf02e3d0c3b094cdaf64098b47"><td class="mdescLeft"> </td><td class="mdescRight">Obtains a file monitor for the given file.  <a href="classGio_1_1File.html#ad266a4cf02e3d0c3b094cdaf64098b47">More...</a><br></br></td></tr>
<tr class="separator:ad266a4cf02e3d0c3b094cdaf64098b47"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab1513c6c380e086241ea61edc77ff0ac"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab1513c6c380e086241ea61edc77ff0ac">monitor</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a>)</td></tr>
<tr class="memdesc:ab1513c6c380e086241ea61edc77ff0ac"><td class="mdescLeft"> </td><td class="mdescRight">Obtains a file monitor for the given file.  <a href="classGio_1_1File.html#ab1513c6c380e086241ea61edc77ff0ac">More...</a><br></br></td></tr>
<tr class="separator:ab1513c6c380e086241ea61edc77ff0ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7841ac4282c5ae77cb70e00863083154"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7841ac4282c5ae77cb70e00863083154">measure_disk_usage</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGio_1_1File.html#aa42b589db64b478d6074a80cf2099729">SlotFileMeasureProgress</a>&amp; slot_progress, guint64&amp; disk_usage, guint64&amp; num_dirs, guint64&amp; num_files, <a class="el" href="group__giommEnums.html#ga970cea61c786fdcd5df56173fcc28201">MeasureFlags</a> flags=<a class="el" href="classGio_1_1File.html#ga970cea61c786fdcd5df56173fcc28201ab50339a10e1de285ac99d4c3990b8693">MeasureFlags::NONE</a>)</td></tr>
<tr class="memdesc:a7841ac4282c5ae77cb70e00863083154"><td class="mdescLeft"> </td><td class="mdescRight">Recursively measures the disk usage of the file.  <a href="classGio_1_1File.html#a7841ac4282c5ae77cb70e00863083154">More...</a><br></br></td></tr>
<tr class="separator:a7841ac4282c5ae77cb70e00863083154"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a960bc67cd620a76454fe8cca6d742888"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a960bc67cd620a76454fe8cca6d742888">measure_disk_usage_async</a> (const SlotAsyncReady&amp; slot_ready, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGio_1_1File.html#aa42b589db64b478d6074a80cf2099729">SlotFileMeasureProgress</a>&amp; slot_progress, <a class="el" href="group__giommEnums.html#ga970cea61c786fdcd5df56173fcc28201">MeasureFlags</a> flags=<a class="el" href="classGio_1_1File.html#ga970cea61c786fdcd5df56173fcc28201ab50339a10e1de285ac99d4c3990b8693">MeasureFlags::NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a960bc67cd620a76454fe8cca6d742888"><td class="mdescLeft"> </td><td class="mdescRight">Recursively measures the disk usage of the file.  <a href="classGio_1_1File.html#a960bc67cd620a76454fe8cca6d742888">More...</a><br></br></td></tr>
<tr class="separator:a960bc67cd620a76454fe8cca6d742888"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5463283f6a20c51d4db7943190350d26"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5463283f6a20c51d4db7943190350d26">measure_disk_usage_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, guint64&amp; disk_usage, guint64&amp; num_dirs, guint64&amp; num_files)</td></tr>
<tr class="memdesc:a5463283f6a20c51d4db7943190350d26"><td class="mdescLeft"> </td><td class="mdescRight">Collects the results from an earlier call to g_file_measure_disk_usage_async().  <a href="classGio_1_1File.html#a5463283f6a20c51d4db7943190350d26">More...</a><br></br></td></tr>
<tr class="separator:a5463283f6a20c51d4db7943190350d26"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abdfa661cf123de9754dd5491cf388184"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abdfa661cf123de9754dd5491cf388184">start_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#ga15a94dcb93f1c5f40bdba5c0fdfb5198">Drive::StartFlags</a> flags=<a class="el" href="classGio_1_1Drive.html#ga15a94dcb93f1c5f40bdba5c0fdfb5198ab50339a10e1de285ac99d4c3990b8693">Drive::StartFlags::NONE</a>)</td></tr>
<tr class="memdesc:abdfa661cf123de9754dd5491cf388184"><td class="mdescLeft"> </td><td class="mdescRight">Starts a file of type Mountable.  <a href="classGio_1_1File.html#abdfa661cf123de9754dd5491cf388184">More...</a><br></br></td></tr>
<tr class="separator:abdfa661cf123de9754dd5491cf388184"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a34624228e0a8039a6719af7049a61721"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a34624228e0a8039a6719af7049a61721">start_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#ga15a94dcb93f1c5f40bdba5c0fdfb5198">Drive::StartFlags</a> flags=<a class="el" href="classGio_1_1Drive.html#ga15a94dcb93f1c5f40bdba5c0fdfb5198ab50339a10e1de285ac99d4c3990b8693">Drive::StartFlags::NONE</a>)</td></tr>
<tr class="memdesc:a34624228e0a8039a6719af7049a61721"><td class="mdescLeft"> </td><td class="mdescRight">Starts a file of type Mountable.  <a href="classGio_1_1File.html#a34624228e0a8039a6719af7049a61721">More...</a><br></br></td></tr>
<tr class="separator:a34624228e0a8039a6719af7049a61721"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af11e51943807876180474b39d2e521ac"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac">start_mountable_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:af11e51943807876180474b39d2e521ac"><td class="mdescLeft"> </td><td class="mdescRight">Finishes a start operation.  <a href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac">More...</a><br></br></td></tr>
<tr class="separator:af11e51943807876180474b39d2e521ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a173f85f0a892dbbdedf27a672e251a15"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a173f85f0a892dbbdedf27a672e251a15">stop_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:a173f85f0a892dbbdedf27a672e251a15"><td class="mdescLeft"> </td><td class="mdescRight">Stops a file of type Mountable.  <a href="classGio_1_1File.html#a173f85f0a892dbbdedf27a672e251a15">More...</a><br></br></td></tr>
<tr class="separator:a173f85f0a892dbbdedf27a672e251a15"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa1a189f682759135c4df353193904231"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa1a189f682759135c4df353193904231">stop_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> flags=<a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a>)</td></tr>
<tr class="memdesc:aa1a189f682759135c4df353193904231"><td class="mdescLeft"> </td><td class="mdescRight">Stops a file of type Mountable.  <a href="classGio_1_1File.html#aa1a189f682759135c4df353193904231">More...</a><br></br></td></tr>
<tr class="separator:aa1a189f682759135c4df353193904231"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a195990af8825745d0d26147174824565"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565">stop_mountable_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a195990af8825745d0d26147174824565"><td class="mdescLeft"> </td><td class="mdescRight">Finishes a stop operation, see g_file_stop_mountable() for details.  <a href="classGio_1_1File.html#a195990af8825745d0d26147174824565">More...</a><br></br></td></tr>
<tr class="separator:a195990af8825745d0d26147174824565"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8e81dd0bab13e56ed98456f6a53591ca"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8e81dd0bab13e56ed98456f6a53591ca">poll_mountable</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a8e81dd0bab13e56ed98456f6a53591ca"><td class="mdescLeft"> </td><td class="mdescRight">Polls a file of type Mountable.  <a href="classGio_1_1File.html#a8e81dd0bab13e56ed98456f6a53591ca">More...</a><br></br></td></tr>
<tr class="separator:a8e81dd0bab13e56ed98456f6a53591ca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2025339de9d7ed9b62300cad1a8e8fd4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2025339de9d7ed9b62300cad1a8e8fd4">poll_mountable</a> (const SlotAsyncReady&amp; slot)</td></tr>
<tr class="memdesc:a2025339de9d7ed9b62300cad1a8e8fd4"><td class="mdescLeft"> </td><td class="mdescRight">Polls a file of type Mountable.  <a href="classGio_1_1File.html#a2025339de9d7ed9b62300cad1a8e8fd4">More...</a><br></br></td></tr>
<tr class="separator:a2025339de9d7ed9b62300cad1a8e8fd4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2da5ec13a4a32f229ca97cce8961e637"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2da5ec13a4a32f229ca97cce8961e637">poll_mountable_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a2da5ec13a4a32f229ca97cce8961e637"><td class="mdescLeft"> </td><td class="mdescRight">Finishes a poll operation.  <a href="classGio_1_1File.html#a2da5ec13a4a32f229ca97cce8961e637">More...</a><br></br></td></tr>
<tr class="separator:a2da5ec13a4a32f229ca97cce8961e637"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a753546465735b25633b003333b66d05c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AppInfo.html">AppInfo</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a753546465735b25633b003333b66d05c">query_default_handler</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a753546465735b25633b003333b66d05c"><td class="mdescLeft"> </td><td class="mdescRight">Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> that is registered as the default application to handle the file specified by <em>file</em>.  <a href="classGio_1_1File.html#a753546465735b25633b003333b66d05c">More...</a><br></br></td></tr>
<tr class="separator:a753546465735b25633b003333b66d05c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0c0fd0ece2570b6704889df5ee43c283"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AppInfo.html">AppInfo</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0c0fd0ece2570b6704889df5ee43c283">query_default_handler</a> ()</td></tr>
<tr class="memdesc:a0c0fd0ece2570b6704889df5ee43c283"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a0c0fd0ece2570b6704889df5ee43c283" title="A query_default_handler() convenience overload. ">query_default_handler()</a> convenience overload.  <a href="classGio_1_1File.html#a0c0fd0ece2570b6704889df5ee43c283">More...</a><br></br></td></tr>
<tr class="separator:a0c0fd0ece2570b6704889df5ee43c283"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac53be228d732b34e062a2a57814cdf15"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15">load_contents</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, char*&amp; contents, gsize&amp; length, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr class="memdesc:ac53be228d732b34e062a2a57814cdf15"><td class="mdescLeft"> </td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data.  <a href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15">More...</a><br></br></td></tr>
<tr class="separator:ac53be228d732b34e062a2a57814cdf15"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ada7c826a417f88b405244c8dc39ae1ef"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ada7c826a417f88b405244c8dc39ae1ef">load_contents</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, char*&amp; contents, gsize&amp; length)</td></tr>
<tr class="memdesc:ada7c826a417f88b405244c8dc39ae1ef"><td class="mdescLeft"> </td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data.  <a href="classGio_1_1File.html#ada7c826a417f88b405244c8dc39ae1ef">More...</a><br></br></td></tr>
<tr class="separator:ada7c826a417f88b405244c8dc39ae1ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a77f7781b0ba65bc4e7e613b80b353fd7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a77f7781b0ba65bc4e7e613b80b353fd7">load_contents</a> (char*&amp; contents, gsize&amp; length, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr class="memdesc:a77f7781b0ba65bc4e7e613b80b353fd7"><td class="mdescLeft"> </td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data.  <a href="classGio_1_1File.html#a77f7781b0ba65bc4e7e613b80b353fd7">More...</a><br></br></td></tr>
<tr class="separator:a77f7781b0ba65bc4e7e613b80b353fd7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40f3ce7cf905144bac7218f9988d2d35"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40f3ce7cf905144bac7218f9988d2d35">load_contents</a> (char*&amp; contents, gsize&amp; length)</td></tr>
<tr class="memdesc:a40f3ce7cf905144bac7218f9988d2d35"><td class="mdescLeft"> </td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data.  <a href="classGio_1_1File.html#a40f3ce7cf905144bac7218f9988d2d35">More...</a><br></br></td></tr>
<tr class="separator:a40f3ce7cf905144bac7218f9988d2d35"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad0e02ebffbaa13036e4636d2118f71a0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad0e02ebffbaa13036e4636d2118f71a0">load_contents_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:ad0e02ebffbaa13036e4636d2118f71a0"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous load of the file's contents.  <a href="classGio_1_1File.html#ad0e02ebffbaa13036e4636d2118f71a0">More...</a><br></br></td></tr>
<tr class="separator:ad0e02ebffbaa13036e4636d2118f71a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6af7ec98d5543bce07b917b65d7276ce"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6af7ec98d5543bce07b917b65d7276ce">load_contents_async</a> (const SlotAsyncReady&amp; slot)</td></tr>
<tr class="memdesc:a6af7ec98d5543bce07b917b65d7276ce"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous load of the file's contents.  <a href="classGio_1_1File.html#a6af7ec98d5543bce07b917b65d7276ce">More...</a><br></br></td></tr>
<tr class="separator:a6af7ec98d5543bce07b917b65d7276ce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5fd15277ab90bcc57db088be04cac457"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457">load_contents_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr class="memdesc:a5fd15277ab90bcc57db088be04cac457"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous load of the <em>file's</em> contents.  <a href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457">More...</a><br></br></td></tr>
<tr class="separator:a5fd15277ab90bcc57db088be04cac457"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee93c7e24e8391615f9f263584fb02bd"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aee93c7e24e8391615f9f263584fb02bd">load_contents_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length)</td></tr>
<tr class="memdesc:aee93c7e24e8391615f9f263584fb02bd"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous load of the <em>file's</em> contents.  <a href="classGio_1_1File.html#aee93c7e24e8391615f9f263584fb02bd">More...</a><br></br></td></tr>
<tr class="separator:aee93c7e24e8391615f9f263584fb02bd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0e8d95fcdf7c2aa38f54e90a22d3ab6f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f">load_partial_contents_async</a> (const <a class="el" href="classGio_1_1File.html#a5977e55c02f52afc78d9091cd3eab8ed">SlotReadMore</a>&amp; slot_read_more, const SlotAsyncReady&amp; slot_async_ready, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a0e8d95fcdf7c2aa38f54e90a22d3ab6f"><td class="mdescLeft"> </td><td class="mdescRight">Reads the partial contents of a file.  <a href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f">More...</a><br></br></td></tr>
<tr class="separator:a0e8d95fcdf7c2aa38f54e90a22d3ab6f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a362d71932c0ba8797a8c47b77df1b6d7"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a362d71932c0ba8797a8c47b77df1b6d7">load_partial_contents_async</a> (const <a class="el" href="classGio_1_1File.html#a5977e55c02f52afc78d9091cd3eab8ed">SlotReadMore</a>&amp; slot_read_more, const SlotAsyncReady&amp; slot_async_ready)</td></tr>
<tr class="memdesc:a362d71932c0ba8797a8c47b77df1b6d7"><td class="mdescLeft"> </td><td class="mdescRight">Reads the partial contents of a file.  <a href="classGio_1_1File.html#a362d71932c0ba8797a8c47b77df1b6d7">More...</a><br></br></td></tr>
<tr class="separator:a362d71932c0ba8797a8c47b77df1b6d7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b323508401d2e6fd2b3ad659f9bb5eb"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb">load_partial_contents_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr class="memdesc:a4b323508401d2e6fd2b3ad659f9bb5eb"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file. ">load_partial_contents_async()</a>.  <a href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb">More...</a><br></br></td></tr>
<tr class="separator:a4b323508401d2e6fd2b3ad659f9bb5eb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae3a59c3831feeadea9bd0709617d2db9"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae3a59c3831feeadea9bd0709617d2db9">load_partial_contents_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length)</td></tr>
<tr class="memdesc:ae3a59c3831feeadea9bd0709617d2db9"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file. ">load_partial_contents_async()</a>.  <a href="classGio_1_1File.html#ae3a59c3831feeadea9bd0709617d2db9">More...</a><br></br></td></tr>
<tr class="separator:ae3a59c3831feeadea9bd0709617d2db9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2a9fbab61953ff81d79a9ec797b65ab1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2a9fbab61953ff81d79a9ec797b65ab1">replace_contents</a> (const char* contents, gsize length, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a2a9fbab61953ff81d79a9ec797b65ab1"><td class="mdescLeft"> </td><td class="mdescRight">Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes.  <a href="classGio_1_1File.html#a2a9fbab61953ff81d79a9ec797b65ab1">More...</a><br></br></td></tr>
<tr class="separator:a2a9fbab61953ff81d79a9ec797b65ab1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad11e49651118499dc9127c9a92a1965c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad11e49651118499dc9127c9a92a1965c">replace_contents</a> (const char* contents, gsize length, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:ad11e49651118499dc9127c9a92a1965c"><td class="mdescLeft"> </td><td class="mdescRight">Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes.  <a href="classGio_1_1File.html#ad11e49651118499dc9127c9a92a1965c">More...</a><br></br></td></tr>
<tr class="separator:ad11e49651118499dc9127c9a92a1965c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a49fff959d08c22b67004e13a0a6478ef"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a49fff959d08c22b67004e13a0a6478ef">replace_contents</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a49fff959d08c22b67004e13a0a6478ef"><td class="mdescLeft"> </td><td class="mdescRight">Replaces the contents of the file with <em>contents</em>.  <a href="classGio_1_1File.html#a49fff959d08c22b67004e13a0a6478ef">More...</a><br></br></td></tr>
<tr class="separator:a49fff959d08c22b67004e13a0a6478ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae97189c7fd13c47ae6b77ec841eecc2c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae97189c7fd13c47ae6b77ec841eecc2c">replace_contents</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:ae97189c7fd13c47ae6b77ec841eecc2c"><td class="mdescLeft"> </td><td class="mdescRight">Replaces the contents of the file with <em>contents</em>.  <a href="classGio_1_1File.html#ae97189c7fd13c47ae6b77ec841eecc2c">More...</a><br></br></td></tr>
<tr class="separator:ae97189c7fd13c47ae6b77ec841eecc2c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa4355c5493713e32e2a4f1f2c9d923fb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa4355c5493713e32e2a4f1f2c9d923fb">replace_contents_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const char* contents, gsize length, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:aa4355c5493713e32e2a4f1f2c9d923fb"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes.  <a href="classGio_1_1File.html#aa4355c5493713e32e2a4f1f2c9d923fb">More...</a><br></br></td></tr>
<tr class="separator:aa4355c5493713e32e2a4f1f2c9d923fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adf7263f8473b92da80a4958c80c06e6a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#adf7263f8473b92da80a4958c80c06e6a">replace_contents_async</a> (const SlotAsyncReady&amp; slot, const char* contents, gsize length, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:adf7263f8473b92da80a4958c80c06e6a"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes.  <a href="classGio_1_1File.html#adf7263f8473b92da80a4958c80c06e6a">More...</a><br></br></td></tr>
<tr class="separator:adf7263f8473b92da80a4958c80c06e6a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a09247b840eed74d688ac38dd46e2fd84"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a09247b840eed74d688ac38dd46e2fd84">replace_contents_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a09247b840eed74d688ac38dd46e2fd84"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes.  <a href="classGio_1_1File.html#a09247b840eed74d688ac38dd46e2fd84">More...</a><br></br></td></tr>
<tr class="separator:a09247b840eed74d688ac38dd46e2fd84"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2d57cddf6becface248df2071ced2f0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac2d57cddf6becface248df2071ced2f0">replace_contents_async</a> (const SlotAsyncReady&amp; slot, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:ac2d57cddf6becface248df2071ced2f0"><td class="mdescLeft"> </td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em>.  <a href="classGio_1_1File.html#ac2d57cddf6becface248df2071ced2f0">More...</a><br></br></td></tr>
<tr class="separator:ac2d57cddf6becface248df2071ced2f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afbe0e644bafcb88ce52b62de803167cd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd">replace_contents_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag)</td></tr>
<tr class="memdesc:afbe0e644bafcb88ce52b62de803167cd"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous replace of the given file .  <a href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd">More...</a><br></br></td></tr>
<tr class="separator:afbe0e644bafcb88ce52b62de803167cd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af0372ffd3f535f39b7e48c0483e4c1f4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af0372ffd3f535f39b7e48c0483e4c1f4">replace_contents_finish</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:af0372ffd3f535f39b7e48c0483e4c1f4"><td class="mdescLeft"> </td><td class="mdescRight">Finishes an asynchronous replace of the given file .  <a href="classGio_1_1File.html#af0372ffd3f535f39b7e48c0483e4c1f4">More...</a><br></br></td></tr>
<tr class="separator:af0372ffd3f535f39b7e48c0483e4c1f4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a350dbc9f509735ef912e1382fee5a50a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a350dbc9f509735ef912e1382fee5a50a">replace_contents_bytes_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a> &gt;&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:a350dbc9f509735ef912e1382fee5a50a"><td class="mdescLeft"> </td><td class="mdescRight">Same as <a class="el" href="classGio_1_1File.html#aa4355c5493713e32e2a4f1f2c9d923fb" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a> but takes a Gio::Bytes input instead.  <a href="classGio_1_1File.html#a350dbc9f509735ef912e1382fee5a50a">More...</a><br></br></td></tr>
<tr class="separator:a350dbc9f509735ef912e1382fee5a50a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec12b716994baa347cecf868b3d8a3b8"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aec12b716994baa347cecf868b3d8a3b8">replace_contents_bytes_async</a> (const SlotAsyncReady&amp; slot, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a> &gt;&amp; contents, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> flags=<a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a>)</td></tr>
<tr class="memdesc:aec12b716994baa347cecf868b3d8a3b8"><td class="mdescLeft"> </td><td class="mdescRight">Same as <a class="el" href="classGio_1_1File.html#aa4355c5493713e32e2a4f1f2c9d923fb" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a> but takes a Gio::Bytes input instead.  <a href="classGio_1_1File.html#aec12b716994baa347cecf868b3d8a3b8">More...</a><br></br></td></tr>
<tr class="separator:aec12b716994baa347cecf868b3d8a3b8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab666a9ec3922903646504f4080758522"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab666a9ec3922903646504f4080758522">supports_thread_contexts</a> () const </td></tr>
<tr class="memdesc:ab666a9ec3922903646504f4080758522"><td class="mdescLeft"> </td><td class="mdescRight">Checks if <em>file</em> supports [thread-default contexts][g-main-context-push-thread-default-context].  <a href="classGio_1_1File.html#ab666a9ec3922903646504f4080758522">More...</a><br></br></td></tr>
<tr class="separator:ab666a9ec3922903646504f4080758522"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1Interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1Interface')"><img alt="-" src="closed.png"></img> Public Member Functions inherited from <a class="el" href="classGlib_1_1Interface.html">Glib::Interface</a></td></tr>
<tr class="memitem:a3ab20f29c40967352d1bf2d88bfe11e5 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a3ab20f29c40967352d1bf2d88bfe11e5">Interface</a> ()</td></tr>
<tr class="memdesc:a3ab20f29c40967352d1bf2d88bfe11e5 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft"> </td><td class="mdescRight">A Default constructor.  <a href="classGio_1_1File.html#a3ab20f29c40967352d1bf2d88bfe11e5">More...</a><br></br></td></tr>
<tr class="separator:a3ab20f29c40967352d1bf2d88bfe11e5 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83337dc270f966539b9f46804460ab75 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a83337dc270f966539b9f46804460ab75">Interface</a> (<a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a83337dc270f966539b9f46804460ab75 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a411d66c7467e749dbb2c4b31c4d518b5 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a411d66c7467e749dbb2c4b31c4d518b5">operator=</a> (<a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a411d66c7467e749dbb2c4b31c4d518b5 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#ae05bf6a4ce0f0992c2ad01429d13f9f7">Interface</a> (const Glib::Interface_Class&amp; interface_class)</td></tr>
<tr class="memdesc:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft"> </td><td class="mdescRight">Called by constructors of derived classes.  <a href="classGio_1_1File.html#ae05bf6a4ce0f0992c2ad01429d13f9f7">More...</a><br></br></td></tr>
<tr class="separator:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a00253b22a76f751f1627865451cbc404">Interface</a> (GObject* castitem)</td></tr>
<tr class="memdesc:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft"> </td><td class="mdescRight">Called by constructors of derived classes.  <a href="classGio_1_1File.html#a00253b22a76f751f1627865451cbc404">More...</a><br></br></td></tr>
<tr class="separator:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a158029af7ab7279e18ab84ad6f5ad5 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a3a158029af7ab7279e18ab84ad6f5ad5">~Interface</a> () noexcept override</td></tr>
<tr class="separator:a3a158029af7ab7279e18ab84ad6f5ad5 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4bb27d294728f34452be66b4ec4cd757 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a4bb27d294728f34452be66b4ec4cd757">Interface</a> (const <a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;)=delete</td></tr>
<tr class="separator:a4bb27d294728f34452be66b4ec4cd757 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acf322f95cef17aa4cc232d8ef25f2b42 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#acf322f95cef17aa4cc232d8ef25f2b42">operator=</a> (const <a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;)=delete</td></tr>
<tr class="separator:acf322f95cef17aa4cc232d8ef25f2b42 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a969e9396f75132a9577428f4fa932d42 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top">GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a969e9396f75132a9577428f4fa932d42">gobj</a> ()</td></tr>
<tr class="separator:a969e9396f75132a9577428f4fa932d42 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a70a443071a69d3372c2cdd7128a91ed1 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top">const GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a70a443071a69d3372c2cdd7128a91ed1">gobj</a> () const </td></tr>
<tr class="separator:a70a443071a69d3372c2cdd7128a91ed1 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1ObjectBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1ObjectBase')"><img alt="-" src="closed.png"></img> Public Member Functions inherited from <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a></td></tr>
<tr class="memitem:aaf0e140e7192dcecddd9f57c46825434 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#aaf0e140e7192dcecddd9f57c46825434">ObjectBase</a> (const <a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;)=delete</td></tr>
<tr class="separator:aaf0e140e7192dcecddd9f57c46825434 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a15f8834a320eac98dc1c1b8a9a2fd4c1 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a15f8834a320eac98dc1c1b8a9a2fd4c1">operator=</a> (const <a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;)=delete</td></tr>
<tr class="separator:a15f8834a320eac98dc1c1b8a9a2fd4c1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#aab599d3eec4b4a9ddc95ccdc6100053d">set_property_value</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const <a class="el" href="classGlib_1_1ValueBase.html">Glib::ValueBase</a>&amp; value)</td></tr>
<tr class="memdesc:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1File.html#aab599d3eec4b4a9ddc95ccdc6100053d">More...</a><br></br></td></tr>
<tr class="separator:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5e30750441b92f0246c9d4ece95fc8a0">get_property_value</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, <a class="el" href="classGlib_1_1ValueBase.html">Glib::ValueBase</a>&amp; value) const </td></tr>
<tr class="memdesc:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1File.html#a5e30750441b92f0246c9d4ece95fc8a0">More...</a><br></br></td></tr>
<tr class="separator:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad37844f7ea2c0091a22d011e04c48820">set_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const PropertyType&amp; value)</td></tr>
<tr class="memdesc:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1File.html#ad37844f7ea2c0091a22d011e04c48820">More...</a><br></br></td></tr>
<tr class="separator:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5f894c9c36ad391fdc85552af67a8530">get_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, PropertyType&amp; value) const </td></tr>
<tr class="memdesc:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1File.html#a5f894c9c36ad391fdc85552af67a8530">More...</a><br></br></td></tr>
<tr class="separator:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad13198dfb78c8f54eff75034f9282c36 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:ad13198dfb78c8f54eff75034f9282c36 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memTemplItemLeft" valign="top">PropertyType </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad13198dfb78c8f54eff75034f9282c36">get_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name) const </td></tr>
<tr class="memdesc:ad13198dfb78c8f54eff75034f9282c36 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1File.html#ad13198dfb78c8f54eff75034f9282c36">More...</a><br></br></td></tr>
<tr class="separator:ad13198dfb78c8f54eff75034f9282c36 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b6fbb318fff3492ac8d0ab4767ac326 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1connection.html">sigc::connection</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5b6fbb318fff3492ac8d0ab4767ac326">connect_property_changed</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const sigc::slot&lt; void()&gt;&amp; slot)</td></tr>
<tr class="memdesc:a5b6fbb318fff3492ac8d0ab4767ac326 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead.  <a href="classGio_1_1File.html#a5b6fbb318fff3492ac8d0ab4767ac326">More...</a><br></br></td></tr>
<tr class="separator:a5b6fbb318fff3492ac8d0ab4767ac326 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a04031f42ca0f61950325b6322442bff4 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1connection.html">sigc::connection</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a04031f42ca0f61950325b6322442bff4">connect_property_changed</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, sigc::slot&lt; void()&gt;&amp;&amp; slot)</td></tr>
<tr class="memdesc:a04031f42ca0f61950325b6322442bff4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead.  <a href="classGio_1_1File.html#a04031f42ca0f61950325b6322442bff4">More...</a><br></br></td></tr>
<tr class="separator:a04031f42ca0f61950325b6322442bff4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a6e9e13b75f116c20212d318204ce8ea3">freeze_notify</a> ()</td></tr>
<tr class="memdesc:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Increases the freeze count on object.  <a href="classGio_1_1File.html#a6e9e13b75f116c20212d318204ce8ea3">More...</a><br></br></td></tr>
<tr class="separator:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a1bd8ea7bd8c4084ade6b3c27dddf06a4">thaw_notify</a> ()</td></tr>
<tr class="memdesc:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Reverts the effect of a previous call to <a class="el" href="classGlib_1_1ObjectBase.html#a6e9e13b75f116c20212d318204ce8ea3" title="Increases the freeze count on object. ">freeze_notify()</a>.  <a href="classGio_1_1File.html#a1bd8ea7bd8c4084ade6b3c27dddf06a4">More...</a><br></br></td></tr>
<tr class="separator:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a896a8a5db20043ea82956e3ef4b9c4ae">reference</a> () const </td></tr>
<tr class="memdesc:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Increment the reference count for this object.  <a href="classGio_1_1File.html#a896a8a5db20043ea82956e3ef4b9c4ae">More...</a><br></br></td></tr>
<tr class="separator:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3234b8ffb2a35b927e2978c8f3bfbfe3">unreference</a> () const </td></tr>
<tr class="memdesc:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Decrement the reference count for this object.  <a href="classGio_1_1File.html#a3234b8ffb2a35b927e2978c8f3bfbfe3">More...</a><br></br></td></tr>
<tr class="separator:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">gobj</a> ()</td></tr>
<tr class="memdesc:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1File.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">More...</a><br></br></td></tr>
<tr class="separator:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">const GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">gobj</a> () const </td></tr>
<tr class="memdesc:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1File.html#a778a94181132976bbfb0519793f3b32e">More...</a><br></br></td></tr>
<tr class="separator:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a9b2a5eb93102f1849e5419016e22a15f">gobj_copy</a> () const </td></tr>
<tr class="memdesc:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Give a ref-ed copy to someone. Use for direct struct access.  <a href="classGio_1_1File.html#a9b2a5eb93102f1849e5419016e22a15f">More...</a><br></br></td></tr>
<tr class="separator:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_structsigc_1_1trackable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structsigc_1_1trackable')"><img alt="-" src="closed.png"></img> Public Member Functions inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a></td></tr>
<tr class="memitem:a7e1348841e762fb41b41c6f2ce9fa073 inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a7e1348841e762fb41b41c6f2ce9fa073">trackable</a> () noexcept</td></tr>
<tr class="separator:a7e1348841e762fb41b41c6f2ce9fa073 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac8431d9452c9698a012597e6560c72fa inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#ac8431d9452c9698a012597e6560c72fa">trackable</a> (const <a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp;src) noexcept</td></tr>
<tr class="separator:ac8431d9452c9698a012597e6560c72fa inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a6ff5a4d7c51cede2117525f470f96a inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a9a6ff5a4d7c51cede2117525f470f96a">trackable</a> (<a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:a9a6ff5a4d7c51cede2117525f470f96a inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a75587da09e30031db7a2519843f1f4fb inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a75587da09e30031db7a2519843f1f4fb">~trackable</a> ()</td></tr>
<tr class="separator:a75587da09e30031db7a2519843f1f4fb inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a146daab307d37c92b68a974c79ed10b7 inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a146daab307d37c92b68a974c79ed10b7">add_destroy_notify_callback</a> (<a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html">notifiable</a> *data, <a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html#a71455cae4b10ff1277e68a1729e1b8c4">func_destroy_notify</a> func) const </td></tr>
<tr class="separator:a146daab307d37c92b68a974c79ed10b7 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af2e23cfe7adc1ca844a3350bbac557cb inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#af2e23cfe7adc1ca844a3350bbac557cb">notify_callbacks</a> ()</td></tr>
<tr class="separator:af2e23cfe7adc1ca844a3350bbac557cb inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7494fbad23a65932ff1457d00d4edaf5 inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a7494fbad23a65932ff1457d00d4edaf5">operator=</a> (const <a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp;src)</td></tr>
<tr class="separator:a7494fbad23a65932ff1457d00d4edaf5 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a400b5799372238211a4437844d923a4e inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a400b5799372238211a4437844d923a4e">operator=</a> (<a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:a400b5799372238211a4437844d923a4e inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a700a7b0a5059a9c8eda2b1a6eb6905f8 inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a700a7b0a5059a9c8eda2b1a6eb6905f8">remove_destroy_notify_callback</a> (<a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html">notifiable</a> *data) const </td></tr>
<tr class="separator:a700a7b0a5059a9c8eda2b1a6eb6905f8 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa9352e68c93431dd16b8ac587703772f"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa9352e68c93431dd16b8ac587703772f">add_interface</a> (GType gtype_implementer)</td></tr>
<tr class="separator:aa9352e68c93431dd16b8ac587703772f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a1cbe348685c278bb7df93ee8018442"><td align="right" class="memItemLeft" valign="top">static GType </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9a1cbe348685c278bb7df93ee8018442">get_type</a> ()</td></tr>
<tr class="memdesc:a9a1cbe348685c278bb7df93ee8018442"><td class="mdescLeft"> </td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="classGio_1_1File.html#a9a1cbe348685c278bb7df93ee8018442">More...</a><br></br></td></tr>
<tr class="separator:a9a1cbe348685c278bb7df93ee8018442"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1b1a4553b226689d50b9525488223e25"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1b1a4553b226689d50b9525488223e25">create_for_path</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; path)</td></tr>
<tr class="memdesc:a1b1a4553b226689d50b9525488223e25"><td class="mdescLeft"> </td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given path.  <a href="classGio_1_1File.html#a1b1a4553b226689d50b9525488223e25">More...</a><br></br></td></tr>
<tr class="separator:a1b1a4553b226689d50b9525488223e25"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a412b6b55f37f69bd4fb8fbd24d4967be"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a412b6b55f37f69bd4fb8fbd24d4967be">create_for_uri</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; uri)</td></tr>
<tr class="memdesc:a412b6b55f37f69bd4fb8fbd24d4967be"><td class="mdescLeft"> </td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given URI.  <a href="classGio_1_1File.html#a412b6b55f37f69bd4fb8fbd24d4967be">More...</a><br></br></td></tr>
<tr class="separator:a412b6b55f37f69bd4fb8fbd24d4967be"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab311a1c606b3907865fc8aecd4691de8"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab311a1c606b3907865fc8aecd4691de8">create_for_commandline_arg</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01473.html#ga943544cb1017a51d7cafc7b4d3cd022f">arg</a>)</td></tr>
<tr class="memdesc:ab311a1c606b3907865fc8aecd4691de8"><td class="mdescLeft"> </td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given argument from the command line.  <a href="classGio_1_1File.html#ab311a1c606b3907865fc8aecd4691de8">More...</a><br></br></td></tr>
<tr class="separator:ab311a1c606b3907865fc8aecd4691de8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7532baa6ce71fe27cfd1e9bba91a3536"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7532baa6ce71fe27cfd1e9bba91a3536">create_for_parse_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; parse_name)</td></tr>
<tr class="separator:a7532baa6ce71fe27cfd1e9bba91a3536"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abb3b1f0b8e19505b34ae084c518d20fc"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abb3b1f0b8e19505b34ae084c518d20fc">File</a> ()</td></tr>
<tr class="memdesc:abb3b1f0b8e19505b34ae084c518d20fc"><td class="mdescLeft"> </td><td class="mdescRight">You should derive from this class to use it.  <a href="classGio_1_1File.html#abb3b1f0b8e19505b34ae084c518d20fc">More...</a><br></br></td></tr>
<tr class="separator:abb3b1f0b8e19505b34ae084c518d20fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pro_methods_classGlib_1_1ObjectBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGlib_1_1ObjectBase')"><img alt="-" src="closed.png"></img> Protected Member Functions inherited from <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a></td></tr>
<tr class="memitem:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a27d3451d9ca28d6a2f00838d7c56d545">ObjectBase</a> ()</td></tr>
<tr class="memdesc:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">This default constructor is called implicitly from the constructor of user-derived classes, even if, for instance, Gtk::Button calls a different <a class="el" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces. ">ObjectBase</a> constructor.  <a href="classGio_1_1File.html#a27d3451d9ca28d6a2f00838d7c56d545">More...</a><br></br></td></tr>
<tr class="separator:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad4ef18214894c6874579313ab21d1018">ObjectBase</a> (const char* custom_type_name)</td></tr>
<tr class="memdesc:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">A derived constructor always overrides this choice.  <a href="classGio_1_1File.html#ad4ef18214894c6874579313ab21d1018">More...</a><br></br></td></tr>
<tr class="separator:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3d59b4d85b0ee72a727e6b2e1b31a2ff">ObjectBase</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01672.html">std::type_info</a>&amp; custom_type_info)</td></tr>
<tr class="memdesc:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">This constructor is a special feature to allow creation of derived types on the fly, without having to use g_object_new() manually.  <a href="classGio_1_1File.html#a3d59b4d85b0ee72a727e6b2e1b31a2ff">More...</a><br></br></td></tr>
<tr class="separator:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7e2e177061f6a6e09c4cf3da49c6dfd3 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a7e2e177061f6a6e09c4cf3da49c6dfd3">ObjectBase</a> (<a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a7e2e177061f6a6e09c4cf3da49c6dfd3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e968f118314ba4d5debfd2850d18003 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a2e968f118314ba4d5debfd2850d18003">operator=</a> (<a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a2e968f118314ba4d5debfd2850d18003 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae56ec45e9ebeaacf24be4fb54ed2eea3 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">virtual </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ae56ec45e9ebeaacf24be4fb54ed2eea3">~ObjectBase</a> () noexcept=0</td></tr>
<tr class="separator:ae56ec45e9ebeaacf24be4fb54ed2eea3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3faafb14c4f0ca60fbf0f5f5c4d549d0 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3faafb14c4f0ca60fbf0f5f5c4d549d0">initialize</a> (GObject* castitem)</td></tr>
<tr class="separator:a3faafb14c4f0ca60fbf0f5f5c4d549d0 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a44ddc123cd98ed0083aa06364365c8d3 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a44ddc123cd98ed0083aa06364365c8d3">initialize_move</a> (GObject* castitem, <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a>* previous_wrapper)</td></tr>
<tr class="separator:a44ddc123cd98ed0083aa06364365c8d3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a69670cdc7cf63783d6f9370dcbd7cc3d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">Gio::File</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a69670cdc7cf63783d6f9370dcbd7cc3d">wrap</a> (GFile* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a69670cdc7cf63783d6f9370dcbd7cc3d"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="classGio_1_1File.html#a69670cdc7cf63783d6f9370dcbd7cc3d">More...</a><br></br></td></tr>
<tr class="separator:a69670cdc7cf63783d6f9370dcbd7cc3d"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> and directory handling. </p>
<p><a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> is a high level abstraction for manipulating files on a virtual file system. Gio::Files are lightweight, immutable objects that do no I/O upon creation. It is necessary to understand that a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> object does not represent a file, merely a handle to a file. All file I/O is implemented as streaming operations (see <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input. ">Gio::InputStream</a> and <a class="el" href="classGio_1_1OutputStream.html" title="Base class for implementing streaming output. ">Gio::OutputStream</a>).</p>
<p>A GioFile can be constructed from a path, URI, or a command line argument.</p>
<p>You can move through the filesystem with <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> handles with <a class="el" href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94" title="Gets the parent directory for the file. ">get_parent()</a> to get a handle to the parent directory, <a class="el" href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c" title="Gets a child of file with basename equal to name. ">get_child()</a> to get a handle to a child within a directory, and <a class="el" href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03" title="Resolves a relative path for file to an absolute path. ">resolve_relative_path()</a> to resolve a relative path between two Gio::Files.</p>
<p>Many <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> operations have both synchronous and asynchronous versions to suit your application. Asynchronous versions of synchronous functions simply have _async() appended to their function names. The asynchronous I/O functions call a SlotAsyncReady callback slot which is then used to finalize the operation, producing a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a> which is then passed to the function's matching _finish() operation.</p>
<p>Some <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> operations do not have synchronous analogs, as they may take a very long time to finish, and blocking may leave an application unusable. Notable cases include: <a class="el" href="classGio_1_1File.html#ae12349a4620fa8936824eb894eaea08f" title="Mounts a file of type FILE_TYPE_MOUNTABLE. ">mount_mountable()</a> to mount a mountable file, <a class="el" href="classGio_1_1File.html#ad59907320badc6d075f81d867a5b45c8" title="Unmounts a file of type FILE_TYPE_MOUNTABLE. ">unmount_mountable()</a> to unmount a mountable file, and <a class="el" href="classGio_1_1File.html#a5586b39859cc0c0a42a649de41c878da" title="Starts an asynchronous eject on a mountable. ">eject_mountable()</a> to eject a mountable file.</p>
<p>One notable feature of Gio::Files are entity tags, or "etags" for short. Entity tags are somewhat like a more abstract version of the traditional mtime, and can be used to quickly determine if the file has been modified from the version on the file system. See the HTTP 1.1 specification for HTTP Etag headers, which are a very similar concept.</p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000058">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa42b589db64b478d6074a80cf2099729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classGio_1_1File.html#aa42b589db64b478d6074a80cf2099729">Gio::File::SlotFileMeasureProgress</a> =  sigc::slot&lt;void(bool, guint64, guint64, guint64)&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This slot type is used by <a class="el" href="classGio_1_1File.html#a7841ac4282c5ae77cb70e00863083154" title="Recursively measures the disk usage of the file. ">measure_disk_usage()</a> to make periodic progress reports when measuring the amount of disk spaced used by a directory. </p>
<p>These calls are made on a best-effort basis and not all types of GFile will support them. At the minimum, however, one call will always be made immediately.</p>
<p>In the case that there is no support, <em>reporting</em> will be set to false (and the other values undefined) and no further calls will be made. Otherwise, the <em>reporting</em> will be true and the other values all-zeros during the first (immediate) call. In this way, you can know which type of progress UI to show without a delay.</p>
<p>For <a class="el" href="classGio_1_1File.html#a7841ac4282c5ae77cb70e00863083154" title="Recursively measures the disk usage of the file. ">measure_disk_usage()</a> the callback is made directly. For <a class="el" href="classGio_1_1File.html#a960bc67cd620a76454fe8cca6d742888" title="Recursively measures the disk usage of the file. ">measure_disk_usage_async()</a> the callback is made via the default main context of the calling thread (ie: the same way that the final async result would be reported).</p>
<p><em>current_size</em> is in the same units as requested by the operation (see FILE_DISK_USAGE_APPARENT_SIZE).</p>
<p>The frequency of the updates is implementation defined, but is ideally about once every 200ms.</p>
<p>The last progress callback may or may not be equal to the final result. Always check the async result to get the final value.</p>
<p>For instance, void on_file_measure_progress(bool reporting, guint64 current_size, guint64 num_dirs, guint64 num_files);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">reporting</td><td>true if more reports will come. </td></tr>
    <tr><td class="paramname">current_size</td><td>The current cumulative size measurement. </td></tr>
    <tr><td class="paramname">num_dirs</td><td>The number of directories visited so far. </td></tr>
    <tr><td class="paramname">num_files</td><td>The number of non-directory files encountered.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000017">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8ac8e3eb55eab168a75d934edcb2ab22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">Gio::File::SlotFileProgress</a> =  sigc::slot&lt;void(goffset, goffset)&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A signal handler would be, for instance: void on_file_progress(goffset current_num_bytes, goffset total_num_bytes);. </p>

</div>
</div>
<a class="anchor" id="a5977e55c02f52afc78d9091cd3eab8ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classGio_1_1File.html#a5977e55c02f52afc78d9091cd3eab8ed">Gio::File::SlotReadMore</a> =  sigc::slot&lt;bool(const char*, goffset)&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A signal handler would be, for instance: bool on_read_more(const char* file_contents, goffset file_size);. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abb3b1f0b8e19505b34ae084c518d20fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gio::File::File </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>You should derive from this class to use it. </p>

</div>
</div>
<a class="anchor" id="a91341a5c27005398bef11c6b232f2ec8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gio::File::File </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGio_1_1File.html">File</a>&amp;&amp; </td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adf1624302e7d139bbf462eb35cf6ddd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gio::File::~File </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa9352e68c93431dd16b8ac587703772f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static void Gio::File::add_interface </td>
          <td>(</td>
          <td class="paramtype">GType </td>
          <td class="paramname"><em>gtype_implementer</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8749bba26443b6adab85c0cf5d69a93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::append_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets an output stream for appending data to the file. </p>
<p>If the file doesn't already exist it is created.</p>
<p>By default files created are generally readable by everyone, but if you pass <a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6a84c6d22cfdf3772e66b07bde636e0571" title="Create a file that can only be accessed by the current user. ">CreateFlags::PRIVATE</a> in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a25aca58f2c66dfb9de40e531aaf41256"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::append_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets an output stream for appending data to the file. </p>
<p>If the file doesn't already exist it is created.</p>
<p>By default files created are generally readable by everyone, but if you pass <a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6a84c6d22cfdf3772e66b07bde636e0571" title="Create a file that can only be accessed by the current user. ">CreateFlags::PRIVATE</a> in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ea55b0e04fa8ab1ea52d9e97c634722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::append_to_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously opens the file for appending. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad8749bba26443b6adab85c0cf5d69a93" title="Gets an output stream for appending data to the file. ">append_to()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab95fdc72631ad9a07a94eac0bac50090" title="Finishes an asynchronous file append operation started with g_file_append_to_async(). ">append_to_finish()</a> to get the result of the operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa20bd10a0f98bba05ec3fb88e8ea8fba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::append_to_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously opens the file for appending. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad8749bba26443b6adab85c0cf5d69a93" title="Gets an output stream for appending data to the file. ">append_to()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab95fdc72631ad9a07a94eac0bac50090" title="Finishes an asynchronous file append operation started with g_file_append_to_async(). ">append_to_finish()</a> to get the result of the operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab95fdc72631ad9a07a94eac0bac50090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::append_to_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous file append operation started with g_file_append_to_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td><a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14f3429c51dd8af76d56c73e148321d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is specified an already existing destination file is overwritten. If the flag <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ac19ab3ff46eb1025b6944f450e95514e" title="Don't follow symlinks. ">CopyFlags::NOFOLLOW_SYMLINKS</a> is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The operation can be monitored via the <em>slot</em> callback.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle. ">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="a294ad252c16999322da80a2b7af3926a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is specified an already existing destination file is overwritten. If the flag <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ac19ab3ff46eb1025b6944f450e95514e" title="Don't follow symlinks. ">CopyFlags::NOFOLLOW_SYMLINKS</a> is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be monitored via the <em>slot</em> callback.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle. ">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="a10eb6824d2430e3e4806df10f385fa46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is specified an already existing destination file is overwritten. If the flag <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ac19ab3ff46eb1025b6944f450e95514e" title="Don't follow symlinks. ">CopyFlags::NOFOLLOW_SYMLINKS</a> is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle. ">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="a8bf6e7a24bf7b50df3daba3d587ded31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; </td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#a14f3429c51dd8af76d56c73e148321d2" title="Copies the file source to the location specified by destination. ">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7" title="Finishes copying the file started with g_file_copy_async(). ">copy_finish()</a> to get the result of the operation.</p>
<p>The function specified by <em>slot_progress</em> will be called just like in <a class="el" href="classGio_1_1File.html#a14f3429c51dd8af76d56c73e148321d2" title="Copies the file source to the location specified by destination. ">copy()</a>, however the callback will run in the main loop, not in the thread that is doing the I/O operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> </td></tr>
    <tr><td class="paramname">slot_progress</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">flags</td><td>Set of CopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a497af04aad912b3ad816530d1ac31f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#a14f3429c51dd8af76d56c73e148321d2" title="Copies the file source to the location specified by destination. ">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7" title="Finishes copying the file started with g_file_copy_async(). ">copy_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">flags</td><td>Set of CopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af25073f3374aae4bbf697c6ed0c880fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; </td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#a14f3429c51dd8af76d56c73e148321d2" title="Copies the file source to the location specified by destination. ">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7" title="Finishes copying the file started with g_file_copy_async(). ">copy_finish()</a> to get the result of the operation.</p>
<p>The function specified by <em>slot_progress</em> will be called just like in <a class="el" href="classGio_1_1File.html#a14f3429c51dd8af76d56c73e148321d2" title="Copies the file source to the location specified by destination. ">copy()</a>, however the callback will run in the main loop, not in the thread that is doing the I/O operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> </td></tr>
    <tr><td class="paramname">slot_progress</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">flags</td><td>Set of CopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a789c836e27f41e70ce8378c59b1fe5e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#a14f3429c51dd8af76d56c73e148321d2" title="Copies the file source to the location specified by destination. ">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7" title="Finishes copying the file started with g_file_copy_async(). ">copy_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">flags</td><td>Set of CopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af57515546dd8c73044d8226f4d73d7f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::copy_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies the file attributes from <em>source</em> to <em>destination</em>. </p>
<p>Normally only a subset of the file attributes are copied, those that are copies in a normal file copy operation (which for instance does not include e.g. mtime). However if <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901adeac3e173d6a8e8f5868be57ff0e0c6d" title="Copy all file metadata instead of just default set used for copy (see FileInfo). ">CopyFlags::ALL_METADATA</a> is specified in <em>flags</em>, then all the metadata that is possible to copy is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">destination</td><td>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to copy attributes to. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the attributes were copied successfully, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a47a2fb66ac1b20d831e8e6830543e5b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::copy_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies the file attributes from <em>source</em> to <em>destination</em>. </p>
<p>Normally only a subset of the file attributes are copied, those that are copies in a normal file copy operation (which for instance does not include e.g. mtime). However if <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901adeac3e173d6a8e8f5868be57ff0e0c6d" title="Copy all file metadata instead of just default set used for copy (see FileInfo). ">CopyFlags::ALL_METADATA</a> is specified in <em>flags</em>, then all the metadata that is possible to copy is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">destination</td><td>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to copy attributes to. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the attributes were copied successfully, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab16cd89db6cd5bb0c8dfdd4b635002d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::copy_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes copying the file started with g_file_copy_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>true</code> on success, <code>false</code> on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f98adc5cb353b29a5c93ec4731f50a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::create_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass <a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6a84c6d22cfdf3772e66b07bde636e0571" title="Create a file that can only be accessed by the current user. ">CreateFlags::PRIVATE</a> in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="a70511f41813ae029585c47f384356187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::create_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass <a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6a84c6d22cfdf3772e66b07bde636e0571" title="Create a file that can only be accessed by the current user. ">CreateFlags::PRIVATE</a> in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="aafd50f29955c820e7f92af372ff7451f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::create_file_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist. For more details, see <a class="el" href="classGio_1_1File.html#a2f98adc5cb353b29a5c93ec4731f50a9" title="Creates a new file and returns an output stream for writing to it. ">create_file()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a128001018104d45b158a27003c0c2638" title="Finishes an asynchronous file create operation started with g_file_create_async(). ">create_file_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a4c4fc0a4ce0935df2f9793ff4772a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::create_file_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist. For more details, see <a class="el" href="classGio_1_1File.html#a2f98adc5cb353b29a5c93ec4731f50a9" title="Creates a new file and returns an output stream for writing to it. ">create_file()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a128001018104d45b158a27003c0c2638" title="Finishes an asynchronous file create operation started with g_file_create_async(). ">create_file_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a128001018104d45b158a27003c0c2638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::create_file_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous file create operation started with g_file_create_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91d3de0fbbaf286244cd05630133d897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::create_file_readwrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass <a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6a84c6d22cfdf3772e66b07bde636e0571" title="Create a file that can only be accessed by the current user. ">CreateFlags::PRIVATE</a> in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e63296c462e888ee71e582d4db5c229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::create_file_readwrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass <a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6a84c6d22cfdf3772e66b07bde636e0571" title="Create a file that can only be accessed by the current user. ">CreateFlags::PRIVATE</a> in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="a8709e1a928621e837957e4690f284a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::create_file_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a91d3de0fbbaf286244cd05630133d897" title="Creates a new file and returns a stream for reading and writing to it. ">create_file_readwrite()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a339d08bf6cafea58d9d0b0675e741d25" title="Finishes an asynchronous file create operation started with g_file_create_readwrite_async(). ">create_file_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000059">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a81522da95f7b0dd3ed677d38e5b911e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::create_file_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a91d3de0fbbaf286244cd05630133d897" title="Creates a new file and returns a stream for reading and writing to it. ">create_file_readwrite()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a339d08bf6cafea58d9d0b0675e741d25" title="Finishes an asynchronous file create operation started with g_file_create_readwrite_async(). ">create_file_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000060">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a339d08bf6cafea58d9d0b0675e741d25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::create_file_readwrite_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous file create operation started with g_file_create_readwrite_async(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000028">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab311a1c606b3907865fc8aecd4691de8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_commandline_arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given argument from the command line. </p>
<p>The value of <em>arg</em> can be either a URI, an absolute path or a relative path resolved relative to the current working directory. This operation never fails, but the returned object might not support any I/O operation if arg points to a malformed path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">arg</td><td>A string containing a relative or absolute path. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a7532baa6ce71fe27cfd1e9bba91a3536"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_parse_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; </td>
          <td class="paramname"><em>parse_name</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b1a4553b226689d50b9525488223e25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given path. </p>
<p>This operation never fails, but the returned object might not support any I/O operation if path is malformed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">path</td><td>A string containing a relative or absolute path. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a412b6b55f37f69bd4fb8fbd24d4967be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_uri </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given URI. </p>
<p>This operation never fails, but the returned object might not support any I/O operation if path is malformed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">uri</td><td>A string containing a URI. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ea238062cdc317ae982ffae5c226c9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::dup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Duplicates a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> handle. </p>
<p>This operation does not duplicate the actual file or directory represented by the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>; see g_file_copy() if attempting to copy a file.</p>
<p>g_file_dup() is useful when a second handle is needed to the same underlying file, for use in a separate thread (<a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> is not thread-safe). For use within the same thread, use Glib::object_ref() to increment the existing object’s reference count.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> that is a duplicate of the given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5586b39859cc0c0a42a649de41c878da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). ">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7de2dbb85ff2e81f9c52424f1e1874d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). ">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a117264f558f4399324293ec55241eda5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51269c0ab9db0c07508b9fae8da08171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). ">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000070">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a4f1794967577da586a6701670e2dd12e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). ">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000071">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa9ced1df033473c1f89d3bb82fd88fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000072">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6a5124de7c55e9dc5e85ffcb9d3dd14f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::eject_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000033">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>file</em> was ejected successfully. <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7909a4bc1ab980ae9ebfbd995dea375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; Gio::File::enumerate_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the requested information about the files in a directory. </p>
<p>The result is a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> object that will give out <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> objects for all the files in the directory.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are availible as defines, like FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is not a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_DIRECTORY will be thrown. Other errors are possible too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bf7abcd4773dfeb827227289184a87b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; Gio::File::enumerate_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the requested information about the files in a directory. </p>
<p>The result is a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> object that will give out <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> objects for all the files in the directory.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are availible as defines, like FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is not a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_DIRECTORY will be thrown. Other errors are possible too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a945576cd1d0a78164705c26d54e7d1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::enumerate_children_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about the files in a directory. </p>
<p>The result is a GFileEnumerator object that will give out GFileInfo objects for all the files in the directory.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ab7909a4bc1ab980ae9ebfbd995dea375" title="Gets the requested information about the files in a directory. ">enumerate_children()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#acdabb80157c69c01479e0b89821c1299" title="Finishes an async enumerate children operation. ">enumerate_children_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d6c273e02e5c23bdb8df482cdbbb409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::enumerate_children_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about the files in a directory. </p>
<p>The result is a GFileEnumerator object that will give out GFileInfo objects for all the files in the directory.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ab7909a4bc1ab980ae9ebfbd995dea375" title="Gets the requested information about the files in a directory. ">enumerate_children()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#acdabb80157c69c01479e0b89821c1299" title="Finishes an async enumerate children operation. ">enumerate_children_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdabb80157c69c01479e0b89821c1299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; Gio::File::enumerate_children_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an async enumerate children operation. </p>
<p>See g_file_enumerate_children_async().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> or <code>nullptr</code> if an error occurred. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8877115c870ea8f58b03d1d3c01a83e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks equality of two given Files. </p>
<p>Note that two Files that differ can still refer to the same file on the filesystem due to various forms of filename aliasing.</p>
<p>This call does no blocking I/O. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">other</td><td>The other <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>* this</em> and <em>other</em> are equal. <code>false</code> if either is not a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a45b881926b8d58c49d3baa1f51f2ee5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; Gio::File::find_enclosing_mount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts. ">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </p>
<p>If the FileIface for <em>file</em> does not have a mount (e.g. possibly a remote share), a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with NOT_FOUND and <code>nullptr</code> will be returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts. ">Mount</a> where the <em>file</em> is located or <code>nullptr</code> on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6eb675267c7ea1c2a0d40e2e754d8333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; Gio::File::find_enclosing_mount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="A find_enclosing_mount() convenience overload. ">find_enclosing_mount()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a78c95d4fa47157f7757b686677dec018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::find_enclosing_mount_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously gets the mount for the file. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="A find_enclosing_mount() convenience overload. ">find_enclosing_mount()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ad4b415b02053e16a92cabb6a48368733" title="Finishes an asynchronous find mount request. ">find_enclosing_mount_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67458be57c5687e7469bc26e2594f4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::find_enclosing_mount_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously gets the mount for the file. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="A find_enclosing_mount() convenience overload. ">find_enclosing_mount()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ad4b415b02053e16a92cabb6a48368733" title="Finishes an asynchronous find mount request. ">find_enclosing_mount_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4b415b02053e16a92cabb6a48368733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; Gio::File::find_enclosing_mount_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous find mount request. </p>
<p>See g_file_find_enclosing_mount_async().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts. ">Mount</a> for given <em>file</em> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac731bed45bb7fcfd411eb69c49d3b883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_basename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the base name (the last component of the path) for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </p>
<p>If called for the top level of a system (such as the filesystem root or a uri like sftp://host/) it will return a single directory separator (and on Windows, possibly a drive letter).</p>
<p>The base name is a byte string (not UTF-8). It has no defined encoding or rules other than it may not contain zero bytes. If you want to use filenames in a user interface you should use the display name that you can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>String containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s base name, or <code>nullptr</code> if given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a53c533d6bbeaaadd1b5592cf1e5ef93c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets a child of <em>file</em> with basename equal to <em>name</em>. </p>
<p>Note that the file with that specific name might not exist, but you can still have a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> that points to it. You can use this for instance to create that file.</p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>String containing the child's basename. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to a child specified by <em>name</em>. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a479cfd632af30b29e125f904f809ed71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::get_child_for_display_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; </td>
          <td class="paramname"><em>display_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the child of <em>file</em> for a given <em>display_name</em> (i.e. a UTF-8 version of the name). </p>
<p>If this function fails, it returns <code>nullptr</code> and <em>error</em> will be set. This is very useful when constructing a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a new file and the user entered the filename in the user interface, for instance when you select a directory and type a filename in the file selector.</p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">display_name</td><td>String to a possible child. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to the specified child, or <code>nullptr</code> if the display name couldn't be converted. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af39bbd5013b2dd675911df322e12ff94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::get_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the parent directory for the <em>file</em>. </p>
<p>If the <em>file</em> represents the root directory of the file system, then <code>nullptr</code> will be returned.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> structure to the parent of the given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> or <code>nullptr</code> if there is no parent. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aea4a78163e3085a35cbaacde9a3a7628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Gio::File::get_parse_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the parse name of the <em>file</em>. </p>
<p>A parse name is a UTF-8 string that describes the file such that one can get the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> back using g_file_parse_name().</p>
<p>This is generally used to show the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> as a nice full-pathname kind of string in a user interface, like in a location entry.</p>
<p>For local files with names that can safely be converted to UTF-8 the pathname is used, otherwise the IRI is used (a form of URI that allows UTF-8 characters unescaped).</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s parse name. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b3edc7946b681b6db2cdcdad08d2b00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the local pathname for <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>, if one exists. </p>
<p>If non-<code>nullptr</code>, this is guaranteed to be an absolute, canonical path. It might contain symlinks.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>String containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s path, or <code>nullptr</code> if no such path exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a464248111fa2bc5df89c620354eb99bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_relative_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the path for <em>descendant</em> relative to <em>parent</em>. </p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">descendant</td><td>Input <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String with the relative path from <em>descendant</em> to <em>parent</em>, or <code>nullptr</code> if <em>descendant</em> doesn't have <em>parent</em> as prefix. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a1cbe348685c278bb7df93ee8018442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static GType Gio::File::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get the GType for this class, for use with the underlying GObject type system. </p>

</div>
</div>
<a class="anchor" id="a2d1313e4a4eb5de034b693ec1cc9fba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the URI for the <em>file</em>. </p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s URI. </dd></dl>

</div>
</div>
<a class="anchor" id="aeecec6962f955bd72ac5595be37db7a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_uri_scheme </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the URI scheme for a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </p>
<p>RFC 3986 decodes the scheme as:</p>
<p>[C example ellipted] Common schemes include "file", "http", "ftp", etc.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the URI scheme for the given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a96552cfbaf2e5fa3659a1568db8cca91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">GFile* Gio::File::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a class="anchor" id="a5437bc648d8b73451e8bee0bc902cfc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const GFile* Gio::File::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a class="anchor" id="ae0b0d16b849b2f92699ad57ee7c935d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::has_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks if <em>file</em> has a parent, and optionally, if it is <em>parent</em>. </p>
<p>If <em>parent</em> is <code>nullptr</code> then this function returns <code>true</code> if <em>file</em> has any parent at all. If <em>parent</em> is non-<code>nullptr</code> then <code>true</code> is only returned if <em>file</em> is an immediate child of <em>parent</em>.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000057">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">parent</td><td>The parent to check for, or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>file</em> is an immediate child of <em>parent</em> (or any parent in the case that <em>parent</em> is <code>nullptr</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="aa1daee0498c403e83ac509e6157edd1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::has_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks if the file has any parent at all. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the file is a child of any parent.</dd></dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000058">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a4c40ec88dfc4333f19e939d26a1e0332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::has_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks whether <em>file</em> has the prefix specified by <em>prefix</em>. </p>
<p>In other words, if the names of initial elements of <em>file's</em> pathname match <em>prefix</em>. Only full pathname elements are matched, so a path like /foo is not considered a prefix of /foobar, only of /foo/bar.</p>
<p>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> is not a prefix of itself. If you want to check for equality, use g_file_equal().</p>
<p>This call does no I/O, as it works purely on names. As such it can sometimes return <code>false</code> even if <em>file</em> is inside a <em>prefix</em> (from a filesystem point of view), because the prefix of <em>file</em> is an alias of <em>prefix</em>.</p>
<p>Virtual: prefix_matches</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">prefix</td><td>Input <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>file's</em> parent, grandparent, etc is <em>prefix</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d71529e5b51b9ff73914eaf90be0f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::has_uri_scheme </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>uri_scheme</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> has a given URI scheme. </p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">uri_scheme</td><td>A string containing a URI scheme. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s backend supports the given URI scheme, <code>false</code> if URI scheme is <code>nullptr</code>, not supported, or <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a0320bac72ecc9ced1f894f1af696856f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">guint Gio::File::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a hash value for a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </p>
<p>This call does no blocking I/O.</p>
<p>Virtual: hash</p>
<dl class="section return"><dt>Returns</dt><dd>0 if <em>file</em> is not a valid <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>, otherwise an integer that can be used as hash value for the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. This function is intended for easily hashing a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to add to a HashTable or similar data structure. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa3b910bc9f240d4ebd0efc70979f163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::is_native </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks to see if a file is native to the platform. </p>
<p>A native file is one expressed in the platform-native filename format, e.g. "C:\\Windows" or "/usr/bin/". This does not mean the file is local, as it might be on a locally mounted remote filesystem.</p>
<p>On some systems non-native files may be available using the native filesystem via a userspace filesystem (FUSE), in these cases this call will return <code>false</code>, but g_file_get_path() will still return a native path.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>file</em> is native. </dd></dl>

</div>
</div>
<a class="anchor" id="ac53be228d732b34e062a2a57814cdf15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp; </td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag_out</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> exception with CANCELLED will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada7c826a417f88b405244c8dc39ae1ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp; </td>
          <td class="paramname"><em>length</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> exception with CANCELLED will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000037">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a77f7781b0ba65bc4e7e613b80b353fd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">char *&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp; </td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag_out</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40f3ce7cf905144bac7218f9988d2d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">char *&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp; </td>
          <td class="paramname"><em>length</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000038">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad0e02ebffbaa13036e4636d2118f71a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::load_contents_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous load of the file's contents. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15" title="Loads the content of the file into memory, returning the size of the data. ">load_contents()</a> which is the synchronous version of this call.</p>
<p>When the load operation has completed, the <em>slot</em> will be called. To finish the operation, call <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457" title="Finishes an asynchronous load of the file's contents. ">load_contents_finish()</a> with the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a> provided to the <em>slot</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6af7ec98d5543bce07b917b65d7276ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::load_contents_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous load of the file's contents. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15" title="Loads the content of the file into memory, returning the size of the data. ">load_contents()</a> which is the synchronous version of this call.</p>
<p>When the load operation has completed, the <em>slot</em> will be called. To finish the operation, call <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457" title="Finishes an asynchronous load of the file's contents. ">load_contents_finish()</a> with the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a> provided to the <em>slot</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fd15277ab90bcc57db088be04cac457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::load_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp; </td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag_out</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous load of the <em>file's</em> contents. </p>
<p>The contents are placed in <em>contents</em>, and <em>length</em> is set to the size of the <em>contents</em> string. If <em>etag_out</em> is present, it will be set to the new entity tag for the <em>file</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="aee93c7e24e8391615f9f263584fb02bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::load_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp; </td>
          <td class="paramname"><em>length</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous load of the <em>file's</em> contents. </p>
<p>The contents are placed in <em>contents</em>, and <em>length</em> is set to the size of the <em>contents</em> string. If <em>etag_out</em> is present, it will be set to the new entity tag for the <em>file</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000039">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0e8d95fcdf7c2aa38f54e90a22d3ab6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::load_partial_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a5977e55c02f52afc78d9091cd3eab8ed">SlotReadMore</a>&amp; </td>
          <td class="paramname"><em>slot_read_more</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_async_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Reads the partial contents of a file. </p>
<p>The <em>slot_read_more</em> callback slot should be used to stop reading from the file when appropriate. This operation can be finished by <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async(). ">load_partial_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async(). ">load_partial_contents_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot_read_more</td><td>A callback to receive partial data and to specify whether further data should be read. </td></tr>
    <tr><td class="paramname">slot_async_ready</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a362d71932c0ba8797a8c47b77df1b6d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::load_partial_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a5977e55c02f52afc78d9091cd3eab8ed">SlotReadMore</a>&amp; </td>
          <td class="paramname"><em>slot_read_more</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_async_ready</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Reads the partial contents of a file. </p>
<p>The <em>slot_read_more</em> callback slot should be used to stop reading from the file when appropriate. This operation can be finished by <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async(). ">load_partial_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async(). ">load_partial_contents_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot_read_more</td><td>A callback to receive partial data and to specify whether further data should be read. </td></tr>
    <tr><td class="paramname">slot_async_ready</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b323508401d2e6fd2b3ad659f9bb5eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::load_partial_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp; </td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag_out</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file. ">load_partial_contents_async()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3a59c3831feeadea9bd0709617d2db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::load_partial_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp; </td>
          <td class="paramname"><em>length</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file. ">load_partial_contents_async()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000040">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="abfa05e23e95e77cabac289ab4e294a58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::make_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a directory. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on successful creation, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1e9aa5f58a76a8562fd00a13434f554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::make_directory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#aa1e9aa5f58a76a8562fd00a13434f554" title="A make_directory() convenience overload. ">make_directory()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a60cf2bf09420aec99766fa132d8ae0a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::make_directory_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously creates a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000014">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad7facff532924459948de0031396f9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::make_directory_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously creates a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000015">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0758295d049fe070dd235786775f777e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::make_directory_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous directory creation, started with g_file_make_directory_async(). </p>
<p>Virtual: make_directory_finish </p><dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000016">Since glibmm 2.38:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on successful directory creation, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb0b5b094339057b4b15952eb73e08d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::make_directory_with_parents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a directory and any parent directories that may not exist similar to 'mkdir -p'. </p>
<p>If the file system does not support creating directories, this function will fail, setting <em>error</em> to <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134ae71d1cb1e1e36c3653f1a4f176ec3459" title="Operation (or one of its parameters) not supported. ">Gio::Error::NOT_SUPPORTED</a>. If the directory itself already exists, this function will fail setting <em>error</em> to <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a78acf3772678a25c74fb94728f3c7697" title="File already exists. ">Gio::Error::EXISTS</a>, unlike the similar Glib::mkdir_with_parents().</p>
<p>For a local <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> the newly created directories will have the default (current) ownership and permissions of the current process.</p>
<p>If <em>cancellable</em> is not <code>nullptr</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a708f6079268ad1a626c248ace401b899" title="Operation was cancelled. ">Gio::Error::CANCELLED</a> will be returned.</p>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000020">Since glibmm 2.18:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all directories have been successfully created, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a874a487551d49ca62b31a3e5cf32fee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::make_directory_with_parents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6" title="A make_directory_with_parents() convenience overload. ">make_directory_with_parents()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a2709318e1f24dfd0cd498d28f5e1b8fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::make_symbolic_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>symlink_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a symbolic link. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">symlink_value</td><td>A string with the value of the new symlink. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on the creation of a new symlink, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a9a3d060c2675ff9ac1c758f0b2c024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::make_symbolic_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>symlink_value</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe" title="Creates a symbolic link. ">make_symbolic_link()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a7841ac4282c5ae77cb70e00863083154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::measure_disk_usage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#aa42b589db64b478d6074a80cf2099729">SlotFileMeasureProgress</a>&amp; </td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp; </td>
          <td class="paramname"><em>disk_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp; </td>
          <td class="paramname"><em>num_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp; </td>
          <td class="paramname"><em>num_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga970cea61c786fdcd5df56173fcc28201">MeasureFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#ga970cea61c786fdcd5df56173fcc28201ab50339a10e1de285ac99d4c3990b8693">MeasureFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Recursively measures the disk usage of the file. </p>
<p>This is essentially an analog of the '<code>du</code>' command, but it also reports the number of directories and non-directory files encountered (including things like symbolic links).</p>
<p>By default, errors are only reported against the toplevel file itself. Errors found while recursing are silently ignored, unless FILE_DISK_USAGE_REPORT_ALL_ERRORS is given in <em>flags</em>.</p>
<p>The returned size, <em>disk_usage</em>, is in bytes and should be formatted with g_format_size() in order to get something reasonable for showing in a user interface.</p>
<p><em>slot_progress</em> can be given to request periodic progress updates while scanning. See the documentation for SlotFileMeasureProgress for information about when and how the callback will be invoked.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">slot_progress</td><td>A SlotFileMeasureProgress to call periodically while scanning. </td></tr>
    <tr><td class="paramname">disk_usage</td><td>The number of bytes of disk space used. </td></tr>
    <tr><td class="paramname">num_dirs</td><td>The number of directories encountered. </td></tr>
    <tr><td class="paramname">num_files</td><td>The number of non-directories encountered. </td></tr>
    <tr><td class="paramname">flags</td><td>Set of MeasureFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a960bc67cd620a76454fe8cca6d742888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::measure_disk_usage_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#aa42b589db64b478d6074a80cf2099729">SlotFileMeasureProgress</a>&amp; </td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga970cea61c786fdcd5df56173fcc28201">MeasureFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#ga970cea61c786fdcd5df56173fcc28201ab50339a10e1de285ac99d4c3990b8693">MeasureFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Recursively measures the disk usage of the file. </p>
<p>This is the asynchronous version of <a class="el" href="classGio_1_1File.html#a7841ac4282c5ae77cb70e00863083154" title="Recursively measures the disk usage of the file. ">measure_disk_usage()</a>. See there for more information.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a5463283f6a20c51d4db7943190350d26" title="Collects the results from an earlier call to g_file_measure_disk_usage_async(). ">measure_disk_usage_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">slot_progress</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td class="paramname">flags</td><td>Set of MeasureFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5463283f6a20c51d4db7943190350d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::measure_disk_usage_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp; </td>
          <td class="paramname"><em>disk_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp; </td>
          <td class="paramname"><em>num_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp; </td>
          <td class="paramname"><em>num_files</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Collects the results from an earlier call to g_file_measure_disk_usage_async(). </p>
<p>See g_file_measure_disk_usage() for more information.</p>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000018">Since glibmm 2.38:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>The <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a> passed to your SlotAsyncReady. </td></tr>
    <tr><td class="paramname">disk_usage</td><td>The number of bytes of disk space used. </td></tr>
    <tr><td class="paramname">num_dirs</td><td>The number of directories encountered. </td></tr>
    <tr><td class="paramname">num_files</td><td>The number of non-directories encountered. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, with the out parameters set. <code>false</code> otherwise, with <em>error</em> set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad266a4cf02e3d0c3b094cdaf64098b47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000021">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab1513c6c380e086241ea61edc77ff0ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000022">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a44a980b923daf347f160797762ba3815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtains a directory monitor for the given file. </p>
<p>This may fail if directory monitoring is not supported.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2f57c06f9f9e6ac30a6b38180c1721f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_directory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtains a directory monitor for the given file. </p>
<p>This may fail if directory monitoring is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a4050ecb4732101b921605ada858ffbe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a514c5a0b152e61e2df4646f0db9c5e3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649ab50339a10e1de285ac99d4c3990b8693">FileMonitorFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="ace75bca82febb0a6a0ab95a7dcf6b1fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume(). ">mount_enclosing_volume_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acea9e8e1c493c30ae2dd8c1657137320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume(). ">mount_enclosing_volume_finish()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4238e62b6dffc31a67cb55bbd79be289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume(). ">mount_enclosing_volume_finish()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a374d9646586506e697a686846d5376a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd44b1b3467bcc474b345ff98b4aa6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::mount_enclosing_volume_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes a mount operation started by g_file_mount_enclosing_volume(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful. If an error has occurred, this function will return <code>false</code> and set <em>error</em> appropriately if present.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae12349a4620fa8936824eb894eaea08f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>Using <em>mount_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation. ">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03d0a86006debd8d517b5d3c9b4f32b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>Using <em>mount_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation. ">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0c85ada254ecee87b66bb3c3f51d663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation. ">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a975050008b7dea5bd7b758c8d99ef62b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga767692e81966d996f2fb22cb3b42f8f9">Mount::MountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#ga767692e81966d996f2fb22cb3b42f8f9ab50339a10e1de285ac99d4c3990b8693">Mount::MountFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae15d36a7969c55122b9f85a1690a46e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::mount_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes a mount operation. </p>
<p>See g_file_mount_mountable() for details.</p>
<p>Finish an asynchronous mount operation that was started with g_file_mount_mountable().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab73995a83642bbd0768157b1985128b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Tries to move the file or directory source to the location specified by destination. </p>
<p>If native move operations are supported then this is used, otherwise a copy and delete fallback is used. The native implementation may support moving directories (for instance on moves inside the same filesystem), but the fallback code does not.</p>
<p>If the flag <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is specified an already existing destination file is overwritten.</p>
<p>If the flag <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ac19ab3ff46eb1025b6944f450e95514e" title="Don't follow symlinks. ">CopyFlags::NOFOLLOW_SYMLINKS</a> is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The operation can be monitored via the <em>slot</em> callback. If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If G_CopyFlags::OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or <a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901a1038b7c5b38b3977c52e47d18cc741ee" title="Overwrite any existing files. ">CopyFlags::OVERWRITE</a> is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_RECURSE may be thrown (if the native move operation isn't available). </p>

</div>
</div>
<a class="anchor" id="a1012301ae63714d41b7ce49b57c94d23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a8ac8e3eb55eab168a75d934edcb2ab22">SlotFileProgress</a>&amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa50d1739a4e4a9b5645c8292f62cf26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; </td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gaebf684a8446aa31ea05305e4fbcda901">CopyFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gaebf684a8446aa31ea05305e4fbcda901ab50339a10e1de285ac99d4c3990b8693">CopyFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a128757d6cf7b152c82bb378a095003ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::open_readwrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Opens an existing file for reading and writing. </p>
<p>The result is a <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> that can be used to read and write the contents of the file.</p>
<p>If <em>cancellable</em> is not <code>nullptr</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a708f6079268ad1a626c248ace401b899" title="Operation was cancelled. ">Gio::Error::CANCELLED</a> will be returned.</p>
<p>If the file does not exist, the <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a3d51c29d886106dd037f4373c8799e1d" title="File not found. ">Gio::Error::NOT_FOUND</a> error will be returned. If the file is a directory, the <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4dabd1728e3bed146fb033f9f2419070" title="File is a directory. ">Gio::Error::IS_DIRECTORY</a> error will be returned. Other errors are possible too, and depend on what kind of filesystem the file is on. Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000029">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a456f74951f371ef5cca4282751efc66a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::open_readwrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a" title="A open_readwrite() convenience overload. ">open_readwrite()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a73d95a731716c7ffaa86c3af90afe8d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::open_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Opens an existing file for reading and writing. </p>
<p>The result is a <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> that can be used to read and write the contents of the file.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a" title="A open_readwrite() convenience overload. ">open_readwrite()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a5fdcb54ece686c870eac69c6f93aed75" title="Finishes an asynchronous file read operation started with g_file_open_readwrite_async(). ">open_readwrite_finish()</a> to get the result of the operation. If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000061">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a405af7082f531a7a39f3e7a453ab6267"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::open_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Opens an existing file for reading and writing. </p>
<p>The result is a <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> that can be used to read and write the contents of the file.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a" title="A open_readwrite() convenience overload. ">open_readwrite()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a5fdcb54ece686c870eac69c6f93aed75" title="Finishes an asynchronous file read operation started with g_file_open_readwrite_async(). ">open_readwrite_finish()</a> to get the result of the operation. If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000062">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5fdcb54ece686c870eac69c6f93aed75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::open_readwrite_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous file read operation started with g_file_open_readwrite_async(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000030">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4d8c21aa35f4703e0b46b04ae2f5b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGio_1_1File.html">File</a>&amp; Gio::File::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGio_1_1File.html">File</a>&amp;&amp; </td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e81dd0bab13e56ed98456f6a53591ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::poll_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Polls a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes a stop operation, see g_file_stop_mountable() for details. ">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000077">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2025339de9d7ed9b62300cad1a8e8fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::poll_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Polls a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes a stop operation, see g_file_stop_mountable() for details. ">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000078">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2da5ec13a4a32f229ca97cce8961e637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::poll_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes a poll operation. </p>
<p>See g_file_poll_mountable() for details.</p>
<p>Finish an asynchronous poll operation that was polled with g_file_poll_mountable().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000036">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a753546465735b25633b003333b66d05c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AppInfo.html">AppInfo</a>&gt; Gio::File::query_default_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> that is registered as the default application to handle the file specified by <em>file</em>. </p>
<p>If <em>cancellable</em> is not <code>nullptr</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a708f6079268ad1a626c248ace401b899" title="Operation was cancelled. ">Gio::Error::CANCELLED</a> will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> if the handle was found, <code>nullptr</code> if there were errors. When you are done with it, release it with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c0fd0ece2570b6704889df5ee43c283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AppInfo.html">AppInfo</a>&gt; Gio::File::query_default_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a0c0fd0ece2570b6704889df5ee43c283" title="A query_default_handler() convenience overload. ">query_default_handler()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ad8b0a75e0afdb5f6874ea5e304d55ea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::query_exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Utility function to check if a particular file exists. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685" title="Gets the requested information about the file. ">query_info()</a> and as such does blocking I/O.</p>
<p>Note that in many cases it is racy to first check for file existence and then execute something based on the outcome of that, because the file might have been created or removed in between the operations. The general approach to handling that is to not check, but just do the operation and handle the errors as they come.</p>
<p>As an example of race-free checking, take the case of reading a file, and if it doesn't exist, creating it. There are two racy versions: read it, and on error create it; and: check if it exists, if not create it. These can both result in two processes creating the file (with perhaps a partially written file as the result). The correct approach is to always try to create the file with File::create() which will either atomically create the file or fail with a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> exception with EXISTS.</p>
<p>However, in many cases an existence check is useful in a user interface, for instance to make a menu item sensitive/insensitive, so that you don't have to fool users that something is possible and then just show and error dialog. If you do this, you should make sure to also handle the errors that can happen due to races when you execute the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the file exists (and can be detected without error), <code>false</code> otherwise (or if cancelled). </dd></dl>

</div>
</div>
<a class="anchor" id="ab4cfdbf4fedacd364e40a72c71ab341a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::query_exists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8" title="Utility function to check if a particular file exists. ">query_exists()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="aa27c5b271c8f7667ce117cfc6118262e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> Gio::File::query_file_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Utility function to inspect the FileType of a file. </p>
<p>This is implemented using g_file_query_info() and as such does blocking I/O.</p>
<p>The primary use case of this method is to check if a file is a regular file, directory, or symlink.</p>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000018">Since glibmm 2.18:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags passed to g_file_query_info(). </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The FileType of the file and <a class="el" href="namespaceGio.html#ga7dcba95023d74c47bba3fd0a07f8824ca696b031073e74bf2cb98e5ef201d4aa3" title="File's type is unknown. ">Gio::FileType::UNKNOWN</a> if the file does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7910ee8c894c337644d54b793b8bb68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> Gio::File::query_file_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Utility function to inspect the FileType of a file. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685" title="Gets the requested information about the file. ">query_info()</a> and as such does blocking I/O.</p>
<p>The primary use case of this method is to check if a file is a regular file, directory, or symlink.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>a set of FileQueryInfoFlags passed to <a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685" title="Gets the requested information about the file. ">query_info()</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The FileType of the file, or FILE_TYPE_UNKNOWN if the file does not exist.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000019">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a40486bc2f0c8758ef8a705b6b8b57e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_filesystem_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685" title="Gets the requested information about the file. ">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. </p>
<p>For instance the amount of space availible and the type of the filesystem.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "fs:*" means all attributes in the fs namespace. The standard namespace for filesystem attributes is "fs". Common attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes availible), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac737012f8df97d90e2447d94d30b817d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_filesystem_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685" title="Gets the requested information about the file. ">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. </p>
<p>For instance the amount of space availible and the type of the filesystem.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "fs:*" means all attributes in the fs namespace. The standard namespace for filesystem attributes is "fs". Common attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes availible), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a39184ff9c9437259df4b9a9e2f283a0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::query_filesystem_info_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about the filesystem that the file is on. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57" title="Similar to query_info(), but obtains information about the filesystem the file is on...">query_filesystem_info()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#af986512a5b8cb8acf75afd7206b09be1" title="Finishes an asynchronous filesystem info query. ">query_filesystem_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4557ab16a50337f73d8a4649cf60fe70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::query_filesystem_info_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about the filesystem that the file is on. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57" title="Similar to query_info(), but obtains information about the filesystem the file is on...">query_filesystem_info()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#af986512a5b8cb8acf75afd7206b09be1" title="Finishes an asynchronous filesystem info query. ">query_filesystem_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af986512a5b8cb8acf75afd7206b09be1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_filesystem_info_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous filesystem info query. </p>
<p>See g_file_query_filesystem_info_async().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> for given <em>file</em> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2a2311094a75338f76d237b23774685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the requested information about the file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as the type or size of the file).</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if it's not possible to read a particular requested attribute from a file - it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are available as defines, like G_FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>For symlinks, normally the information about the target of the symlink is returned, rather than information about the symlink itself. However if you pass <a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ac19ab3ff46eb1025b6944f450e95514e" title="Don't follow symlinks. ">FileQueryInfoFlags::NOFOLLOW_SYMLINKS</a> in <em>flags</em> the information about the symlink itself will be returned. Also, for symlinks that point to non-existing files the information about the symlink itself will be returned.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> for the file, or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d65e1866fd98708495e94dc92a5ad94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the requested information about the file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as the type or size of the file).</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if it's not possible to read a particular requested attribute from a file - it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are available as defines, like G_FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>For symlinks, normally the information about the target of the symlink is returned, rather than information about the symlink itself. However if you pass <a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ac19ab3ff46eb1025b6944f450e95514e" title="Don't follow symlinks. ">FileQueryInfoFlags::NOFOLLOW_SYMLINKS</a> in <em>flags</em> the information about the symlink itself will be returned. Also, for symlinks that point to non-existing files the information about the symlink itself will be returned.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> for the file, or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa86c313589bb9679be7ce780642f17fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::query_info_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about specified file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685" title="Gets the requested information about the file. ">query_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a33eadfff77c93a77ecde795307728e52" title="Finishes an asynchronous file info query. ">query_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad24a796507738e0b263555314e074eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::query_info_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attributes</em> = <code>"*"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about specified file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac2a2311094a75338f76d237b23774685" title="Gets the requested information about the file. ">query_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a33eadfff77c93a77ecde795307728e52" title="Finishes an asynchronous file info query. ">query_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33eadfff77c93a77ecde795307728e52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_info_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous file info query. </p>
<p>See g_file_query_info_async().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> for given <em>file</em> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a543339b58cff6a7e5ddd840df0e69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_settable_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtain the list of settable attributes for the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes. ">FileAttributeInfoList</a> describing the settable attributes. When you are done with it, release it with g_file_attribute_info_list_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ae03d0652bcfbad2f47409b8f815bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_settable_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a1ae03d0652bcfbad2f47409b8f815bc4" title="A query_settable_attributes() convenience overload. ">query_settable_attributes()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="af5c7463b92e2887597486e7b195ca12f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_writable_namespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Obtain the list of attribute namespaces where new attributes can be created by a user. </p>
<p>An example of this is extended attributes (in the "xattr" namespace).</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes. ">FileAttributeInfoList</a> describing the writable namespaces. When you are done with it, release it with g_file_attribute_info_list_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0278acd7d09ed292359004defb742b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_writable_namespaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#aa0278acd7d09ed292359004defb742b0" title="A query_writable_namespaces() convenience overload. ">query_writable_namespaces()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a3ef959c7ad7096846f26eb8b282e3c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; Gio::File::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Opens a file for reading. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file. ">FileInputStream</a> that can be used to read the contents of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file. ">FileInputStream</a> or <code>nullptr</code> on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0395b3b0b8cec5dc1fd9953e52e5fbc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; Gio::File::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="A read() convenience overload. ">read()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a2826eed0b1e76c3771f6ad5f5b993991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::read_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously opens the file for reading. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="A read() convenience overload. ">read()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a3e71d2cd04c5c9c17a51fe8f1dc87c78" title="Finishes an asynchronous file read operation started with g_file_read_async(). ">read_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab451a182a647408e697c9115e66f6194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::read_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously opens the file for reading. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="A read() convenience overload. ">read()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a3e71d2cd04c5c9c17a51fe8f1dc87c78" title="Finishes an asynchronous file read operation started with g_file_read_async(). ">read_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e71d2cd04c5c9c17a51fe8f1dc87c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; Gio::File::read_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous file read operation started with g_file_read_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file. ">FileInputStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aded971b0cf84801f6684ad4bd5dc66c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Deletes a file. </p>
<p>If the file is a directory, it will only be deleted if it is empty. The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the file was deleted. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a14f34508dea523cbf889b7193e513ca4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a14f34508dea523cbf889b7193e513ca4" title="A remove() convenience overload. ">remove()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ad8499cabde1f50f1cbd5d928d63e73fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::remove_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously delete a file. </p>
<p>If the file is a directory, it will only be deleted if it is empty. This has the same semantics as g_unlink().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_34"><dt><b><a class="el" href="since_2_34.html#_since_2_34000054">Since glibmm 2.34:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a21198001203267126de9a24a8e91b0d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::remove_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously delete a file. </p>
<p>If the file is a directory, it will only be deleted if it is empty. This has the same semantics as g_unlink().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_34"><dt><b><a class="el" href="since_2_34.html#_since_2_34000055">Since glibmm 2.34:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0240c85a3ec46e107666e65da9b92c54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::remove_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes deleting a file started with g_file_delete_async(). </p>
<p>Virtual: delete_file_finish </p><dl class="since_2_34"><dt><b><a class="el" href="since_2_34.html#_since_2_34000056">Since glibmm 2.34:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the file was deleted. <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cfa97a67aa32a044e809a1a36dbcf23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. </p>
<p>This will try to replace the file in the safest way possible so that any errors during the writing will not affect an already existing copy of the file. For instance, for local files it may write to a temporary file and then atomically rename over the destination when the stream is closed.</p>
<p>By default files created are generally readable by everyone, but if you pass <a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6a84c6d22cfdf3772e66b07bde636e0571" title="Create a file that can only be accessed by the current user. ">CreateFlags::PRIVATE</a> in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If you pass in an etag value, then this value is compared to the current entity tag of the file, and if they differ a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown. This generally means that the file has been changed since you last read it. You can get the new etag from <a class="el" href="classGio_1_1FileOutputStream.html#a9b9189607f209d15a9fdd6be51c217cf" title="Gets the entity tag for the file when it has been written. ">FileOutputStream::get_etag()</a> after you've finished writing and closed the <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. When you load a new file you can use <a class="el" href="classGio_1_1FileInputStream.html#ae9cf87761484839f4ea53bc33064f189" title="Queries a file input stream the given attributes. ">FileInputStream::query_info()</a> to get the etag of the file.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the current file before overwriting it. If this fails aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANT_CREATE_BACKUP will be thrown. If you want to replace anyway, try again with <em>make_backup</em> set to false.</p>
<p>If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown, and if the file is some other form of non-regular file then aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_REGULAR_FILE will be thrown. Some file systems don't allow all file names, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a34817f33f9452734e31e251c496a0cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. </p>
<p>This will try to replace the file in the safest way possible so that any errors during the writing will not affect an already existing copy of the file. For instance, for local files it may write to a temporary file and then atomically rename over the destination when the stream is closed.</p>
<p>By default files created are generally readable by everyone, but if you pass <a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6a84c6d22cfdf3772e66b07bde636e0571" title="Create a file that can only be accessed by the current user. ">CreateFlags::PRIVATE</a> in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If you pass in an etag value, then this value is compared to the current entity tag of the file, and if they differ a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown. This generally means that the file has been changed since you last read it. You can get the new etag from <a class="el" href="classGio_1_1FileOutputStream.html#a9b9189607f209d15a9fdd6be51c217cf" title="Gets the entity tag for the file when it has been written. ">FileOutputStream::get_etag()</a> after you've finished writing and closed the <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. When you load a new file you can use <a class="el" href="classGio_1_1FileInputStream.html#ae9cf87761484839f4ea53bc33064f189" title="Queries a file input stream the given attributes. ">FileInputStream::query_info()</a> to get the etag of the file.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the current file before overwriting it. If this fails aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANT_CREATE_BACKUP will be thrown. If you want to replace anyway, try again with <em>make_backup</em> set to false.</p>
<p>If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown, and if the file is some other form of non-regular file then aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_REGULAR_FILE will be thrown. Some file systems don't allow all file names, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="add0f520fd16648261770799058427ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a2cfa97a67aa32a044e809a1a36dbcf23" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4e5fe0438c73500d3d6ec7d0d4b39daa" title="Finishes an asynchronous file replace operation started with g_file_replace_async(). ">replace_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91051b378a881531003702f1bac00977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a2cfa97a67aa32a044e809a1a36dbcf23" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4e5fe0438c73500d3d6ec7d0d4b39daa" title="Finishes an asynchronous file replace operation started with g_file_replace_async(). ">replace_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a9fbab61953ff81d79a9ec797b65ab1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const char * </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad11e49651118499dc9127c9a92a1965c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const char * </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49fff959d08c22b67004e13a0a6478ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em>. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae97189c7fd13c47ae6b77ec841eecc2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em>. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4355c5493713e32e2a4f1f2c9d923fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char * </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf7263f8473b92da80a4958c80c06e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char * </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09247b840eed74d688ac38dd46e2fd84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2d57cddf6becface248df2071ced2f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em>. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a350dbc9f509735ef912e1382fee5a50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents_bytes_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a> &gt;&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classGio_1_1File.html#aa4355c5493713e32e2a4f1f2c9d923fb" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a> but takes a Gio::Bytes input instead. </p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">contents</td><td>Bytes of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec12b716994baa347cecf868b3d8a3b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents_bytes_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a> &gt;&amp; </td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classGio_1_1File.html#aa4355c5493713e32e2a4f1f2c9d923fb" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a> but takes a Gio::Bytes input instead. </p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">contents</td><td>Bytes of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbe0e644bafcb88ce52b62de803167cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>new_etag</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous replace of the given file . </p>
<p>See <a class="el" href="classGio_1_1File.html#aa4355c5493713e32e2a4f1f2c9d923fb" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a>. Sets <em>new_etag</em> to the new entity tag for the document. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location of a new entity tag for the document. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0372ffd3f535f39b7e48c0483e4c1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous replace of the given file . </p>
<p>See <a class="el" href="classGio_1_1File.html#aa4355c5493713e32e2a4f1f2c9d923fb" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a>. Sets <em>new_etag</em> to the new entity tag for the document. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. for the document. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e5fe0438c73500d3d6ec7d0d4b39daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::replace_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous file replace operation started with g_file_replace_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>, or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab70699281c2125a80f54a9e142e9bcb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::replace_readwrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first. </p>
<p>If the file doesn't exist, it will be created.</p>
<p>For details about the behaviour, see <a class="el" href="classGio_1_1File.html#a2cfa97a67aa32a044e809a1a36dbcf23" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which does the same thing but returns an output stream only.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>.</dd></dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000063">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aebea81eca6fb8e180f1099bf642f8590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::replace_readwrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first. </p>
<p>If the file doesn't exist, it will be created.</p>
<p>For details about the behaviour, see <a class="el" href="classGio_1_1File.html#a2cfa97a67aa32a044e809a1a36dbcf23" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which does the same thing but returns an output stream only.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>.</dd></dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000064">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ae6ac74357f700e5e1c3f0b657057d1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ab70699281c2125a80f54a9e142e9bcb8" title="Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy ...">replace_readwrite()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a47d246b8ff87be3aaef635ac123d1e44" title="Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async(). ">replace_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000065">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a470284a6c81af59a169db65131202b1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::replace_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>etag</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gac86169fb62af16b3a5f0d275e80138a6">CreateFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1File.html#gac86169fb62af16b3a5f0d275e80138a6ab50339a10e1de285ac99d4c3990b8693">CreateFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ab70699281c2125a80f54a9e142e9bcb8" title="Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy ...">replace_readwrite()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a47d246b8ff87be3aaef635ac123d1e44" title="Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async(). ">replace_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of CreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000066">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a47d246b8ff87be3aaef635ac123d1e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::replace_readwrite_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000031">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a>, or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5e286d421c7236df39881f8ce0a4e03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::resolve_relative_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>relative_path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Resolves a relative path for <em>file</em> to an absolute path. </p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">relative_path</td><td>A given relative path string. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to the resolved path. <code>nullptr</code> if <em>relative_path</em> is <code>nullptr</code> or if <em>file</em> is invalid. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4f4373b8694c346a6908195f1f2644f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_byte_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail, returning <code>false</code>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A string containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09f574259052186e1b516bdcbe696710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_byte_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to value. ">set_attribute_byte_string()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ab0290ecba7b06ccf7736e2292708667e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_int32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint32 </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #gint32 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a707084a3c0a963548a21d17d0ec0b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_int32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint32 </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT32 to value. ">set_attribute_int32()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a111d73a2d003e5a5a4c5f86c7c3d2fb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64 </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint64 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4477b0063110951b26c855696ec34802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64 </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT64 to value. ">set_attribute_int64()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a37c39d7392c7324daa8e6d0597ced146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A string containing the attribute's value. </td></tr>
    <tr><td class="paramname">flags</td><td>FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8091652bb139428d2d8525aad84d2952"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a37c39d7392c7324daa8e6d0597ced146" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_STRING to value. ">set_attribute_string()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ae53b0f4d2214e050a290c8e35cac0f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_uint32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32 </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint32 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f769f140143f2e96a7587a10b6792a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_uint32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32 </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT32 to value. ">set_attribute_uint32()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a48638081fd7af772a39af59a558b17f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type G_FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint64 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4aa77b3580df88cfd3d7231af78155c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attribute_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 </td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7" title="Sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT64 to value. ">set_attribute_uint64()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a4ac22907ff66821a965828f59b115d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::set_attributes_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; </td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously sets the attributes of file with info. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a3dc7af767076fedea902b53be909d6b4" title="Tries to set all attributes in the FileInfo on the target values, not stopping on the first error...">set_attributes_from_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f5748b2f96bd7b47b122a463e193b4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::set_attributes_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; </td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously sets the attributes of file with info. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a3dc7af767076fedea902b53be909d6b4" title="Tries to set all attributes in the FileInfo on the target values, not stopping on the first error...">set_attributes_from_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd45aed7b975b6e204e67927de2817a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attributes_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; </td>
          <td class="paramname"><em>info</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3dc7af767076fedea902b53be909d6b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attributes_from_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; </td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> on the target values, not stopping on the first error. </p>
<p>If there is any error during this operation then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown. <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Error</a> on particular fields are flagged by setting the "status" field in the attribute value to FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect further errors.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there was any error, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a70dd6d0f7cbb3fd10ca6af2d7843423c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::set_attributes_from_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; </td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0ab50339a10e1de285ac99d4c3990b8693">FileQueryInfoFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> on the target values, not stopping on the first error. </p>
<p>If there is any error during this operation then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown. <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Error</a> on particular fields are flagged by setting the "status" field in the attribute value to FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect further errors.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a>. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there was any error, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dd75810d7c9ebafac398288f5afc018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::set_display_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; </td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Renames <em>file</em> to the specified display name. </p>
<p>The display name is converted from UTF8 to the correct encoding for the target filesystem if possible and the <em>file</em> is renamed to this.</p>
<p>If you want to implement a rename operation in the user interface the edit name (G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value in the rename widget, and then the result after editing should be passed to g_file_set_display_name().</p>
<p>On success the resulting converted filename is returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">display_name</td><td>A string. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> specifying what <em>file</em> was renamed to, or <code>nullptr</code> if there was an error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c2aa80b2d0ecdd22f0222c8ce42d177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::set_display_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; </td>
          <td class="paramname"><em>display_name</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name. ">set_display_name()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a0ac539d7758b9c0de809f8c83e0bba79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::set_display_name_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; </td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </p>
<p>For the synchronous version of this function, see <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name. ">set_display_name()</a>. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a2abb19573076b426434f7d8d2d5a0cdb" title="Finishes setting a display name started with g_file_set_display_name_async(). ">set_display_name_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">display_name</td><td>A string. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74d219d321dca3d438f876256dee82d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::set_display_name_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; </td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </p>
<p>For the synchronous version of this function, see <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name. ">set_display_name()</a>. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a2abb19573076b426434f7d8d2d5a0cdb" title="Finishes setting a display name started with g_file_set_display_name_async(). ">set_display_name_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">display_name</td><td>A string. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2abb19573076b426434f7d8d2d5a0cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::set_display_name_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes setting a display name started with g_file_set_display_name_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abdfa661cf123de9754dd5491cf388184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::start_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga15a94dcb93f1c5f40bdba5c0fdfb5198">Drive::StartFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Drive.html#ga15a94dcb93f1c5f40bdba5c0fdfb5198ab50339a10e1de285ac99d4c3990b8693">Drive::StartFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac" title="Finishes a start operation. ">start_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">start_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>, or <code>nullptr</code> to avoid user interaction. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000073">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a34624228e0a8039a6719af7049a61721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::start_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga15a94dcb93f1c5f40bdba5c0fdfb5198">Drive::StartFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Drive.html#ga15a94dcb93f1c5f40bdba5c0fdfb5198ab50339a10e1de285ac99d4c3990b8693">Drive::StartFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Starts a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac" title="Finishes a start operation. ">start_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">start_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>, or <code>nullptr</code> to avoid user interaction. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000074">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af11e51943807876180474b39d2e521ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::start_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes a start operation. </p>
<p>See g_file_start_mountable() for details.</p>
<p>Finish an asynchronous start operation that was started with g_file_start_mountable().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000034">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a173f85f0a892dbbdedf27a672e251a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::stop_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Stops a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes a stop operation, see g_file_stop_mountable() for details. ">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">start_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>, or <code>nullptr</code> to avoid user interaction. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000075">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa1a189f682759135c4df353193904231"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::stop_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Stops a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes a stop operation, see g_file_stop_mountable() for details. ">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">start_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>, or <code>nullptr</code> to avoid user interaction. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000076">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a195990af8825745d0d26147174824565"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::stop_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes a stop operation, see g_file_stop_mountable() for details. </p>
<p>Finish an asynchronous stop operation that was started with g_file_stop_mountable().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000035">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab666a9ec3922903646504f4080758522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::supports_thread_contexts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks if <em>file</em> supports [thread-default contexts][g-main-context-push-thread-default-context]. </p>
<p>If this returns <code>false</code>, you cannot perform asynchronous operations on <em>file</em> in a thread that has a thread-default context.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000041">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <em>file</em> supports thread-default contexts. </dd></dl>

</div>
</div>
<a class="anchor" id="acae5ecd962e832cf8d538877f4118da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::trash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sends <em>file</em> to the "Trashcan", if possible. </p>
<p>This is similar to deleting it, but the user can recover it before emptying the trashcan. Not all file systems support trashing, so this call can throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_SUPPORTED.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on successful trash, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1925736f9af338eaf9942468b4d6d65e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::trash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a1925736f9af338eaf9942468b4d6d65e" title="A trash() convenience overload. ">trash()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="afab15e7d88376d144253bce7bfba2730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::trash_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously sends the file to the Trash location, if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000011">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5cb6f01422a66c141ba721fc8790f10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::trash_async </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Asynchronously sends the file to the Trash location, if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000012">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7ee78bd712cb24661335cee8e3d29344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::trash_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an asynchronous file trashing operation, started with g_file_trash_async(). </p>
<p>Virtual: trash_finish </p><dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000013">Since glibmm 2.38:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on successful trash, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad59907320badc6d075f81d867a5b45c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. ">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5fbc336d4236169ada5106bd4cf6cc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. ">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50d5cad0c2b6ec64a264b4b3c1535c6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a345e1e3328a523516fe5799e4ac3d9da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. ">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000067">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af2e42dca3b08784ca01c805fdc57f386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const SlotAsyncReady &amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. ">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000068">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2b2907e2be71adb781363e211095ab50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; </td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gabb64d2cea7be6f77163eff7d1a101643">Mount::UnmountFlags</a> </td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classGio_1_1Mount.html#gabb64d2cea7be6f77163eff7d1a101643ab50339a10e1de285ac99d4c3990b8693">Mount::UnmountFlags::NONE</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000069">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a51458cf04ad25e4a784a3ebcb906155d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::File::unmount_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; </td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. </p>
<p>Finish an asynchronous unmount operation that was started with g_file_unmount_mountable_with_operation().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000032">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a69670cdc7cf63783d6f9370dcbd7cc3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">Gio::File</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GFile * </td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>take_copy</em> = <code>false</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div></div></div><div id="footer_art" class="default"> </div></div><div class="clearfix"></div><div id="footer_grass">   </div><div id="footer"><div class="container_12"><div class="links grid_9"><div class="menu-footer-1-container"><ul id="menu-footer-1" class="menu"><li id="menu-item-88" class="menu-item menu-item-type-custom menu-item-home menu-item-88"><a href="https://www.gnome.org/">The GNOME Project</a><ul class="sub-menu"><li id="menu-item-89" class="menu-item menu-item-type-post_type menu-item-89"><a href="https://www.gnome.org/about/">About Us</a></li><li id="menu-item-90" class="menu-item menu-item-type-custom menu-item-90"><a href="https://www.gnome.org/get-involved/">Get Involved</a></li><li id="menu-item-91" class="menu-item menu-item-type-custom menu-item-91"><a href="https://www.gnome.org/teams/">Teams</a></li><li id="menu-item-92" class="menu-item menu-item-type-custom menu-item-92"><a href="https://foundation.gnome.org">The GNOME Foundation</a></li><li><a href="https://www.gnome.org/support-gnome/">Support GNOME</a></li><li><a href="https://www.gnome.org/contact/">Contact</a></li></ul></li></ul></div><div class="menu-footer-2-container"><ul id="menu-footer-2" class="menu"><li id="menu-item-99" class="menu-item menu-item-type-post_type current-menu-item page_item page-item-20 current_page_item menu-item-99"><a href="classGio_1_1File.html#">Resources</a><ul class="sub-menu"><li><a href="https://help.gnome.org">Documentation</a></li><li><a href="https://wiki.gnome.org">Wiki</a></li><li><a href="https://mail.gnome.org/mailman/listinfo">Mailing Lists</a></li><li><a href="https://wiki.gnome.org/GnomeIrcChannels">IRC Channels</a></li><li><a href="https://gitlab.gnome.org/">Bug Tracker</a></li><li><a href="https://gitlab.gnome.org/">Development Code</a></li><li><a href="https://wiki.gnome.org/Jhbuild">Build Tool</a></li></ul></li></ul></div><div class="menu-footer-4-container"><ul id="menu-footer-4" class="menu"><li id="menu-item-104" class="menu-item menu-item-type-custom menu-item-104"><a href="http://www.gnome.org/news/">News</a><ul class="sub-menu"><li><a href="https://www.gnome.org/start/stable">Latest Release</a></li><li><a href="https://planet.gnome.org">Planet GNOME</a></li><li><a href="https://news.gnome.org">Development News</a></li><li><a href="https://twitter.com/gnome">Twitter</a></li></ul></li></ul></div></div><div class="links grid_3 right"><div><ul class="menu available_languages"><li><strong>This website is available in many languages</strong><ul class="sub-menu"><li><a href="../../languages.html" title="Switching Language">Switch Language</a></li></ul></li></ul><script type="text/javascript" src="../../js/language.js"></script></div></div><div id="footnotes" class="grid_9">
                Copyright © 2005‒2014 <strong class="gnome_logo">The GNOME Project</strong><br></br><small>Optimised for standards. Hosted by <a href="http://redhat.com">Red Hat</a>.</small></div><div class="clear"></div></div></div><script type="text/javascript">
$(document).ready(function() {
    // Get browser
    $.each($.browser, function(i) {
        $('body').addClass(i);
        return false;
    });

    // Get OS and add it as class to body tag, this then allows forcing some
    // customisation in the CSS rules.
    var match = navigator.userAgent.toLowerCase().match(/(win|mac|linux)/);
    if (match) {
        $('body').addClass(match[0]);
    }
});
</script><script type="text/javascript">
      var _paq = _paq || [];
      _paq.push(['disableCookies']);
      _paq.push(["trackPageView"]);
      _paq.push(["enableLinkTracking"]);

      (function() {
        var u=(("https:" == document.location.protocol) ? "https" : "http") + "://webstats.gnome.org/";
        _paq.push(["setTrackerUrl", u+"piwik.php"]);
        _paq.push(["setSiteId", "6"]);
        var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";
        g.defer=true; g.async=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);
      })();
    </script></body></html>
