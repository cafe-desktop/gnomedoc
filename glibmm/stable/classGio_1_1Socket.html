<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8"></meta><link rel="stylesheet" href="../../skin/doxygen.css" type="text/css"></link><link rel="stylesheet" type="text/css" media="all" href="https://static.gnome.org/css/grass-theme-style.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/lgo2010.css"></link><link rel="icon" type="image/png" href="../../skin/gnome-16.png"></link><link rel="SHORTCUT ICON" type="image/png" href="../../skin/gnome-16.png"></link><link rel="search" type="application/opensearchdescription+xml" href="../../gnome-library-search.xml" title="GNOME Library Search"></link><link rel="stylesheet" type="text/css" href="../../skin/jquery.autocomplete.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script><title>glibmm: Gio::Socket Class Reference</title><link rel="stylesheet" type="text/css" media="all" href="../../skin/jquery.autocomplete.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/960_24_col.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="https://developer-old.gnome.org/js/jquery.jcarousel.min.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script></head><body><div id="accessibility_access"><ul><li><a href="classGio_1_1Socket.html#container">Go to page content</a></li><li><a href="classGio_1_1Socket.html#top_bar">Go to main menu</a></li><li><a href="classGio_1_1Socket.html#s" onclick="$('#s').focus(); return false;">Go to the search field</a></li></ul></div><div id="global_domain_bar"><div class="maxwidth"><div class="tab"><a class="root" href="https://www.gnome.org/">GNOME.org</a></div></div></div><div id="header" class="container_12"><div id="logo" class="grid_3"><a title="Go to home page" href="../../index.html"><img alt="GNOME: The Free Software Desktop Project" src="../../skin/gnome-logo-devcenter.png"></img></a></div><div id="top_bar" class="grid_9"><div class="left"><div class="menu-globalnav-container"><ul id="menu-globalnav" class="menu"><li class="menu-item menu-item-type-post_type menu-item-6"><a href="../../about/index.html">About</a></li><li class="menu-item menu-item-type-post_type menu-item-23"><a href="https://help.gnome.org/users/">Users</a></li><li class="menu-item menu-item-type-post_type menu-item-40"><a href="https://help.gnome.org/admin/">Administrators</a></li><li class="current-menu-item"><a href="https://developer.gnome.org/">Developers</a></li></ul></div></div><div class="right"><form role="search" method="get" id="searchform" action="https://developer-old.gnome.org/symbols/"><div><label class="hidden" for="q">Search:
                        </label><input type="text" value="" name="q" id="s" placeholder="Search"></input></div></form><script type="text/javascript">
$('#s').autocomplete('/symbols/lookup/',
        { minChars:3, matchSubset:1, matchContains:1, cacheLength:10,
          selectOnly:1, rowsLimit:25 });
              </script></div></div></div><div class="clearfix"></div><div id="container" class="gtkmm"><div class="content"><h1 class="lgotitle">glibmm: Gio::Socket Class Reference</h1><div id="content"><div class="tabs" id="navrow1">
    <ul class="tablist">
      <li><a href="index.html"><span>Main Page</span></a></li>
      <li><a href="pages.html"><span>Related Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div><div class="contents">

<p>Low-level socket object.  
 <a href="classGio_1_1Socket.html#details">More...</a></p>

<p><code>#include &lt;giomm/socket.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::Socket:</div>
<div class="dyncontent">
<div class="center"><img alt="Inheritance graph" border="0" src="classGio_1_1Socket__inherit__graph.png" usemap="#Gio_1_1Socket_inherit__map"></img></div>
<map id="Gio_1_1Socket_inherit__map" name="Gio_1_1Socket_inherit__map">
<area alt="" coords="5,304,104,331" href="classGlib_1_1Object.html" id="node2" shape="rect" title="Glib::Object"></area>
<area alt="" coords="51,155,181,181" href="classGlib_1_1ObjectBase.html" id="node3" shape="rect" title="Glib::ObjectBase is a common base class for Objects and Interfaces. "></area>
<area alt="" coords="113,229,228,256" href="classGlib_1_1Interface.html" id="node7" shape="rect" title="Glib::Interface"></area>
<area alt="" coords="58,80,174,107" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html" id="node4" shape="rect" title="sigc::trackable"></area>
<area alt="" coords="57,5,175,32" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html" id="node5" shape="rect" title="sigc::notifiable"></area>
<area alt="" coords="128,304,229,331" href="classGio_1_1Initable.html" id="node6" shape="rect" title="Failable object initialization interface. "></area>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="inherit_header pub_types_classGlib_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classGlib_1_1Object')"><img alt="-" src="closed.png"></img> Public Types inherited from <a class="el" href="classGlib_1_1Object.html">Glib::Object</a></td></tr>
<tr class="memitem:a969836f7bf4fec78eb50a1d790304d82 inherit pub_types_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a969836f7bf4fec78eb50a1d790304d82">DestroyNotify</a> = void(*)(gpointer data)</td></tr>
<tr class="separator:a969836f7bf4fec78eb50a1d790304d82 inherit pub_types_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_types_structsigc_1_1trackable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structsigc_1_1trackable')"><img alt="-" src="closed.png"></img> Public Types inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a></td></tr>
<tr class="memitem:a1721dff57885c3ff2bc409538ceb8097 inherit pub_types_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top">typedef internal::func_destroy_notify </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a1721dff57885c3ff2bc409538ceb8097">func_destroy_notify</a></td></tr>
<tr class="separator:a1721dff57885c3ff2bc409538ceb8097 inherit pub_types_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_types_structsigc_1_1notifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structsigc_1_1notifiable')"><img alt="-" src="closed.png"></img> Public Types inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html">sigc::notifiable</a></td></tr>
<tr class="memitem:a71455cae4b10ff1277e68a1729e1b8c4 inherit pub_types_structsigc_1_1notifiable"><td align="right" class="memItemLeft" valign="top">typedef internal::func_destroy_notify </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html#a71455cae4b10ff1277e68a1729e1b8c4">func_destroy_notify</a></td></tr>
<tr class="separator:a71455cae4b10ff1277e68a1729e1b8c4 inherit pub_types_structsigc_1_1notifiable"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a87a644ad422b1b809acad72e38829fb1"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a87a644ad422b1b809acad72e38829fb1">Socket</a> (<a class="el" href="classGio_1_1Socket.html">Socket</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a87a644ad422b1b809acad72e38829fb1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab713c206146db8f718377e4cd3609c27"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGio_1_1Socket.html">Socket</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ab713c206146db8f718377e4cd3609c27">operator=</a> (<a class="el" href="classGio_1_1Socket.html">Socket</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:ab713c206146db8f718377e4cd3609c27"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a41175831b614d34f1addca9e14406156"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a41175831b614d34f1addca9e14406156">~Socket</a> () noexcept override</td></tr>
<tr class="separator:a41175831b614d34f1addca9e14406156"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d51f7bcd83450331d7261898e9007d6"><td align="right" class="memItemLeft" valign="top">GSocket* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a1d51f7bcd83450331d7261898e9007d6">gobj</a> ()</td></tr>
<tr class="memdesc:a1d51f7bcd83450331d7261898e9007d6"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1Socket.html#a1d51f7bcd83450331d7261898e9007d6">More...</a><br></br></td></tr>
<tr class="separator:a1d51f7bcd83450331d7261898e9007d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a51c7fa832ce1c984a7bbceb4d7ba93a8"><td align="right" class="memItemLeft" valign="top">const GSocket* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a51c7fa832ce1c984a7bbceb4d7ba93a8">gobj</a> () const </td></tr>
<tr class="memdesc:a51c7fa832ce1c984a7bbceb4d7ba93a8"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1Socket.html#a51c7fa832ce1c984a7bbceb4d7ba93a8">More...</a><br></br></td></tr>
<tr class="separator:a51c7fa832ce1c984a7bbceb4d7ba93a8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae2fe06b1a579c40b596933da0ded4e37"><td align="right" class="memItemLeft" valign="top">GSocket* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae2fe06b1a579c40b596933da0ded4e37">gobj_copy</a> ()</td></tr>
<tr class="memdesc:ae2fe06b1a579c40b596933da0ded4e37"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="classGio_1_1Socket.html#ae2fe06b1a579c40b596933da0ded4e37">More...</a><br></br></td></tr>
<tr class="separator:ae2fe06b1a579c40b596933da0ded4e37"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a16044bba5924c183cff90f0a4cf47394"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a16044bba5924c183cff90f0a4cf47394">bind</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, bool allow_reuse)</td></tr>
<tr class="memdesc:a16044bba5924c183cff90f0a4cf47394"><td class="mdescLeft"> </td><td class="mdescRight">When a socket is created it is attached to an address family, but it doesn't have an address in this family.  <a href="classGio_1_1Socket.html#a16044bba5924c183cff90f0a4cf47394">More...</a><br></br></td></tr>
<tr class="separator:a16044bba5924c183cff90f0a4cf47394"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af16eed3fd42f3769b5e608f96db214fd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af16eed3fd42f3769b5e608f96db214fd">listen</a> ()</td></tr>
<tr class="memdesc:af16eed3fd42f3769b5e608f96db214fd"><td class="mdescLeft"> </td><td class="mdescRight">Marks the socket as a server socket - a socket that is used to accept incoming requests using <a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888" title="A accept() convenience overload. ">Socket::accept()</a>.  <a href="classGio_1_1Socket.html#af16eed3fd42f3769b5e608f96db214fd">More...</a><br></br></td></tr>
<tr class="separator:af16eed3fd42f3769b5e608f96db214fd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a137ae34a8f211eaed11f9a58ca6b3f5e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a137ae34a8f211eaed11f9a58ca6b3f5e">accept</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a137ae34a8f211eaed11f9a58ca6b3f5e"><td class="mdescLeft"> </td><td class="mdescRight">Accept incoming connections on a connection-based socket.  <a href="classGio_1_1Socket.html#a137ae34a8f211eaed11f9a58ca6b3f5e">More...</a><br></br></td></tr>
<tr class="separator:a137ae34a8f211eaed11f9a58ca6b3f5e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b6c036db4e484e6b7f0419962254888"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888">accept</a> ()</td></tr>
<tr class="memdesc:a4b6c036db4e484e6b7f0419962254888"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888" title="A accept() convenience overload. ">accept()</a> convenience overload.  <a href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888">More...</a><br></br></td></tr>
<tr class="separator:a4b6c036db4e484e6b7f0419962254888"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9ab220f5714a6116d35e846b00f4ad23"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23">connect</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a9ab220f5714a6116d35e846b00f4ad23"><td class="mdescLeft"> </td><td class="mdescRight">Connect the socket to the specified remote address.  <a href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23">More...</a><br></br></td></tr>
<tr class="separator:a9ab220f5714a6116d35e846b00f4ad23"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0828763fe472d46aed833fad30af1c0b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0828763fe472d46aed833fad30af1c0b">connect</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address)</td></tr>
<tr class="memdesc:a0828763fe472d46aed833fad30af1c0b"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23" title="Connect the socket to the specified remote address. ">connect()</a> convenience overload.  <a href="classGio_1_1Socket.html#a0828763fe472d46aed833fad30af1c0b">More...</a><br></br></td></tr>
<tr class="separator:a0828763fe472d46aed833fad30af1c0b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06b68dc0948e6dfa158487c314f9a521"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a06b68dc0948e6dfa158487c314f9a521">check_connect_result</a> ()</td></tr>
<tr class="memdesc:a06b68dc0948e6dfa158487c314f9a521"><td class="mdescLeft"> </td><td class="mdescRight">Checks and resets the pending connect error for the socket.  <a href="classGio_1_1Socket.html#a06b68dc0948e6dfa158487c314f9a521">More...</a><br></br></td></tr>
<tr class="separator:a06b68dc0948e6dfa158487c314f9a521"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a742403f4d076ba9050a435d95fea5d1c"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c">receive</a> (char* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a742403f4d076ba9050a435d95fea5d1c"><td class="mdescLeft"> </td><td class="mdescRight">Receive data (up to <em>size</em> bytes) from a socket.  <a href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c">More...</a><br></br></td></tr>
<tr class="separator:a742403f4d076ba9050a435d95fea5d1c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a73463b7677ffdfddaced49bdf170b4b6"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a73463b7677ffdfddaced49bdf170b4b6">receive</a> (char* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>)</td></tr>
<tr class="memdesc:a73463b7677ffdfddaced49bdf170b4b6"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c" title="Receive data (up to size bytes) from a socket. ">receive()</a> convenience overload.  <a href="classGio_1_1Socket.html#a73463b7677ffdfddaced49bdf170b4b6">More...</a><br></br></td></tr>
<tr class="separator:a73463b7677ffdfddaced49bdf170b4b6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d2d4382139553881ae139920e8db93e"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4d2d4382139553881ae139920e8db93e">receive_from</a> (<a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, char* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="separator:a4d2d4382139553881ae139920e8db93e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a056fd2c3609971d5befcf2b4ccf51aa3"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a056fd2c3609971d5befcf2b4ccf51aa3">receive_from</a> (<a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, char* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>)</td></tr>
<tr class="separator:a056fd2c3609971d5befcf2b4ccf51aa3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc5c3145109841e0406150ad0b7f547c"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c">send</a> (const gchar* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:adc5c3145109841e0406150ad0b7f547c"><td class="mdescLeft"> </td><td class="mdescRight">Tries to send <em>size</em> bytes from <em>buffer</em> on the socket.  <a href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c">More...</a><br></br></td></tr>
<tr class="separator:adc5c3145109841e0406150ad0b7f547c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a986efa2a33528ce5aba0d7c6a7be1b65"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a986efa2a33528ce5aba0d7c6a7be1b65">send</a> (const gchar* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>)</td></tr>
<tr class="memdesc:a986efa2a33528ce5aba0d7c6a7be1b65"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c" title="Tries to send size bytes from buffer on the socket. ">send()</a> convenience overload.  <a href="classGio_1_1Socket.html#a986efa2a33528ce5aba0d7c6a7be1b65">More...</a><br></br></td></tr>
<tr class="separator:a986efa2a33528ce5aba0d7c6a7be1b65"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8b2d4ff883535e696b6cdaacd730f729"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729">send_to</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const char* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a8b2d4ff883535e696b6cdaacd730f729"><td class="mdescLeft"> </td><td class="mdescRight">Tries to send <em>size</em> bytes from <em>buffer</em> to <em>address</em>.  <a href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729">More...</a><br></br></td></tr>
<tr class="separator:a8b2d4ff883535e696b6cdaacd730f729"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a929c8c4e0c10a39d65358853e94d9c4f"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a929c8c4e0c10a39d65358853e94d9c4f">send_to</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const char* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>)</td></tr>
<tr class="memdesc:a929c8c4e0c10a39d65358853e94d9c4f"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729" title="Tries to send size bytes from buffer to address. ">send_to()</a> convenience overload.  <a href="classGio_1_1Socket.html#a929c8c4e0c10a39d65358853e94d9c4f">More...</a><br></br></td></tr>
<tr class="separator:a929c8c4e0c10a39d65358853e94d9c4f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab30d39b9e73fef6401c76d1d4edc118"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aab30d39b9e73fef6401c76d1d4edc118">close</a> ()</td></tr>
<tr class="memdesc:aab30d39b9e73fef6401c76d1d4edc118"><td class="mdescLeft"> </td><td class="mdescRight">Closes the socket, shutting down any active connection.  <a href="classGio_1_1Socket.html#aab30d39b9e73fef6401c76d1d4edc118">More...</a><br></br></td></tr>
<tr class="separator:aab30d39b9e73fef6401c76d1d4edc118"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7ac925f7e6592ad4a96afe0f75411a96"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a7ac925f7e6592ad4a96afe0f75411a96">is_closed</a> ()</td></tr>
<tr class="memdesc:a7ac925f7e6592ad4a96afe0f75411a96"><td class="mdescLeft"> </td><td class="mdescRight">Checks whether a socket is closed.  <a href="classGio_1_1Socket.html#a7ac925f7e6592ad4a96afe0f75411a96">More...</a><br></br></td></tr>
<tr class="separator:a7ac925f7e6592ad4a96afe0f75411a96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae610eb0842fe6fd32a8a1798fb0e305d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketSource.html">SocketSource</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae610eb0842fe6fd32a8a1798fb0e305d">create_source</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable={})</td></tr>
<tr class="memdesc:ae610eb0842fe6fd32a8a1798fb0e305d"><td class="mdescLeft"> </td><td class="mdescRight">Creates a <a class="el" href="classGio_1_1SocketSource.html" title="An event source that can monitor a Gio::Socket. ">SocketSource</a> that can be attached to a <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">Glib::MainContext</a> to monitor for the availability of the specified <em>condition</em> on the socket.  <a href="classGio_1_1Socket.html#ae610eb0842fe6fd32a8a1798fb0e305d">More...</a><br></br></td></tr>
<tr class="separator:ae610eb0842fe6fd32a8a1798fb0e305d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4f685bc040e9e10abe093deec0719fd7"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4f685bc040e9e10abe093deec0719fd7">shutdown</a> (bool shutdown_read, bool shutdown_write)</td></tr>
<tr class="memdesc:a4f685bc040e9e10abe093deec0719fd7"><td class="mdescLeft"> </td><td class="mdescRight">Shut down part or all of a full-duplex connection.  <a href="classGio_1_1Socket.html#a4f685bc040e9e10abe093deec0719fd7">More...</a><br></br></td></tr>
<tr class="separator:a4f685bc040e9e10abe093deec0719fd7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aea9561511b77e652271705fbfdb2f8f2"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aea9561511b77e652271705fbfdb2f8f2">is_connected</a> ()</td></tr>
<tr class="memdesc:aea9561511b77e652271705fbfdb2f8f2"><td class="mdescLeft"> </td><td class="mdescRight">Check whether the socket is connected.  <a href="classGio_1_1Socket.html#aea9561511b77e652271705fbfdb2f8f2">More...</a><br></br></td></tr>
<tr class="separator:aea9561511b77e652271705fbfdb2f8f2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3cd0af5978112d1c8e2e68e51c9b99c5"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a3cd0af5978112d1c8e2e68e51c9b99c5">get_available_bytes</a> () const </td></tr>
<tr class="memdesc:a3cd0af5978112d1c8e2e68e51c9b99c5"><td class="mdescLeft"> </td><td class="mdescRight">Get the amount of data pending in the OS input buffer, without blocking.  <a href="classGio_1_1Socket.html#a3cd0af5978112d1c8e2e68e51c9b99c5">More...</a><br></br></td></tr>
<tr class="separator:a3cd0af5978112d1c8e2e68e51c9b99c5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a86fdc5d814fd61abab15ec03c7da20ec"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec">condition_check</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition)</td></tr>
<tr class="memdesc:a86fdc5d814fd61abab15ec03c7da20ec"><td class="mdescLeft"> </td><td class="mdescRight">Checks on the readiness of <em>socket</em> to perform operations.  <a href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec">More...</a><br></br></td></tr>
<tr class="separator:a86fdc5d814fd61abab15ec03c7da20ec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaae28fa63035c05396064f5f4bb4fc36"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36">condition_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:aaae28fa63035c05396064f5f4bb4fc36"><td class="mdescLeft"> </td><td class="mdescRight">Waits for <em>condition</em> to become true on <em>socket</em>.  <a href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36">More...</a><br></br></td></tr>
<tr class="separator:aaae28fa63035c05396064f5f4bb4fc36"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9ae420715a2050cc09112f178bae88ba"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9ae420715a2050cc09112f178bae88ba">condition_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition)</td></tr>
<tr class="memdesc:a9ae420715a2050cc09112f178bae88ba"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36" title="Waits for condition to become true on socket. ">condition_wait()</a> convenience overload.  <a href="classGio_1_1Socket.html#a9ae420715a2050cc09112f178bae88ba">More...</a><br></br></td></tr>
<tr class="separator:a9ae420715a2050cc09112f178bae88ba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:addb32e1cc859b9689bf10169dfd70a9c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#addb32e1cc859b9689bf10169dfd70a9c">condition_timed_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition, gint64 timeout, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:addb32e1cc859b9689bf10169dfd70a9c"><td class="mdescLeft"> </td><td class="mdescRight">Waits for up to <em>timeout</em> microseconds for <em>condition</em> to become true on <em>socket</em>.  <a href="classGio_1_1Socket.html#addb32e1cc859b9689bf10169dfd70a9c">More...</a><br></br></td></tr>
<tr class="separator:addb32e1cc859b9689bf10169dfd70a9c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71a3736a74c730c76e7c9a1670c3fbdd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a71a3736a74c730c76e7c9a1670c3fbdd">condition_timed_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition, gint64 timeout)</td></tr>
<tr class="memdesc:a71a3736a74c730c76e7c9a1670c3fbdd"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#addb32e1cc859b9689bf10169dfd70a9c" title="Waits for up to timeout microseconds for condition to become true on socket. ">condition_timed_wait()</a> convenience overload.  <a href="classGio_1_1Socket.html#a71a3736a74c730c76e7c9a1670c3fbdd">More...</a><br></br></td></tr>
<tr class="separator:a71a3736a74c730c76e7c9a1670c3fbdd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc7b9d6cecc1c2234f9979b2ffb1b309"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adc7b9d6cecc1c2234f9979b2ffb1b309">set_listen_backlog</a> (int backlog)</td></tr>
<tr class="memdesc:adc7b9d6cecc1c2234f9979b2ffb1b309"><td class="mdescLeft"> </td><td class="mdescRight">Sets the maximum number of outstanding connections allowed when listening on this socket.  <a href="classGio_1_1Socket.html#adc7b9d6cecc1c2234f9979b2ffb1b309">More...</a><br></br></td></tr>
<tr class="separator:adc7b9d6cecc1c2234f9979b2ffb1b309"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a22a9e70db9abc7fc6383641afde8ee6f"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a22a9e70db9abc7fc6383641afde8ee6f">get_listen_backlog</a> () const </td></tr>
<tr class="memdesc:a22a9e70db9abc7fc6383641afde8ee6f"><td class="mdescLeft"> </td><td class="mdescRight">Gets the listen backlog setting of the socket.  <a href="classGio_1_1Socket.html#a22a9e70db9abc7fc6383641afde8ee6f">More...</a><br></br></td></tr>
<tr class="separator:a22a9e70db9abc7fc6383641afde8ee6f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a51d5a174441c255b69be9e809cdb96b3"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a51d5a174441c255b69be9e809cdb96b3">set_blocking</a> (bool blocking)</td></tr>
<tr class="memdesc:a51d5a174441c255b69be9e809cdb96b3"><td class="mdescLeft"> </td><td class="mdescRight">Sets the blocking mode of the socket.  <a href="classGio_1_1Socket.html#a51d5a174441c255b69be9e809cdb96b3">More...</a><br></br></td></tr>
<tr class="separator:a51d5a174441c255b69be9e809cdb96b3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ffcbc226b08ae14856ea0dfe4d580e9"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a1ffcbc226b08ae14856ea0dfe4d580e9">get_blocking</a> () const </td></tr>
<tr class="memdesc:a1ffcbc226b08ae14856ea0dfe4d580e9"><td class="mdescLeft"> </td><td class="mdescRight">Gets the blocking mode of the socket.  <a href="classGio_1_1Socket.html#a1ffcbc226b08ae14856ea0dfe4d580e9">More...</a><br></br></td></tr>
<tr class="separator:a1ffcbc226b08ae14856ea0dfe4d580e9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6cfac67927584ae7afe53006eebb06d7"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a6cfac67927584ae7afe53006eebb06d7">set_keepalive</a> (bool keepalive)</td></tr>
<tr class="memdesc:a6cfac67927584ae7afe53006eebb06d7"><td class="mdescLeft"> </td><td class="mdescRight">Sets or unsets the SO_KEEPALIVE flag on the underlying socket.  <a href="classGio_1_1Socket.html#a6cfac67927584ae7afe53006eebb06d7">More...</a><br></br></td></tr>
<tr class="separator:a6cfac67927584ae7afe53006eebb06d7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a530b4adc3d295f7c000981286dee8019"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a530b4adc3d295f7c000981286dee8019">get_keepalive</a> () const </td></tr>
<tr class="memdesc:a530b4adc3d295f7c000981286dee8019"><td class="mdescLeft"> </td><td class="mdescRight">Gets the keepalive mode of the socket.  <a href="classGio_1_1Socket.html#a530b4adc3d295f7c000981286dee8019">More...</a><br></br></td></tr>
<tr class="separator:a530b4adc3d295f7c000981286dee8019"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aac1e2a576e62d1e339eefae1fe12e24b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aac1e2a576e62d1e339eefae1fe12e24b">get_family</a> () const </td></tr>
<tr class="memdesc:aac1e2a576e62d1e339eefae1fe12e24b"><td class="mdescLeft"> </td><td class="mdescRight">Gets the socket family of the socket.  <a href="classGio_1_1Socket.html#aac1e2a576e62d1e339eefae1fe12e24b">More...</a><br></br></td></tr>
<tr class="separator:aac1e2a576e62d1e339eefae1fe12e24b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af3bb5076efcb022e31db9622a1c6e0ae"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af3bb5076efcb022e31db9622a1c6e0ae">get_fd</a> () const </td></tr>
<tr class="memdesc:af3bb5076efcb022e31db9622a1c6e0ae"><td class="mdescLeft"> </td><td class="mdescRight">Returns the underlying OS socket object.  <a href="classGio_1_1Socket.html#af3bb5076efcb022e31db9622a1c6e0ae">More...</a><br></br></td></tr>
<tr class="separator:af3bb5076efcb022e31db9622a1c6e0ae"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a654e36f8577b61a4df93a0a70479a7f1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a654e36f8577b61a4df93a0a70479a7f1">get_local_address</a> () const </td></tr>
<tr class="memdesc:a654e36f8577b61a4df93a0a70479a7f1"><td class="mdescLeft"> </td><td class="mdescRight">Try to get the local address of a bound socket.  <a href="classGio_1_1Socket.html#a654e36f8577b61a4df93a0a70479a7f1">More...</a><br></br></td></tr>
<tr class="separator:a654e36f8577b61a4df93a0a70479a7f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adce45788b8ac674bdf32a3ec8fb683c1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adce45788b8ac674bdf32a3ec8fb683c1">get_remote_address</a> () const </td></tr>
<tr class="memdesc:adce45788b8ac674bdf32a3ec8fb683c1"><td class="mdescLeft"> </td><td class="mdescRight">Try to get the remote address of a connected socket.  <a href="classGio_1_1Socket.html#adce45788b8ac674bdf32a3ec8fb683c1">More...</a><br></br></td></tr>
<tr class="separator:adce45788b8ac674bdf32a3ec8fb683c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1e73efd467d330cfee9cb01e19e1096e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830">Protocol</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a1e73efd467d330cfee9cb01e19e1096e">get_protocol</a> () const </td></tr>
<tr class="memdesc:a1e73efd467d330cfee9cb01e19e1096e"><td class="mdescLeft"> </td><td class="mdescRight">Gets the socket protocol id the socket was created with.  <a href="classGio_1_1Socket.html#a1e73efd467d330cfee9cb01e19e1096e">More...</a><br></br></td></tr>
<tr class="separator:a1e73efd467d330cfee9cb01e19e1096e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a55488fb77aa3c5c0f70ed036428f4b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="group__giommEnums.html#gae7e2589ae30817878ac885a60b0d1461">Type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a6a55488fb77aa3c5c0f70ed036428f4b">get_socket_type</a> () const </td></tr>
<tr class="memdesc:a6a55488fb77aa3c5c0f70ed036428f4b"><td class="mdescLeft"> </td><td class="mdescRight">Gets the socket type of the socket.  <a href="classGio_1_1Socket.html#a6a55488fb77aa3c5c0f70ed036428f4b">More...</a><br></br></td></tr>
<tr class="separator:a6a55488fb77aa3c5c0f70ed036428f4b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae33e646694bf6c5062683ba4b79d4fe1"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae33e646694bf6c5062683ba4b79d4fe1">speaks_ipv4</a> () const </td></tr>
<tr class="memdesc:ae33e646694bf6c5062683ba4b79d4fe1"><td class="mdescLeft"> </td><td class="mdescRight">Checks if a socket is capable of speaking IPv4.  <a href="classGio_1_1Socket.html#ae33e646694bf6c5062683ba4b79d4fe1">More...</a><br></br></td></tr>
<tr class="separator:ae33e646694bf6c5062683ba4b79d4fe1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2fcda0eba8fcb30bd020624ce3f14d8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Credentials.html">Credentials</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a2fcda0eba8fcb30bd020624ce3f14d8f">get_credentials</a> ()</td></tr>
<tr class="memdesc:a2fcda0eba8fcb30bd020624ce3f14d8f"><td class="mdescLeft"> </td><td class="mdescRight">Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for <a class="el" href="namespaceGio.html#ga0ba69e14ad979bf9b2073ad122e38d48a15395d0642f86c5992abbca5e56e2b29" title="The UNIX domain family. ">Gio::SocketFamily::UNIX</a> sockets).  <a href="classGio_1_1Socket.html#a2fcda0eba8fcb30bd020624ce3f14d8f">More...</a><br></br></td></tr>
<tr class="separator:a2fcda0eba8fcb30bd020624ce3f14d8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afcc5b5f562eb0255d846a41bde23d0f7"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1Credentials.html">Credentials</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afcc5b5f562eb0255d846a41bde23d0f7">get_credentials</a> () const </td></tr>
<tr class="memdesc:afcc5b5f562eb0255d846a41bde23d0f7"><td class="mdescLeft"> </td><td class="mdescRight">Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for <a class="el" href="namespaceGio.html#ga0ba69e14ad979bf9b2073ad122e38d48a15395d0642f86c5992abbca5e56e2b29" title="The UNIX domain family. ">Gio::SocketFamily::UNIX</a> sockets).  <a href="classGio_1_1Socket.html#afcc5b5f562eb0255d846a41bde23d0f7">More...</a><br></br></td></tr>
<tr class="separator:afcc5b5f562eb0255d846a41bde23d0f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0c05cab954287b392d6c60bc347ca5d8"><td align="right" class="memItemLeft" valign="top">guint </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0c05cab954287b392d6c60bc347ca5d8">get_timeout</a> () const </td></tr>
<tr class="memdesc:a0c05cab954287b392d6c60bc347ca5d8"><td class="mdescLeft"> </td><td class="mdescRight">Gets the timeout setting of the socket.  <a href="classGio_1_1Socket.html#a0c05cab954287b392d6c60bc347ca5d8">More...</a><br></br></td></tr>
<tr class="separator:a0c05cab954287b392d6c60bc347ca5d8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe942e5157528b217d7af4a7839a9e7a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afe942e5157528b217d7af4a7839a9e7a">set_timeout</a> (guint timeout)</td></tr>
<tr class="memdesc:afe942e5157528b217d7af4a7839a9e7a"><td class="mdescLeft"> </td><td class="mdescRight">Sets the time in seconds after which I/O operations on <em>socket</em> will time out if they have not yet completed.  <a href="classGio_1_1Socket.html#afe942e5157528b217d7af4a7839a9e7a">More...</a><br></br></td></tr>
<tr class="separator:afe942e5157528b217d7af4a7839a9e7a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa22e284f58d0ee09b34644dbd0f291b3"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aa22e284f58d0ee09b34644dbd0f291b3">receive_with_blocking</a> (gchar* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>, bool blocking, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable={})</td></tr>
<tr class="memdesc:aa22e284f58d0ee09b34644dbd0f291b3"><td class="mdescLeft"> </td><td class="mdescRight">This behaves exactly the same as g_socket_receive(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties.  <a href="classGio_1_1Socket.html#aa22e284f58d0ee09b34644dbd0f291b3">More...</a><br></br></td></tr>
<tr class="separator:aa22e284f58d0ee09b34644dbd0f291b3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02b6a6ca54619cf0a990ff9497eb9990"><td align="right" class="memItemLeft" valign="top">gssize </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a02b6a6ca54619cf0a990ff9497eb9990">send_with_blocking</a> (gchar* buffer, gsize <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga5b1a5398fdc4ecf20576f3cae02ea8fc">size</a>, bool blocking, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable={})</td></tr>
<tr class="memdesc:a02b6a6ca54619cf0a990ff9497eb9990"><td class="mdescLeft"> </td><td class="mdescRight">This behaves exactly the same as g_socket_send(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties.  <a href="classGio_1_1Socket.html#a02b6a6ca54619cf0a990ff9497eb9990">More...</a><br></br></td></tr>
<tr class="separator:a02b6a6ca54619cf0a990ff9497eb9990"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae797a60397ec1035d07e625cc3bc423c"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae797a60397ec1035d07e625cc3bc423c">get_option</a> (int level, int optname, int&amp; value) const </td></tr>
<tr class="memdesc:ae797a60397ec1035d07e625cc3bc423c"><td class="mdescLeft"> </td><td class="mdescRight">Gets the value of an integer-valued option on <em>socket</em>, as with getsockopt().  <a href="classGio_1_1Socket.html#ae797a60397ec1035d07e625cc3bc423c">More...</a><br></br></td></tr>
<tr class="separator:ae797a60397ec1035d07e625cc3bc423c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a13116c8ad9db97e3c04a370a8a7ec7d3"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a13116c8ad9db97e3c04a370a8a7ec7d3">set_option</a> (int level, int optname, int value)</td></tr>
<tr class="memdesc:a13116c8ad9db97e3c04a370a8a7ec7d3"><td class="mdescLeft"> </td><td class="mdescRight">Sets the value of an integer-valued option on <em>socket</em>, as with setsockopt().  <a href="classGio_1_1Socket.html#a13116c8ad9db97e3c04a370a8a7ec7d3">More...</a><br></br></td></tr>
<tr class="separator:a13116c8ad9db97e3c04a370a8a7ec7d3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8161abb1b8367aed9502d48be2d94172"><td align="right" class="memItemLeft" valign="top">guint </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8161abb1b8367aed9502d48be2d94172">get_ttl</a> () const </td></tr>
<tr class="memdesc:a8161abb1b8367aed9502d48be2d94172"><td class="mdescLeft"> </td><td class="mdescRight">Gets the unicast time-to-live setting on <em>socket</em>; see g_socket_set_ttl() for more details.  <a href="classGio_1_1Socket.html#a8161abb1b8367aed9502d48be2d94172">More...</a><br></br></td></tr>
<tr class="separator:a8161abb1b8367aed9502d48be2d94172"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afce7afa0966858f85979cbb884294007"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afce7afa0966858f85979cbb884294007">set_ttl</a> (guint ttl)</td></tr>
<tr class="memdesc:afce7afa0966858f85979cbb884294007"><td class="mdescLeft"> </td><td class="mdescRight">Sets the time-to-live for outgoing unicast packets on <em>socket</em>.  <a href="classGio_1_1Socket.html#afce7afa0966858f85979cbb884294007">More...</a><br></br></td></tr>
<tr class="separator:afce7afa0966858f85979cbb884294007"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a766a2e06ff796c80c42147dfb3e85366"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a766a2e06ff796c80c42147dfb3e85366">get_broadcast</a> () const </td></tr>
<tr class="memdesc:a766a2e06ff796c80c42147dfb3e85366"><td class="mdescLeft"> </td><td class="mdescRight">Gets the broadcast setting on <em>socket</em>; if <code>true</code>, it is possible to send packets to broadcast addresses.  <a href="classGio_1_1Socket.html#a766a2e06ff796c80c42147dfb3e85366">More...</a><br></br></td></tr>
<tr class="separator:a766a2e06ff796c80c42147dfb3e85366"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aacaf83216c9c5c127b6b5f8de425db4c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aacaf83216c9c5c127b6b5f8de425db4c">set_broadcast</a> (bool broadcast)</td></tr>
<tr class="memdesc:aacaf83216c9c5c127b6b5f8de425db4c"><td class="mdescLeft"> </td><td class="mdescRight">Sets whether <em>socket</em> should allow sending to broadcast addresses.  <a href="classGio_1_1Socket.html#aacaf83216c9c5c127b6b5f8de425db4c">More...</a><br></br></td></tr>
<tr class="separator:aacaf83216c9c5c127b6b5f8de425db4c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3aa1d5519cde6e690e7d939b8ec79537"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a3aa1d5519cde6e690e7d939b8ec79537">get_multicast_loopback</a> () const </td></tr>
<tr class="memdesc:a3aa1d5519cde6e690e7d939b8ec79537"><td class="mdescLeft"> </td><td class="mdescRight">Gets the multicast loopback setting on <em>socket</em>; if <code>true</code> (the default), outgoing multicast packets will be looped back to multicast listeners on the same host.  <a href="classGio_1_1Socket.html#a3aa1d5519cde6e690e7d939b8ec79537">More...</a><br></br></td></tr>
<tr class="separator:a3aa1d5519cde6e690e7d939b8ec79537"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af2e4493d31588bb9175b090a061dbd5d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af2e4493d31588bb9175b090a061dbd5d">set_multicast_loopback</a> (bool loopback)</td></tr>
<tr class="memdesc:af2e4493d31588bb9175b090a061dbd5d"><td class="mdescLeft"> </td><td class="mdescRight">Sets whether outgoing multicast packets will be received by sockets listening on that multicast address on the same host.  <a href="classGio_1_1Socket.html#af2e4493d31588bb9175b090a061dbd5d">More...</a><br></br></td></tr>
<tr class="separator:af2e4493d31588bb9175b090a061dbd5d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a750debbc865bf9e6d8fb9b950c04dd67"><td align="right" class="memItemLeft" valign="top">guint </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a750debbc865bf9e6d8fb9b950c04dd67">get_multicast_ttl</a> () const </td></tr>
<tr class="memdesc:a750debbc865bf9e6d8fb9b950c04dd67"><td class="mdescLeft"> </td><td class="mdescRight">Gets the multicast time-to-live setting on <em>socket</em>; see g_socket_set_multicast_ttl() for more details.  <a href="classGio_1_1Socket.html#a750debbc865bf9e6d8fb9b950c04dd67">More...</a><br></br></td></tr>
<tr class="separator:a750debbc865bf9e6d8fb9b950c04dd67"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac946c14f5f92326c3f062f23ed1d5837"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ac946c14f5f92326c3f062f23ed1d5837">set_multicast_ttl</a> (guint ttl)</td></tr>
<tr class="memdesc:ac946c14f5f92326c3f062f23ed1d5837"><td class="mdescLeft"> </td><td class="mdescRight">Sets the time-to-live for outgoing multicast datagrams on <em>socket</em>.  <a href="classGio_1_1Socket.html#ac946c14f5f92326c3f062f23ed1d5837">More...</a><br></br></td></tr>
<tr class="separator:ac946c14f5f92326c3f062f23ed1d5837"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afded8c4757a4f2f8a89b6550e48531db"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afded8c4757a4f2f8a89b6550e48531db">join_multicast_group</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; group, bool source_specific, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; iface)</td></tr>
<tr class="memdesc:afded8c4757a4f2f8a89b6550e48531db"><td class="mdescLeft"> </td><td class="mdescRight">Registers <em>socket</em> to receive multicast messages sent to <em>group</em>.  <a href="classGio_1_1Socket.html#afded8c4757a4f2f8a89b6550e48531db">More...</a><br></br></td></tr>
<tr class="separator:afded8c4757a4f2f8a89b6550e48531db"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8db138a424b8b2ab26d62a9ef2b29656"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8db138a424b8b2ab26d62a9ef2b29656">join_multicast_group</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; group, bool source_specific)</td></tr>
<tr class="memdesc:a8db138a424b8b2ab26d62a9ef2b29656"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#afded8c4757a4f2f8a89b6550e48531db" title="Registers socket to receive multicast messages sent to group. ">join_multicast_group()</a> convenience overload.  <a href="classGio_1_1Socket.html#a8db138a424b8b2ab26d62a9ef2b29656">More...</a><br></br></td></tr>
<tr class="separator:a8db138a424b8b2ab26d62a9ef2b29656"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c7e7ee9703f5f92dafa0a49cc47ca91"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a5c7e7ee9703f5f92dafa0a49cc47ca91">leave_multicast_group</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; group, bool source_specific, const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; iface)</td></tr>
<tr class="memdesc:a5c7e7ee9703f5f92dafa0a49cc47ca91"><td class="mdescLeft"> </td><td class="mdescRight">Removes <em>socket</em> from the multicast group defined by <em>group</em>, <em>iface</em>, and <em>source_specific</em> (which must all have the same values they had when you joined the group).  <a href="classGio_1_1Socket.html#a5c7e7ee9703f5f92dafa0a49cc47ca91">More...</a><br></br></td></tr>
<tr class="separator:a5c7e7ee9703f5f92dafa0a49cc47ca91"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad6648bc6b4d15ac95903ff47bb8e140f"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad6648bc6b4d15ac95903ff47bb8e140f">leave_multicast_group</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; group, bool source_specific)</td></tr>
<tr class="memdesc:ad6648bc6b4d15ac95903ff47bb8e140f"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a5c7e7ee9703f5f92dafa0a49cc47ca91" title="Removes socket from the multicast group defined by group, iface, and source_specific (which must all ...">leave_multicast_group()</a> convenience overload.  <a href="classGio_1_1Socket.html#ad6648bc6b4d15ac95903ff47bb8e140f">More...</a><br></br></td></tr>
<tr class="separator:ad6648bc6b4d15ac95903ff47bb8e140f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a33e80070bf40ed9bff3d6e82fd6bc403"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a33e80070bf40ed9bff3d6e82fd6bc403">property_blocking</a> ()</td></tr>
<tr class="memdesc:a33e80070bf40ed9bff3d6e82fd6bc403"><td class="mdescLeft"> </td><td class="mdescRight">Whether or not I/O on this socket is blocking.  <a href="classGio_1_1Socket.html#a33e80070bf40ed9bff3d6e82fd6bc403">More...</a><br></br></td></tr>
<tr class="separator:a33e80070bf40ed9bff3d6e82fd6bc403"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4d697455cc099f37e06550d9a6b244c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad4d697455cc099f37e06550d9a6b244c">property_blocking</a> () const </td></tr>
<tr class="memdesc:ad4d697455cc099f37e06550d9a6b244c"><td class="mdescLeft"> </td><td class="mdescRight">Whether or not I/O on this socket is blocking.  <a href="classGio_1_1Socket.html#ad4d697455cc099f37e06550d9a6b244c">More...</a><br></br></td></tr>
<tr class="separator:ad4d697455cc099f37e06550d9a6b244c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83a9ca8602e7d1c500cf9f4f4ab45aee"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a83a9ca8602e7d1c500cf9f4f4ab45aee">property_family</a> () const </td></tr>
<tr class="memdesc:a83a9ca8602e7d1c500cf9f4f4ab45aee"><td class="mdescLeft"> </td><td class="mdescRight">The sockets address family.  <a href="classGio_1_1Socket.html#a83a9ca8602e7d1c500cf9f4f4ab45aee">More...</a><br></br></td></tr>
<tr class="separator:a83a9ca8602e7d1c500cf9f4f4ab45aee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a92f0ebc8891cdcccf8e16d0845921beb"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a92f0ebc8891cdcccf8e16d0845921beb">property_fd</a> () const </td></tr>
<tr class="memdesc:a92f0ebc8891cdcccf8e16d0845921beb"><td class="mdescLeft"> </td><td class="mdescRight">The sockets file descriptor.  <a href="classGio_1_1Socket.html#a92f0ebc8891cdcccf8e16d0845921beb">More...</a><br></br></td></tr>
<tr class="separator:a92f0ebc8891cdcccf8e16d0845921beb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab16cc7a80fbbf288732298017f21a5f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aab16cc7a80fbbf288732298017f21a5f">property_keepalive</a> ()</td></tr>
<tr class="memdesc:aab16cc7a80fbbf288732298017f21a5f"><td class="mdescLeft"> </td><td class="mdescRight">Keep connection alive by sending periodic pings.  <a href="classGio_1_1Socket.html#aab16cc7a80fbbf288732298017f21a5f">More...</a><br></br></td></tr>
<tr class="separator:aab16cc7a80fbbf288732298017f21a5f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a545a19bc5664e66900d1ca8c29f7d0e6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a545a19bc5664e66900d1ca8c29f7d0e6">property_keepalive</a> () const </td></tr>
<tr class="memdesc:a545a19bc5664e66900d1ca8c29f7d0e6"><td class="mdescLeft"> </td><td class="mdescRight">Keep connection alive by sending periodic pings.  <a href="classGio_1_1Socket.html#a545a19bc5664e66900d1ca8c29f7d0e6">More...</a><br></br></td></tr>
<tr class="separator:a545a19bc5664e66900d1ca8c29f7d0e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c7ef3aff95f2f829af2d3ce2ef36836"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a7c7ef3aff95f2f829af2d3ce2ef36836">property_listen_backlog</a> ()</td></tr>
<tr class="memdesc:a7c7ef3aff95f2f829af2d3ce2ef36836"><td class="mdescLeft"> </td><td class="mdescRight">Outstanding connections in the listen queue.  <a href="classGio_1_1Socket.html#a7c7ef3aff95f2f829af2d3ce2ef36836">More...</a><br></br></td></tr>
<tr class="separator:a7c7ef3aff95f2f829af2d3ce2ef36836"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad08f21c5f7bd408e63815581bbfb48ab"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad08f21c5f7bd408e63815581bbfb48ab">property_listen_backlog</a> () const </td></tr>
<tr class="memdesc:ad08f21c5f7bd408e63815581bbfb48ab"><td class="mdescLeft"> </td><td class="mdescRight">Outstanding connections in the listen queue.  <a href="classGio_1_1Socket.html#ad08f21c5f7bd408e63815581bbfb48ab">More...</a><br></br></td></tr>
<tr class="separator:ad08f21c5f7bd408e63815581bbfb48ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac52bc9e13993758922ce0d3683f336af"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ac52bc9e13993758922ce0d3683f336af">property_local_address</a> () const </td></tr>
<tr class="memdesc:ac52bc9e13993758922ce0d3683f336af"><td class="mdescLeft"> </td><td class="mdescRight">The local address the socket is bound to.  <a href="classGio_1_1Socket.html#ac52bc9e13993758922ce0d3683f336af">More...</a><br></br></td></tr>
<tr class="separator:ac52bc9e13993758922ce0d3683f336af"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0affc1f63146a265a1d1c2b884091708"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0affc1f63146a265a1d1c2b884091708">property_remote_address</a> () const </td></tr>
<tr class="memdesc:a0affc1f63146a265a1d1c2b884091708"><td class="mdescLeft"> </td><td class="mdescRight">The remote address the socket is connected to.  <a href="classGio_1_1Socket.html#a0affc1f63146a265a1d1c2b884091708">More...</a><br></br></td></tr>
<tr class="separator:a0affc1f63146a265a1d1c2b884091708"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4042172bae49d0a2721546e31141d572"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4042172bae49d0a2721546e31141d572">property_timeout</a> ()</td></tr>
<tr class="memdesc:a4042172bae49d0a2721546e31141d572"><td class="mdescLeft"> </td><td class="mdescRight">The timeout in seconds on socket I/O.  <a href="classGio_1_1Socket.html#a4042172bae49d0a2721546e31141d572">More...</a><br></br></td></tr>
<tr class="separator:a4042172bae49d0a2721546e31141d572"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a19433af6a2d3b85920a709559d81e4a3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a19433af6a2d3b85920a709559d81e4a3">property_timeout</a> () const </td></tr>
<tr class="memdesc:a19433af6a2d3b85920a709559d81e4a3"><td class="mdescLeft"> </td><td class="mdescRight">The timeout in seconds on socket I/O.  <a href="classGio_1_1Socket.html#a19433af6a2d3b85920a709559d81e4a3">More...</a><br></br></td></tr>
<tr class="separator:a19433af6a2d3b85920a709559d81e4a3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a251771227ec93ff3b4f98c6e747dd479"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830">Protocol</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a251771227ec93ff3b4f98c6e747dd479">property_protocol</a> () const </td></tr>
<tr class="memdesc:a251771227ec93ff3b4f98c6e747dd479"><td class="mdescLeft"> </td><td class="mdescRight">The id of the protocol to use, or -1 for unknown.  <a href="classGio_1_1Socket.html#a251771227ec93ff3b4f98c6e747dd479">More...</a><br></br></td></tr>
<tr class="separator:a251771227ec93ff3b4f98c6e747dd479"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a870a59c1f58b2c4b28aa402e7c824cf1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a870a59c1f58b2c4b28aa402e7c824cf1">property_broadcast</a> ()</td></tr>
<tr class="memdesc:a870a59c1f58b2c4b28aa402e7c824cf1"><td class="mdescLeft"> </td><td class="mdescRight">Whether the socket should allow sending to broadcast addresses.  <a href="classGio_1_1Socket.html#a870a59c1f58b2c4b28aa402e7c824cf1">More...</a><br></br></td></tr>
<tr class="separator:a870a59c1f58b2c4b28aa402e7c824cf1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa74338dcee4fb6ef6e3d3db36e0a6347"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aa74338dcee4fb6ef6e3d3db36e0a6347">property_broadcast</a> () const </td></tr>
<tr class="memdesc:aa74338dcee4fb6ef6e3d3db36e0a6347"><td class="mdescLeft"> </td><td class="mdescRight">Whether the socket should allow sending to broadcast addresses.  <a href="classGio_1_1Socket.html#aa74338dcee4fb6ef6e3d3db36e0a6347">More...</a><br></br></td></tr>
<tr class="separator:aa74338dcee4fb6ef6e3d3db36e0a6347"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adeb2295f5040a0f8a4709c40fb38ec2e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#gae7e2589ae30817878ac885a60b0d1461">Type</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adeb2295f5040a0f8a4709c40fb38ec2e">property_type</a> () const </td></tr>
<tr class="memdesc:adeb2295f5040a0f8a4709c40fb38ec2e"><td class="mdescLeft"> </td><td class="mdescRight">The sockets type.  <a href="classGio_1_1Socket.html#adeb2295f5040a0f8a4709c40fb38ec2e">More...</a><br></br></td></tr>
<tr class="separator:adeb2295f5040a0f8a4709c40fb38ec2e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab7c54b763b8637fb06f4c03c4796e1c9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ab7c54b763b8637fb06f4c03c4796e1c9">property_ttl</a> ()</td></tr>
<tr class="memdesc:ab7c54b763b8637fb06f4c03c4796e1c9"><td class="mdescLeft"> </td><td class="mdescRight">Time-to-live for outgoing unicast packets.  <a href="classGio_1_1Socket.html#ab7c54b763b8637fb06f4c03c4796e1c9">More...</a><br></br></td></tr>
<tr class="separator:ab7c54b763b8637fb06f4c03c4796e1c9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aba76e739cbfd9a6bb69efa3a908b718f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aba76e739cbfd9a6bb69efa3a908b718f">property_ttl</a> () const </td></tr>
<tr class="memdesc:aba76e739cbfd9a6bb69efa3a908b718f"><td class="mdescLeft"> </td><td class="mdescRight">Time-to-live for outgoing unicast packets.  <a href="classGio_1_1Socket.html#aba76e739cbfd9a6bb69efa3a908b718f">More...</a><br></br></td></tr>
<tr class="separator:aba76e739cbfd9a6bb69efa3a908b718f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a067aa46a4f9950001e56a315f4313add"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a067aa46a4f9950001e56a315f4313add">property_multicast_loopback</a> ()</td></tr>
<tr class="memdesc:a067aa46a4f9950001e56a315f4313add"><td class="mdescLeft"> </td><td class="mdescRight">Whether outgoing multicast packets loop back to the local host.  <a href="classGio_1_1Socket.html#a067aa46a4f9950001e56a315f4313add">More...</a><br></br></td></tr>
<tr class="separator:a067aa46a4f9950001e56a315f4313add"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abe4b46a4077d1889099cf2f11ba92a83"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#abe4b46a4077d1889099cf2f11ba92a83">property_multicast_loopback</a> () const </td></tr>
<tr class="memdesc:abe4b46a4077d1889099cf2f11ba92a83"><td class="mdescLeft"> </td><td class="mdescRight">Whether outgoing multicast packets loop back to the local host.  <a href="classGio_1_1Socket.html#abe4b46a4077d1889099cf2f11ba92a83">More...</a><br></br></td></tr>
<tr class="separator:abe4b46a4077d1889099cf2f11ba92a83"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a669af953e00f1041a0088e1da6c7787d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a669af953e00f1041a0088e1da6c7787d">property_multicast_ttl</a> ()</td></tr>
<tr class="memdesc:a669af953e00f1041a0088e1da6c7787d"><td class="mdescLeft"> </td><td class="mdescRight">Time-to-live out outgoing multicast packets.  <a href="classGio_1_1Socket.html#a669af953e00f1041a0088e1da6c7787d">More...</a><br></br></td></tr>
<tr class="separator:a669af953e00f1041a0088e1da6c7787d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a756aad409d9845505a20069923415179"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a756aad409d9845505a20069923415179">property_multicast_ttl</a> () const </td></tr>
<tr class="memdesc:a756aad409d9845505a20069923415179"><td class="mdescLeft"> </td><td class="mdescRight">Time-to-live out outgoing multicast packets.  <a href="classGio_1_1Socket.html#a756aad409d9845505a20069923415179">More...</a><br></br></td></tr>
<tr class="separator:a756aad409d9845505a20069923415179"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1Object')"><img alt="-" src="closed.png"></img> Public Member Functions inherited from <a class="el" href="classGlib_1_1Object.html">Glib::Object</a></td></tr>
<tr class="memitem:a0127f43140e01d6a6731d42f9419be27 inherit pub_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a0127f43140e01d6a6731d42f9419be27">Object</a> (const <a class="el" href="classGlib_1_1Object.html">Object</a>&amp;)=delete</td></tr>
<tr class="separator:a0127f43140e01d6a6731d42f9419be27 inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7081561a5684709718fdf8c1875c56c0 inherit pub_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1Object.html">Object</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a7081561a5684709718fdf8c1875c56c0">operator=</a> (const <a class="el" href="classGlib_1_1Object.html">Object</a>&amp;)=delete</td></tr>
<tr class="separator:a7081561a5684709718fdf8c1875c56c0 inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a473ee068b40d5c949cee2c721d720c9a inherit pub_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a473ee068b40d5c949cee2c721d720c9a">Object</a> (<a class="el" href="classGlib_1_1Object.html">Object</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a473ee068b40d5c949cee2c721d720c9a inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2855131d475e54294dc34573f12ca9a0 inherit pub_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1Object.html">Object</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a2855131d475e54294dc34573f12ca9a0">operator=</a> (<a class="el" href="classGlib_1_1Object.html">Object</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a2855131d475e54294dc34573f12ca9a0 inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0e6581bcbcc6197cca07df24bb91c492 inherit pub_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top">void* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a0e6581bcbcc6197cca07df24bb91c492">get_data</a> (const <a class="el" href="classGlib_1_1QueryQuark.html">QueryQuark</a>&amp; key)</td></tr>
<tr class="separator:a0e6581bcbcc6197cca07df24bb91c492 inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afff7a375a862f3f899daaa99710122fa inherit pub_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#afff7a375a862f3f899daaa99710122fa">set_data</a> (const <a class="el" href="classGlib_1_1Quark.html">Quark</a>&amp; key, void* data)</td></tr>
<tr class="separator:afff7a375a862f3f899daaa99710122fa inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1febe3bae2dd71756e98e523cd33c1b4 inherit pub_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a1febe3bae2dd71756e98e523cd33c1b4">set_data</a> (const <a class="el" href="classGlib_1_1Quark.html">Quark</a>&amp; key, void* data, <a class="el" href="classGlib_1_1Object.html#a969836f7bf4fec78eb50a1d790304d82">DestroyNotify</a> notify)</td></tr>
<tr class="separator:a1febe3bae2dd71756e98e523cd33c1b4 inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aada5b50844bda7ee02bed0ae2a715c00 inherit pub_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#aada5b50844bda7ee02bed0ae2a715c00">remove_data</a> (const <a class="el" href="classGlib_1_1QueryQuark.html">QueryQuark</a>&amp; quark)</td></tr>
<tr class="separator:aada5b50844bda7ee02bed0ae2a715c00 inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab454f71bd74403b0cc46d3cbbedd6b0e inherit pub_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top">void* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#ab454f71bd74403b0cc46d3cbbedd6b0e">steal_data</a> (const <a class="el" href="classGlib_1_1QueryQuark.html">QueryQuark</a>&amp; quark)</td></tr>
<tr class="separator:ab454f71bd74403b0cc46d3cbbedd6b0e inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1ObjectBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1ObjectBase')"><img alt="-" src="closed.png"></img> Public Member Functions inherited from <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a></td></tr>
<tr class="memitem:aaf0e140e7192dcecddd9f57c46825434 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#aaf0e140e7192dcecddd9f57c46825434">ObjectBase</a> (const <a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;)=delete</td></tr>
<tr class="separator:aaf0e140e7192dcecddd9f57c46825434 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a15f8834a320eac98dc1c1b8a9a2fd4c1 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a15f8834a320eac98dc1c1b8a9a2fd4c1">operator=</a> (const <a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;)=delete</td></tr>
<tr class="separator:a15f8834a320eac98dc1c1b8a9a2fd4c1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#aab599d3eec4b4a9ddc95ccdc6100053d">set_property_value</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const <a class="el" href="classGlib_1_1ValueBase.html">Glib::ValueBase</a>&amp; value)</td></tr>
<tr class="memdesc:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1Socket.html#aab599d3eec4b4a9ddc95ccdc6100053d">More...</a><br></br></td></tr>
<tr class="separator:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5e30750441b92f0246c9d4ece95fc8a0">get_property_value</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, <a class="el" href="classGlib_1_1ValueBase.html">Glib::ValueBase</a>&amp; value) const </td></tr>
<tr class="memdesc:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1Socket.html#a5e30750441b92f0246c9d4ece95fc8a0">More...</a><br></br></td></tr>
<tr class="separator:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad37844f7ea2c0091a22d011e04c48820">set_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const PropertyType&amp; value)</td></tr>
<tr class="memdesc:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1Socket.html#ad37844f7ea2c0091a22d011e04c48820">More...</a><br></br></td></tr>
<tr class="separator:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5f894c9c36ad391fdc85552af67a8530">get_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, PropertyType&amp; value) const </td></tr>
<tr class="memdesc:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1Socket.html#a5f894c9c36ad391fdc85552af67a8530">More...</a><br></br></td></tr>
<tr class="separator:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad13198dfb78c8f54eff75034f9282c36 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:ad13198dfb78c8f54eff75034f9282c36 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memTemplItemLeft" valign="top">PropertyType </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad13198dfb78c8f54eff75034f9282c36">get_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name) const </td></tr>
<tr class="memdesc:ad13198dfb78c8f54eff75034f9282c36 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="classGio_1_1Socket.html#ad13198dfb78c8f54eff75034f9282c36">More...</a><br></br></td></tr>
<tr class="separator:ad13198dfb78c8f54eff75034f9282c36 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b6fbb318fff3492ac8d0ab4767ac326 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1connection.html">sigc::connection</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5b6fbb318fff3492ac8d0ab4767ac326">connect_property_changed</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const sigc::slot&lt; void()&gt;&amp; slot)</td></tr>
<tr class="memdesc:a5b6fbb318fff3492ac8d0ab4767ac326 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead.  <a href="classGio_1_1Socket.html#a5b6fbb318fff3492ac8d0ab4767ac326">More...</a><br></br></td></tr>
<tr class="separator:a5b6fbb318fff3492ac8d0ab4767ac326 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a04031f42ca0f61950325b6322442bff4 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1connection.html">sigc::connection</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a04031f42ca0f61950325b6322442bff4">connect_property_changed</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, sigc::slot&lt; void()&gt;&amp;&amp; slot)</td></tr>
<tr class="memdesc:a04031f42ca0f61950325b6322442bff4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead.  <a href="classGio_1_1Socket.html#a04031f42ca0f61950325b6322442bff4">More...</a><br></br></td></tr>
<tr class="separator:a04031f42ca0f61950325b6322442bff4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a6e9e13b75f116c20212d318204ce8ea3">freeze_notify</a> ()</td></tr>
<tr class="memdesc:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Increases the freeze count on object.  <a href="classGio_1_1Socket.html#a6e9e13b75f116c20212d318204ce8ea3">More...</a><br></br></td></tr>
<tr class="separator:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a1bd8ea7bd8c4084ade6b3c27dddf06a4">thaw_notify</a> ()</td></tr>
<tr class="memdesc:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Reverts the effect of a previous call to <a class="el" href="classGlib_1_1ObjectBase.html#a6e9e13b75f116c20212d318204ce8ea3" title="Increases the freeze count on object. ">freeze_notify()</a>.  <a href="classGio_1_1Socket.html#a1bd8ea7bd8c4084ade6b3c27dddf06a4">More...</a><br></br></td></tr>
<tr class="separator:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a896a8a5db20043ea82956e3ef4b9c4ae">reference</a> () const </td></tr>
<tr class="memdesc:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Increment the reference count for this object.  <a href="classGio_1_1Socket.html#a896a8a5db20043ea82956e3ef4b9c4ae">More...</a><br></br></td></tr>
<tr class="separator:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">virtual void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3234b8ffb2a35b927e2978c8f3bfbfe3">unreference</a> () const </td></tr>
<tr class="memdesc:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Decrement the reference count for this object.  <a href="classGio_1_1Socket.html#a3234b8ffb2a35b927e2978c8f3bfbfe3">More...</a><br></br></td></tr>
<tr class="separator:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">gobj</a> ()</td></tr>
<tr class="memdesc:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1Socket.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">More...</a><br></br></td></tr>
<tr class="separator:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">const GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">gobj</a> () const </td></tr>
<tr class="memdesc:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1Socket.html#a778a94181132976bbfb0519793f3b32e">More...</a><br></br></td></tr>
<tr class="separator:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a9b2a5eb93102f1849e5419016e22a15f">gobj_copy</a> () const </td></tr>
<tr class="memdesc:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">Give a ref-ed copy to someone. Use for direct struct access.  <a href="classGio_1_1Socket.html#a9b2a5eb93102f1849e5419016e22a15f">More...</a><br></br></td></tr>
<tr class="separator:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_structsigc_1_1trackable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structsigc_1_1trackable')"><img alt="-" src="closed.png"></img> Public Member Functions inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a></td></tr>
<tr class="memitem:a7e1348841e762fb41b41c6f2ce9fa073 inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a7e1348841e762fb41b41c6f2ce9fa073">trackable</a> () noexcept</td></tr>
<tr class="separator:a7e1348841e762fb41b41c6f2ce9fa073 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac8431d9452c9698a012597e6560c72fa inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#ac8431d9452c9698a012597e6560c72fa">trackable</a> (const <a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp;src) noexcept</td></tr>
<tr class="separator:ac8431d9452c9698a012597e6560c72fa inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a6ff5a4d7c51cede2117525f470f96a inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a9a6ff5a4d7c51cede2117525f470f96a">trackable</a> (<a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:a9a6ff5a4d7c51cede2117525f470f96a inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a75587da09e30031db7a2519843f1f4fb inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a75587da09e30031db7a2519843f1f4fb">~trackable</a> ()</td></tr>
<tr class="separator:a75587da09e30031db7a2519843f1f4fb inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a146daab307d37c92b68a974c79ed10b7 inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a146daab307d37c92b68a974c79ed10b7">add_destroy_notify_callback</a> (<a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html">notifiable</a> *data, <a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html#a71455cae4b10ff1277e68a1729e1b8c4">func_destroy_notify</a> func) const </td></tr>
<tr class="separator:a146daab307d37c92b68a974c79ed10b7 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af2e23cfe7adc1ca844a3350bbac557cb inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#af2e23cfe7adc1ca844a3350bbac557cb">notify_callbacks</a> ()</td></tr>
<tr class="separator:af2e23cfe7adc1ca844a3350bbac557cb inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7494fbad23a65932ff1457d00d4edaf5 inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a7494fbad23a65932ff1457d00d4edaf5">operator=</a> (const <a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp;src)</td></tr>
<tr class="separator:a7494fbad23a65932ff1457d00d4edaf5 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a400b5799372238211a4437844d923a4e inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a400b5799372238211a4437844d923a4e">operator=</a> (<a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">trackable</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:a400b5799372238211a4437844d923a4e inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a700a7b0a5059a9c8eda2b1a6eb6905f8 inherit pub_methods_structsigc_1_1trackable"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html#a700a7b0a5059a9c8eda2b1a6eb6905f8">remove_destroy_notify_callback</a> (<a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1notifiable.html">notifiable</a> *data) const </td></tr>
<tr class="separator:a700a7b0a5059a9c8eda2b1a6eb6905f8 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_classGio_1_1Initable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGio_1_1Initable')"><img alt="-" src="closed.png"></img> Public Member Functions inherited from <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a></td></tr>
<tr class="memitem:a80cb70756e778fe83023ab4f80706eed inherit pub_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a80cb70756e778fe83023ab4f80706eed">Initable</a> (<a class="el" href="classGio_1_1Initable.html">Initable</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a80cb70756e778fe83023ab4f80706eed inherit pub_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b30589991f534cb7ffba2f12e5d359b inherit pub_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGio_1_1Initable.html">Initable</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a6b30589991f534cb7ffba2f12e5d359b">operator=</a> (<a class="el" href="classGio_1_1Initable.html">Initable</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a6b30589991f534cb7ffba2f12e5d359b inherit pub_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:affc028638b8d8ba9da18d14e6d121c35 inherit pub_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#affc028638b8d8ba9da18d14e6d121c35">~Initable</a> () noexcept override</td></tr>
<tr class="separator:affc028638b8d8ba9da18d14e6d121c35 inherit pub_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a90206d58591c674e03c5de57623bac18 inherit pub_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top">GInitable* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a90206d58591c674e03c5de57623bac18">gobj</a> ()</td></tr>
<tr class="memdesc:a90206d58591c674e03c5de57623bac18 inherit pub_methods_classGio_1_1Initable"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1Socket.html#a90206d58591c674e03c5de57623bac18">More...</a><br></br></td></tr>
<tr class="separator:a90206d58591c674e03c5de57623bac18 inherit pub_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a30665fda96b812e27231ec5abc47b789 inherit pub_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top">const GInitable* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a30665fda96b812e27231ec5abc47b789">gobj</a> () const </td></tr>
<tr class="memdesc:a30665fda96b812e27231ec5abc47b789 inherit pub_methods_classGio_1_1Initable"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="classGio_1_1Socket.html#a30665fda96b812e27231ec5abc47b789">More...</a><br></br></td></tr>
<tr class="separator:a30665fda96b812e27231ec5abc47b789 inherit pub_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1Interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1Interface')"><img alt="-" src="closed.png"></img> Public Member Functions inherited from <a class="el" href="classGlib_1_1Interface.html">Glib::Interface</a></td></tr>
<tr class="memitem:a3ab20f29c40967352d1bf2d88bfe11e5 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a3ab20f29c40967352d1bf2d88bfe11e5">Interface</a> ()</td></tr>
<tr class="memdesc:a3ab20f29c40967352d1bf2d88bfe11e5 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft"> </td><td class="mdescRight">A Default constructor.  <a href="classGio_1_1Socket.html#a3ab20f29c40967352d1bf2d88bfe11e5">More...</a><br></br></td></tr>
<tr class="separator:a3ab20f29c40967352d1bf2d88bfe11e5 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83337dc270f966539b9f46804460ab75 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a83337dc270f966539b9f46804460ab75">Interface</a> (<a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a83337dc270f966539b9f46804460ab75 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a411d66c7467e749dbb2c4b31c4d518b5 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a411d66c7467e749dbb2c4b31c4d518b5">operator=</a> (<a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a411d66c7467e749dbb2c4b31c4d518b5 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#ae05bf6a4ce0f0992c2ad01429d13f9f7">Interface</a> (const Glib::Interface_Class&amp; interface_class)</td></tr>
<tr class="memdesc:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft"> </td><td class="mdescRight">Called by constructors of derived classes.  <a href="classGio_1_1Socket.html#ae05bf6a4ce0f0992c2ad01429d13f9f7">More...</a><br></br></td></tr>
<tr class="separator:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a00253b22a76f751f1627865451cbc404">Interface</a> (GObject* castitem)</td></tr>
<tr class="memdesc:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft"> </td><td class="mdescRight">Called by constructors of derived classes.  <a href="classGio_1_1Socket.html#a00253b22a76f751f1627865451cbc404">More...</a><br></br></td></tr>
<tr class="separator:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a158029af7ab7279e18ab84ad6f5ad5 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a3a158029af7ab7279e18ab84ad6f5ad5">~Interface</a> () noexcept override</td></tr>
<tr class="separator:a3a158029af7ab7279e18ab84ad6f5ad5 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4bb27d294728f34452be66b4ec4cd757 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a4bb27d294728f34452be66b4ec4cd757">Interface</a> (const <a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;)=delete</td></tr>
<tr class="separator:a4bb27d294728f34452be66b4ec4cd757 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acf322f95cef17aa4cc232d8ef25f2b42 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#acf322f95cef17aa4cc232d8ef25f2b42">operator=</a> (const <a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;)=delete</td></tr>
<tr class="separator:acf322f95cef17aa4cc232d8ef25f2b42 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a969e9396f75132a9577428f4fa932d42 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top">GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a969e9396f75132a9577428f4fa932d42">gobj</a> ()</td></tr>
<tr class="separator:a969e9396f75132a9577428f4fa932d42 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a70a443071a69d3372c2cdd7128a91ed1 inherit pub_methods_classGlib_1_1Interface"><td align="right" class="memItemLeft" valign="top">const GObject* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a70a443071a69d3372c2cdd7128a91ed1">gobj</a> () const </td></tr>
<tr class="separator:a70a443071a69d3372c2cdd7128a91ed1 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a175fe732c02ea3e861a86e6c7d690ba0"><td align="right" class="memItemLeft" valign="top">static GType </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a175fe732c02ea3e861a86e6c7d690ba0">get_type</a> ()</td></tr>
<tr class="memdesc:a175fe732c02ea3e861a86e6c7d690ba0"><td class="mdescLeft"> </td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="classGio_1_1Socket.html#a175fe732c02ea3e861a86e6c7d690ba0">More...</a><br></br></td></tr>
<tr class="separator:a175fe732c02ea3e861a86e6c7d690ba0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a226dbeb21a3f42bd976025cb58d682f8"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a226dbeb21a3f42bd976025cb58d682f8">create</a> (<a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> family, <a class="el" href="group__giommEnums.html#gae7e2589ae30817878ac885a60b0d1461">Type</a> type, <a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830">Protocol</a> protocol, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable={})</td></tr>
<tr class="memdesc:a226dbeb21a3f42bd976025cb58d682f8"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> with the defined family, type and protocol.  <a href="classGio_1_1Socket.html#a226dbeb21a3f42bd976025cb58d682f8">More...</a><br></br></td></tr>
<tr class="separator:a226dbeb21a3f42bd976025cb58d682f8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2857fe57a2460b8c0f6a187159038672"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a2857fe57a2460b8c0f6a187159038672">create_from_fd</a> (int fd, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable={})</td></tr>
<tr class="memdesc:a2857fe57a2460b8c0f6a187159038672"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> from a native file descriptor or winsock SOCKET handle.  <a href="classGio_1_1Socket.html#a2857fe57a2460b8c0f6a187159038672">More...</a><br></br></td></tr>
<tr class="separator:a2857fe57a2460b8c0f6a187159038672"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pub_static_methods_classGio_1_1Initable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classGio_1_1Initable')"><img alt="-" src="closed.png"></img> Static Public Member Functions inherited from <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a></td></tr>
<tr class="memitem:a6b68b1a2c2ab02ed1f25887c7acd121c inherit pub_static_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a6b68b1a2c2ab02ed1f25887c7acd121c">add_interface</a> (GType gtype_implementer)</td></tr>
<tr class="separator:a6b68b1a2c2ab02ed1f25887c7acd121c inherit pub_static_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a76f2678aa3641f7ded51813d9ead43 inherit pub_static_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top">static GType </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a6a76f2678aa3641f7ded51813d9ead43">get_type</a> ()</td></tr>
<tr class="memdesc:a6a76f2678aa3641f7ded51813d9ead43 inherit pub_static_methods_classGio_1_1Initable"><td class="mdescLeft"> </td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="classGio_1_1Socket.html#a6a76f2678aa3641f7ded51813d9ead43">More...</a><br></br></td></tr>
<tr class="separator:a6a76f2678aa3641f7ded51813d9ead43 inherit pub_static_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac4d8110044fe1ae3d3b6d339f62b20a7"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ac4d8110044fe1ae3d3b6d339f62b20a7">Socket</a> (<a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> family, <a class="el" href="group__giommEnums.html#gae7e2589ae30817878ac885a60b0d1461">Type</a> type, <a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830">Protocol</a> protocol, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="separator:ac4d8110044fe1ae3d3b6d339f62b20a7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a74d7c4338fcf53743f23926fccc8c6d6"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a74d7c4338fcf53743f23926fccc8c6d6">Socket</a> (int fd, const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="separator:a74d7c4338fcf53743f23926fccc8c6d6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pro_methods_classGlib_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGlib_1_1Object')"><img alt="-" src="closed.png"></img> Protected Member Functions inherited from <a class="el" href="classGlib_1_1Object.html">Glib::Object</a></td></tr>
<tr class="memitem:ad43f7c5ad0336e1eb3af622392a112eb inherit pro_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#ad43f7c5ad0336e1eb3af622392a112eb">Object</a> ()</td></tr>
<tr class="separator:ad43f7c5ad0336e1eb3af622392a112eb inherit pro_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6d72588496bd7ac03f72420021fb94a5 inherit pro_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a6d72588496bd7ac03f72420021fb94a5">Object</a> (const Glib::ConstructParams&amp; construct_params)</td></tr>
<tr class="separator:a6d72588496bd7ac03f72420021fb94a5 inherit pro_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6f490eeaeb71db673c36799a0f729be5 inherit pro_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a6f490eeaeb71db673c36799a0f729be5">Object</a> (GObject* castitem)</td></tr>
<tr class="separator:a6f490eeaeb71db673c36799a0f729be5 inherit pro_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a07e5bddabe8d60f751e157f0a41ce265 inherit pro_methods_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a07e5bddabe8d60f751e157f0a41ce265">~Object</a> () noexcept override</td></tr>
<tr class="separator:a07e5bddabe8d60f751e157f0a41ce265 inherit pro_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pro_methods_classGlib_1_1ObjectBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGlib_1_1ObjectBase')"><img alt="-" src="closed.png"></img> Protected Member Functions inherited from <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a></td></tr>
<tr class="memitem:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a27d3451d9ca28d6a2f00838d7c56d545">ObjectBase</a> ()</td></tr>
<tr class="memdesc:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">This default constructor is called implicitly from the constructor of user-derived classes, even if, for instance, Gtk::Button calls a different <a class="el" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces. ">ObjectBase</a> constructor.  <a href="classGio_1_1Socket.html#a27d3451d9ca28d6a2f00838d7c56d545">More...</a><br></br></td></tr>
<tr class="separator:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad4ef18214894c6874579313ab21d1018">ObjectBase</a> (const char* custom_type_name)</td></tr>
<tr class="memdesc:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">A derived constructor always overrides this choice.  <a href="classGio_1_1Socket.html#ad4ef18214894c6874579313ab21d1018">More...</a><br></br></td></tr>
<tr class="separator:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3d59b4d85b0ee72a727e6b2e1b31a2ff">ObjectBase</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01672.html">std::type_info</a>&amp; custom_type_info)</td></tr>
<tr class="memdesc:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft"> </td><td class="mdescRight">This constructor is a special feature to allow creation of derived types on the fly, without having to use g_object_new() manually.  <a href="classGio_1_1Socket.html#a3d59b4d85b0ee72a727e6b2e1b31a2ff">More...</a><br></br></td></tr>
<tr class="separator:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7e2e177061f6a6e09c4cf3da49c6dfd3 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a7e2e177061f6a6e09c4cf3da49c6dfd3">ObjectBase</a> (<a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a7e2e177061f6a6e09c4cf3da49c6dfd3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e968f118314ba4d5debfd2850d18003 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a2e968f118314ba4d5debfd2850d18003">operator=</a> (<a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a2e968f118314ba4d5debfd2850d18003 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae56ec45e9ebeaacf24be4fb54ed2eea3 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">virtual </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ae56ec45e9ebeaacf24be4fb54ed2eea3">~ObjectBase</a> () noexcept=0</td></tr>
<tr class="separator:ae56ec45e9ebeaacf24be4fb54ed2eea3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3faafb14c4f0ca60fbf0f5f5c4d549d0 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3faafb14c4f0ca60fbf0f5f5c4d549d0">initialize</a> (GObject* castitem)</td></tr>
<tr class="separator:a3faafb14c4f0ca60fbf0f5f5c4d549d0 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a44ddc123cd98ed0083aa06364365c8d3 inherit pro_methods_classGlib_1_1ObjectBase"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a44ddc123cd98ed0083aa06364365c8d3">initialize_move</a> (GObject* castitem, <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a>* previous_wrapper)</td></tr>
<tr class="separator:a44ddc123cd98ed0083aa06364365c8d3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header pro_methods_classGio_1_1Initable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGio_1_1Initable')"><img alt="-" src="closed.png"></img> Protected Member Functions inherited from <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a></td></tr>
<tr class="memitem:a239fb2aa148d653d534db5581d72c348 inherit pro_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a239fb2aa148d653d534db5581d72c348">Initable</a> ()</td></tr>
<tr class="memdesc:a239fb2aa148d653d534db5581d72c348 inherit pro_methods_classGio_1_1Initable"><td class="mdescLeft"> </td><td class="mdescRight">You should derive from this class to use it.  <a href="classGio_1_1Socket.html#a239fb2aa148d653d534db5581d72c348">More...</a><br></br></td></tr>
<tr class="separator:a239fb2aa148d653d534db5581d72c348 inherit pro_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7dbee3b8e980bf52ae2a66e1523127a3 inherit pro_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a7dbee3b8e980bf52ae2a66e1523127a3">init</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a7dbee3b8e980bf52ae2a66e1523127a3 inherit pro_methods_classGio_1_1Initable"><td class="mdescLeft"> </td><td class="mdescRight">Initializes the object implementing the interface.  <a href="classGio_1_1Socket.html#a7dbee3b8e980bf52ae2a66e1523127a3">More...</a><br></br></td></tr>
<tr class="separator:a7dbee3b8e980bf52ae2a66e1523127a3 inherit pro_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5881cf9c259d5af218585b7ecde38464 inherit pro_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a5881cf9c259d5af218585b7ecde38464">init</a> ()</td></tr>
<tr class="memdesc:a5881cf9c259d5af218585b7ecde38464 inherit pro_methods_classGio_1_1Initable"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classGio_1_1Initable.html#a5881cf9c259d5af218585b7ecde38464" title="A init() convenience overload. ">init()</a> convenience overload.  <a href="classGio_1_1Socket.html#a5881cf9c259d5af218585b7ecde38464">More...</a><br></br></td></tr>
<tr class="separator:a5881cf9c259d5af218585b7ecde38464 inherit pro_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a53c86a53352ecda8bca80d5132e4e99c inherit pro_methods_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top">virtual bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a53c86a53352ecda8bca80d5132e4e99c">init_vfunc</a> (const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, GError** error)</td></tr>
<tr class="separator:a53c86a53352ecda8bca80d5132e4e99c inherit pro_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4b4f2145105f84580f0a2659a9e8e5db"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Gio::Socket</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4b4f2145105f84580f0a2659a9e8e5db">wrap</a> (GSocket* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a4b4f2145105f84580f0a2659a9e8e5db"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="classGio_1_1Socket.html#a4b4f2145105f84580f0a2659a9e8e5db">More...</a><br></br></td></tr>
<tr class="separator:a4b4f2145105f84580f0a2659a9e8e5db"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header related_classGlib_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('related_classGlib_1_1Object')"><img alt="-" src="closed.png"></img> Related Functions inherited from <a class="el" href="classGlib_1_1Object.html">Glib::Object</a></td></tr>
<tr class="memitem:ae4dea9a8dc611d6e4400a5b6a3cb4e7f inherit related_classGlib_1_1Object"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#ae4dea9a8dc611d6e4400a5b6a3cb4e7f">wrap</a> (GObject* object, bool take_copy=false)</td></tr>
<tr class="separator:ae4dea9a8dc611d6e4400a5b6a3cb4e7f inherit related_classGlib_1_1Object"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="inherit_header related_classGio_1_1Initable"><td colspan="2" onclick="javascript:toggleInherit('related_classGio_1_1Initable')"><img alt="-" src="closed.png"></img> Related Functions inherited from <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a></td></tr>
<tr class="memitem:a9a2f7929de61e6b32a2317fe0ebde865 inherit related_classGio_1_1Initable"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a9a2f7929de61e6b32a2317fe0ebde865">wrap</a> (GInitable* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a9a2f7929de61e6b32a2317fe0ebde865 inherit related_classGio_1_1Initable"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="classGio_1_1Socket.html#a9a2f7929de61e6b32a2317fe0ebde865">More...</a><br></br></td></tr>
<tr class="separator:a9a2f7929de61e6b32a2317fe0ebde865 inherit related_classGio_1_1Initable"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low-level socket object. </p>
<p>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> is a low-level networking primitive. It is a more or less direct mapping of the BSD socket API in a portable GObject based API. It supports both the UNIX socket implementations and winsock2 on Windows.</p>
<p><a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> is the platform independent base upon which the higher level network primitives are based. Applications are not typically meant to use it directly, but rather through classes like <a class="el" href="classGio_1_1SocketClient.html" title="Helper for connecting to a network service. ">SocketClient</a>, <a class="el" href="classGio_1_1SocketService.html" title="Make it easy to implement a network service. ">SocketService</a> and <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection. ">SocketConnection</a>. However there may be cases where direct use of <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> is useful.</p>
<p><a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> implements the <a class="el" href="classGio_1_1Initable.html" title="Failable object initialization interface. ">Initable</a> interface, and since initialization can fail, the constructor may throw an exception.</p>
<p>Sockets operate in two general modes, blocking or non-blocking. When in blocking mode all operations block until the requested operation is finished or there is an error. In non-blocking mode all calls that would block return immediately with a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa82d49f23243e248a965673ef9a18fcd" title="Operation would block. ">Gio::Error::WOULD_BLOCK</a> error. To know when a call would successfully run you can call <a class="el" href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec" title="Checks on the readiness of socket to perform operations. ">condition_check()</a>, or <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36" title="Waits for condition to become true on socket. ">condition_wait()</a>. You can also use <a class="el" href="classGio_1_1Socket.html#ae610eb0842fe6fd32a8a1798fb0e305d" title="Creates a SocketSource that can be attached to a Glib::MainContext to monitor for the availability of...">create_source()</a> and attach it to a <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">Glib::MainContext</a> to get callbacks when I/O is possible. Note that all sockets are always set to non blocking mode in the system, and blocking mode is emulated in <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a>.</p>
<p>When working in non-blocking mode applications should always be able to handle getting a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa82d49f23243e248a965673ef9a18fcd" title="Operation would block. ">Gio::Error::WOULD_BLOCK</a> error even when some other function said that I/O was possible. This can easily happen in case of a race condition in the application, but it can also happen for other reasons. For instance, on Windows a socket is always seen as writable until a write returns <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa82d49f23243e248a965673ef9a18fcd" title="Operation would block. ">Gio::Error::WOULD_BLOCK</a>.</p>
<p>Sockets can be either connection oriented or datagram based. For connection oriented types you must first establish a connection by either connecting to an address or accepting a connection from another address. For connectionless socket types the target/source address is specified or received in each I/O operation.</p>
<p>All socket file descriptors are set to be close-on-exec.</p>
<p>Note that creating a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> causes the signal SIGPIPE to be ignored for the remainder of the program. If you are writing a command-line utility that uses <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a>, you may need to take into account the fact that your program will not automatically be killed if it tries to write to stdout after it has been closed.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000088">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a87a644ad422b1b809acad72e38829fb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gio::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGio_1_1Socket.html">Socket</a>&amp;&amp; </td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a41175831b614d34f1addca9e14406156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gio::Socket::~Socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac4d8110044fe1ae3d3b6d339f62b20a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gio::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> </td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gae7e2589ae30817878ac885a60b0d1461">Type</a> </td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830">Protocol</a> </td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a74d7c4338fcf53743f23926fccc8c6d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gio::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a137ae34a8f211eaed11f9a58ca6b3f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::accept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Accept incoming connections on a connection-based socket. </p>
<p>This removes the first outstanding connection request from the listening socket and creates a GSocket object for it.</p>
<p>The socket must be bound to a local address with g_socket_bind() and must be listening for incoming connections (<a class="el" href="classGio_1_1Socket.html#af16eed3fd42f3769b5e608f96db214fd" title="Marks the socket as a server socket - a socket that is used to accept incoming requests using Socket:...">Socket::listen()</a>).</p>
<p>If there are no outstanding connections then the operation will block or throw <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be notified of an incoming connection, wait for the Glib::IO_IN condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Gio::Socket</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b6c036db4e484e6b7f0419962254888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::accept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888" title="A accept() convenience overload. ">accept()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a16044bba5924c183cff90f0a4cf47394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>allow_reuse</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>When a socket is created it is attached to an address family, but it doesn't have an address in this family. </p>
<p><a class="el" href="classGio_1_1Socket.html#a16044bba5924c183cff90f0a4cf47394" title="When a socket is created it is attached to an address family, but it doesn't have an address in this ...">Socket::bind()</a> assigns the address (sometimes called name) of the socket.</p>
<p>It is generally required to bind to a local address before you can receive connections. (See <a class="el" href="classGio_1_1Socket.html#af16eed3fd42f3769b5e608f96db214fd" title="Marks the socket as a server socket - a socket that is used to accept incoming requests using Socket:...">Socket::listen()</a> and <a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888" title="A accept() convenience overload. ">Socket::accept()</a>). In certain situations, you may also want to bind a socket that will be used to initiate connections, though this is not normally required.</p>
<p>If socket is a TCP socket, then <em>allow_reuse</em> controls the setting of the SO_REUSEADDR socket option; normally it should be <code>true</code> for server sockets (sockets that you will eventually call <a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888" title="A accept() convenience overload. ">Socket::accept()</a> on), and <code>false</code> for client sockets. (Failing to set this flag on a server socket may cause <a class="el" href="classGio_1_1Socket.html#a16044bba5924c183cff90f0a4cf47394" title="When a socket is created it is attached to an address family, but it doesn't have an address in this ...">Socket::bind()</a> to throw <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with ADDRESS_IN_USE if the server program is stopped and then immediately restarted.)</p>
<p>If socket is a UDP socket, then <em>allow_reuse</em> determines whether or not other UDP sockets can be bound to the same address at the same time. In particular, you can have several UDP sockets bound to the same address, and they will all receive all of the multicast and broadcast packets sent to that address. (The behavior of unicast UDP packets to an address with multiple listeners is not defined.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">address</td><td>a <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication. ">SocketAddress</a> specifying the local address. </td></tr>
    <tr><td class="paramname">allow_reuse</td><td>whether to allow reusing this address</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06b68dc0948e6dfa158487c314f9a521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::check_connect_result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks and resets the pending connect error for the socket. </p>
<p>This is used to check for errors when g_socket_connect() is used in non-blocking mode.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000105">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab30d39b9e73fef6401c76d1d4edc118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Closes the socket, shutting down any active connection. </p>
<p>Closing a socket does not wait for all outstanding I/O operations to finish, so the caller should not rely on them to be guaranteed to complete even if the close returns with no error.</p>
<p>Once the socket is closed, all other operations will return <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa6a502e9ed81ddc95d135b773d3aa23e" title="File was closed. ">Gio::Error::CLOSED</a>. Closing a socket multiple times will not return an error.</p>
<p>Sockets will be automatically closed when the last reference is dropped, but you might want to call this function to make sure resources are released as early as possible.</p>
<p>Beware that due to the way that TCP works, it is possible for recently-sent data to be lost if either you close a socket while the Glib::IOCondition::IN condition is set, or else if the remote connection tries to send something to you after you close the socket but before it has finished reading all of the data you sent. There is no easy generic way to avoid this problem; the easiest fix is to design the network protocol such that the client will never send data "out of turn". Another solution is for the server to half-close the connection by calling g_socket_shutdown() with only the <em>shutdown_write</em> flag set, and then wait for the client to notice this and close its side of the connection, after which the server can safely call g_socket_close(). (This is what <a class="el" href="classGio_1_1TcpConnection.html" title="A TCP SocketConnection. ">TcpConnection</a> does if you call g_tcp_connection_set_graceful_disconnect(). But of course, this only works if the client will close its connection after the server does.)</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000109">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86fdc5d814fd61abab15ec03c7da20ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> Gio::Socket::condition_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> </td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks on the readiness of <em>socket</em> to perform operations. </p>
<p>The operations specified in <em>condition</em> are checked for and masked against the currently-satisfied conditions on <em>socket</em>. The result is returned.</p>
<p>Note that on Windows, it is possible for an operation to return <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa82d49f23243e248a965673ef9a18fcd" title="Operation would block. ">Gio::Error::WOULD_BLOCK</a> even immediately after g_socket_condition_check() has claimed that the socket is ready for writing. Rather than calling g_socket_condition_check() and then writing to the socket if it succeeds, it is generally better to simply try writing to the socket right away, and try again later if the initial attempt returns <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa82d49f23243e248a965673ef9a18fcd" title="Operation would block. ">Gio::Error::WOULD_BLOCK</a>.</p>
<p>It is meaningless to specify Glib::IOCondition::ERR or Glib::IOCondition::HUP in condition; these conditions will always be set in the output if they are true.</p>
<p>This call never blocks.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000113">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">condition</td><td>A IOCondition mask to check. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>GIOCondition</em> mask of the current state. </dd></dl>

</div>
</div>
<a class="anchor" id="addb32e1cc859b9689bf10169dfd70a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::condition_timed_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> </td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64 </td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Waits for up to <em>timeout</em> microseconds for <em>condition</em> to become true on <em>socket</em>. </p>
<p>If the condition is met, <code>true</code> is returned.</p>
<p>If <em>cancellable</em> is cancelled before the condition is met, or if <em>timeout</em> (or the socket's <a class="el" href="classGio_1_1Socket.html#a4042172bae49d0a2721546e31141d572" title="The timeout in seconds on socket I/O. ">Socket::property_timeout()</a>) is reached before the condition is met, then <code>false</code> is returned and <em>error</em>, if non-<code>nullptr</code>, is set to the appropriate value (<a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a708f6079268ad1a626c248ace401b899" title="Operation was cancelled. ">Gio::Error::CANCELLED</a> or <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134ad9be2d9a98ef25458c32ac424264d963" title="Operation timed out. ">Gio::Error::TIMED_OUT</a>).</p>
<p>If you don't want a timeout, use g_socket_condition_wait(). (Alternatively, you can pass -1 for <em>timeout</em>.)</p>
<p>Note that although <em>timeout</em> is in microseconds for consistency with other GLib APIs, this function actually only has millisecond resolution, and the behavior is undefined if <em>timeout</em> is not an exact number of milliseconds.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000104">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">condition</td><td>A IOCondition mask to wait for. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum time (in microseconds) to wait, or -1. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a>, or <code>nullptr</code>.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71a3736a74c730c76e7c9a1670c3fbdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::condition_timed_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> </td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64 </td>
          <td class="paramname"><em>timeout</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#addb32e1cc859b9689bf10169dfd70a9c" title="Waits for up to timeout microseconds for condition to become true on socket. ">condition_timed_wait()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="aaae28fa63035c05396064f5f4bb4fc36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::condition_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> </td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Waits for <em>condition</em> to become true on <em>socket</em>. </p>
<p>When the condition is met, <code>true</code> is returned.</p>
<p>If <em>cancellable</em> is cancelled before the condition is met, or if the socket has a timeout set and it is reached before the condition is met, then <code>false</code> is returned and <em>error</em>, if non-<code>nullptr</code>, is set to the appropriate value (<a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a708f6079268ad1a626c248ace401b899" title="Operation was cancelled. ">Gio::Error::CANCELLED</a> or <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134ad9be2d9a98ef25458c32ac424264d963" title="Operation timed out. ">Gio::Error::TIMED_OUT</a>).</p>
<p>See also g_socket_condition_timed_wait().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000114">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">condition</td><td>A IOCondition mask to wait for. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a>, or <code>nullptr</code>.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ae420715a2050cc09112f178bae88ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::condition_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> </td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36" title="Waits for condition to become true on socket. ">condition_wait()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a9ab220f5714a6116d35e846b00f4ad23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Connect the socket to the specified remote address. </p>
<p>For connection oriented socket this generally means we attempt to make a connection to the address . For a connection-less socket it sets the default address for <a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c" title="Tries to send size bytes from buffer on the socket. ">Socket::send()</a> and discards all incoming datagrams from other sources.</p>
<p>Generally connection oriented sockets can only connect once, but connection-less sockets can connect multiple times to change the default address.</p>
<p>If the connect call needs to do network I/O it will block, unless non-blocking I/O is enabled. Then <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with ERROR_PENDING is thrown and the user can be notified of the connection finishing by waiting for the Glib::IO_OUT condition. The result of the connection must then be checked with <a class="el" href="classGio_1_1Socket.html#a06b68dc0948e6dfa158487c314f9a521" title="Checks and resets the pending connect error for the socket. ">Socket::check_connect_result()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">address</td><td>a <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication. ">SocketAddress</a> specifying the remote address. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0828763fe472d46aed833fad30af1c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23" title="Connect the socket to the specified remote address. ">connect()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a226dbeb21a3f42bd976025cb58d682f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> </td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gae7e2589ae30817878ac885a60b0d1461">Type</a> </td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830">Protocol</a> </td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> with the defined family, type and protocol. </p>
<p>If <em>protocol</em> is 0 (<a class="el" href="classGio_1_1Socket.html#ga7a8e15d48d30611ccbdf260950057830a5b39c8b553c821e7cddc6da64b5bd2ee" title="The default protocol for the family/type. ">Gio::Socket::Protocol::DEFAULT</a>) the default protocol type for the family and type is used.</p>
<p>The <em>protocol</em> is a family and type specific int that specifies what kind of protocol to use. <a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830" title="A protocol identifier is specified when creating a Socket, which is a family/type specific identifier...">Gio::Socket::Protocol</a> lists several common ones. Many families only support one protocol, and use 0 for this, others support several and using 0 means to use the default protocol for the family and type.</p>
<p>The protocol id is passed directly to the operating system, so you can use protocols not listed in <a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830" title="A protocol identifier is specified when creating a Socket, which is a family/type specific identifier...">Gio::Socket::Protocol</a> if you know the protocol number used for it.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000103">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">family</td><td>The socket family to use, e.g. <a class="el" href="namespaceGio.html#ga0ba69e14ad979bf9b2073ad122e38d48ae638ca944d27f97f46a5986a5aa53434" title="The IPv4 family. ">Gio::SocketFamily::IPV4</a>. </td></tr>
    <tr><td class="paramname">type</td><td>The socket type to use. </td></tr>
    <tr><td class="paramname">protocol</td><td>The id of the protocol to use, or 0 for default. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2857fe57a2460b8c0f6a187159038672"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::create_from_fd </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> from a native file descriptor or winsock SOCKET handle. </p>
<p>This reads all the settings from the file descriptor so that all properties should work. Note that the file descriptor will be set to non-blocking mode, independent on the blocking mode of the <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a>.</p>
<p>On success, the returned <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> takes ownership of <em>fd</em>. On failure, the caller must close <em>fd</em> themselves.</p>
<p>Since GLib 2.46, it is no longer a fatal error to call this on a non-socket descriptor. Instead, a GError will be set with code <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa0e791aa4861a641bfc653f3856328df" title="Generic error condition for when an operation fails and no more specific Gio::Error value is defined...">Gio::Error::FAILED</a></p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000104">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">fd</td><td>A native socket file descriptor. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae610eb0842fe6fd32a8a1798fb0e305d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketSource.html">SocketSource</a>&gt; Gio::Socket::create_source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> </td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classGio_1_1SocketSource.html" title="An event source that can monitor a Gio::Socket. ">SocketSource</a> that can be attached to a <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">Glib::MainContext</a> to monitor for the availability of the specified <em>condition</em> on the socket. </p>
<p>Create a slot from a function to be called when <em>condition</em> is met for the socket with <a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/group__ptr__fun.html#ga90d9748e4be611e80869c0a6a8d8e62a">sigc::ptr_fun()</a> or <a class="elRef" doxygen="libsigc++-3.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/group__mem__fun.html#ga5d28dcf1bb88830a6e50d08d1fe7ec08">sigc::mem_fun()</a> and pass it into the <a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23" title="Connect the socket to the specified remote address. ">connect()</a> function of the returned <a class="el" href="classGio_1_1SocketSource.html" title="An event source that can monitor a Gio::Socket. ">SocketSource</a> object. Polling of the socket will start when you attach a <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">Glib::MainContext</a> object to the returned <a class="el" href="classGio_1_1SocketSource.html" title="An event source that can monitor a Gio::Socket. ">SocketSource</a> object using its attach() function.</p>
<p>It is meaningless to specify Glib::IO_ERR or Glib::IO_HUP in <em>condition</em>; these conditions will always be reported output if they are true.</p>
<p><em>cancellable</em> can be used to cancel the source, which will cause the source to trigger, reporting the current condition (which is likely 0 unless cancellation happened at the same time as a condition change). You can check for this in the callback using <a class="el" href="classGio_1_1Cancellable.html#a47ce5f2f16541b7ae18bc5114b366d8c" title="Checks if a cancellable job has been cancelled. ">Cancellable::is_cancelled()</a>.</p>
<p>If the socket has a timeout set, and it is reached before <em>condition</em> occurs, the source will then trigger anyway, reporting Glib::IO_IN or Glib::IO_OUT depending on <em>condition</em>. However, the socket will have been marked as having had a timeout, and so the next <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> I/O method you call will then fail with a Gio::IO_ERROR_TIMED_OUT.</p>
<p><a class="el" href="group__NetworkIO.html#ga3a51a5ce257882e0cd41ead1081a5655" title="Convenience socket signal. ">Gio::signal_socket()</a>.<a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23" title="Connect the socket to the specified remote address. ">connect()</a> is a simpler interface to the same functionality.</p>
<dl class="since_2_42"><dt><b><a class="el" href="since_2_42.html#_since_2_42000017">Since glibmm 2.42:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">condition</td><td>A <a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918" title="A bitwise combination representing an I/O condition to watch for on an event source. ">Glib::IOCondition</a> mask to monitor. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a>. The default value means the source is not cancellable. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated <a class="el" href="classGio_1_1SocketSource.html" title="An event source that can monitor a Gio::Socket. ">SocketSource</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3cd0af5978112d1c8e2e68e51c9b99c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::get_available_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the amount of data pending in the OS input buffer, without blocking. </p>
<p>If <em>socket</em> is a UDP or SCTP socket, this will return the size of just the next packet, even if additional packets are buffered after that one.</p>
<p>Note that on Windows, this function is rather inefficient in the UDP case, and so if you know any plausible upper bound on the size of the incoming packet, it is better to just do a g_socket_receive() with a buffer of that size, rather than calling g_socket_get_available_bytes() first and then doing a receive of exactly the right size.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000103">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that can be read from the socket without blocking or truncating, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ffcbc226b08ae14856ea0dfe4d580e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::get_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the blocking mode of the socket. </p>
<p>For details on blocking I/O, see g_socket_set_blocking().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000118">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if blocking I/O is used, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a766a2e06ff796c80c42147dfb3e85366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::get_broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the broadcast setting on <em>socket</em>; if <code>true</code>, it is possible to send packets to broadcast addresses. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000107">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The broadcast setting on <em>socket</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fcda0eba8fcb30bd020624ce3f14d8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Credentials.html">Credentials</a>&gt; Gio::Socket::get_credentials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for <a class="el" href="namespaceGio.html#ga0ba69e14ad979bf9b2073ad122e38d48a15395d0642f86c5992abbca5e56e2b29" title="The UNIX domain family. ">Gio::SocketFamily::UNIX</a> sockets). </p>
<p>If this operation isn't supported on the OS, the method fails with the <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134ae71d1cb1e1e36c3653f1a4f176ec3459" title="Operation (or one of its parameters) not supported. ">Gio::Error::NOT_SUPPORTED</a> error. On Linux this is implemented by reading the SO_PEERCRED option on the underlying socket.</p>
<p>This method can be expected to be available on the following platforms:</p>
<ul>
<li>Linux since GLib 2.26</li>
<li>OpenBSD since GLib 2.30</li>
<li>Solaris, Illumos and OpenSolaris since GLib 2.40</li>
<li>NetBSD since GLib 2.42</li>
<li>macOS, tvOS, iOS since GLib 2.66</li>
</ul>
<p>Other ways to obtain credentials from a foreign peer includes the <a class="el" href="classGio_1_1UnixCredentialsMessage.html" title="UnixCredentialsMessage - A SocketControlMessage containing credentials. ">UnixCredentialsMessage</a> type and g_unix_connection_send_credentials() / g_unix_connection_receive_credentials() functions.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000308">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if <em>error</em> is set, otherwise a <a class="el" href="classGio_1_1Credentials.html" title="An object containing credentials. ">Credentials</a> object that must be freed with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcc5b5f562eb0255d846a41bde23d0f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;const <a class="el" href="classGio_1_1Credentials.html">Credentials</a>&gt; Gio::Socket::get_credentials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for <a class="el" href="namespaceGio.html#ga0ba69e14ad979bf9b2073ad122e38d48a15395d0642f86c5992abbca5e56e2b29" title="The UNIX domain family. ">Gio::SocketFamily::UNIX</a> sockets). </p>
<p>If this operation isn't supported on the OS, the method fails with the <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134ae71d1cb1e1e36c3653f1a4f176ec3459" title="Operation (or one of its parameters) not supported. ">Gio::Error::NOT_SUPPORTED</a> error. On Linux this is implemented by reading the SO_PEERCRED option on the underlying socket.</p>
<p>This method can be expected to be available on the following platforms:</p>
<ul>
<li>Linux since GLib 2.26</li>
<li>OpenBSD since GLib 2.30</li>
<li>Solaris, Illumos and OpenSolaris since GLib 2.40</li>
<li>NetBSD since GLib 2.42</li>
<li>macOS, tvOS, iOS since GLib 2.66</li>
</ul>
<p>Other ways to obtain credentials from a foreign peer includes the <a class="el" href="classGio_1_1UnixCredentialsMessage.html" title="UnixCredentialsMessage - A SocketControlMessage containing credentials. ">UnixCredentialsMessage</a> type and g_unix_connection_send_credentials() / g_unix_connection_receive_credentials() functions.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000309">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if <em>error</em> is set, otherwise a <a class="el" href="classGio_1_1Credentials.html" title="An object containing credentials. ">Credentials</a> object that must be freed with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac1e2a576e62d1e339eefae1fe12e24b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> Gio::Socket::get_family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the socket family of the socket. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000121">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A SocketFamily. </dd></dl>

</div>
</div>
<a class="anchor" id="af3bb5076efcb022e31db9622a1c6e0ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gio::Socket::get_fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the underlying OS socket object. </p>
<p>On unix this is a socket file descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be useful for doing platform specific or otherwise unusual operations on the socket.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000122">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The file descriptor of the socket. </dd></dl>

</div>
</div>
<a class="anchor" id="a530b4adc3d295f7c000981286dee8019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::get_keepalive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the keepalive mode of the socket. </p>
<p>For details on this, see g_socket_set_keepalive().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000120">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if keepalive is active, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a22a9e70db9abc7fc6383641afde8ee6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gio::Socket::get_listen_backlog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the listen backlog setting of the socket. </p>
<p>For details on this, see g_socket_set_listen_backlog().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000116">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of pending connections. </dd></dl>

</div>
</div>
<a class="anchor" id="a654e36f8577b61a4df93a0a70479a7f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; Gio::Socket::get_local_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Try to get the local address of a bound socket. </p>
<p>This is only useful if the socket has been bound to a local address, either explicitly or implicitly when connecting.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000123">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication. ">SocketAddress</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3aa1d5519cde6e690e7d939b8ec79537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::get_multicast_loopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the multicast loopback setting on <em>socket</em>; if <code>true</code> (the default), outgoing multicast packets will be looped back to multicast listeners on the same host. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000109">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The multicast loopback setting on <em>socket</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a750debbc865bf9e6d8fb9b950c04dd67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">guint Gio::Socket::get_multicast_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the multicast time-to-live setting on <em>socket</em>; see g_socket_set_multicast_ttl() for more details. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000111">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The multicast time-to-live setting on <em>socket</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae797a60397ec1035d07e625cc3bc423c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::get_option </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>value</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the value of an integer-valued option on <em>socket</em>, as with getsockopt(). </p>
<p>(If you need to fetch a non-integer-valued option, you will need to call getsockopt() directly.)</p>
<p>The [&lt;gio/gnetworking.h&gt;][gio-gnetworking.h] header pulls in system headers that will define most of the standard/portable socket options. For unusual socket protocols or platform-dependent options, you may need to include additional headers.</p>
<p>Note that even for socket options that are a single byte in size, <em>value</em> is still a pointer to a <code>int</code> variable, not a #guchar; g_socket_get_option() will handle the conversion internally.</p>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000022">Since glibmm 2.36:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">level</td><td>The "API level" of the option (eg, <code>SOL_SOCKET</code>). </td></tr>
    <tr><td class="paramname">optname</td><td>The "name" of the option (eg, <code>SO_BROADCAST</code>). </td></tr>
    <tr><td class="paramname">value</td><td>Return location for the option value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success or failure. On failure, <em>error</em> will be set, and the system error value (<code>errno</code> or WSAGetLastError()) will still be set to the result of the getsockopt() call.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e73efd467d330cfee9cb01e19e1096e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830">Protocol</a> Gio::Socket::get_protocol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the socket protocol id the socket was created with. </p>
<p>In case the protocol is unknown, -1 is returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000125">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A protocol id, or -1 if unknown. </dd></dl>

</div>
</div>
<a class="anchor" id="adce45788b8ac674bdf32a3ec8fb683c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; Gio::Socket::get_remote_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Try to get the remote address of a connected socket. </p>
<p>This is only useful for connection oriented sockets that have been connected.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000124">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication. ">SocketAddress</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a55488fb77aa3c5c0f70ed036428f4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#gae7e2589ae30817878ac885a60b0d1461">Type</a> Gio::Socket::get_socket_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the socket type of the socket. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000126">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="group__giommEnums.html#gae7e2589ae30817878ac885a60b0d1461" title="Flags used when creating a Socket. ">Gio::Socket::Type</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c05cab954287b392d6c60bc347ca5d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">guint Gio::Socket::get_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the timeout setting of the socket. </p>
<p>For details on this, see g_socket_set_timeout().</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000310">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The timeout in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a8161abb1b8367aed9502d48be2d94172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">guint Gio::Socket::get_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gets the unicast time-to-live setting on <em>socket</em>; see g_socket_set_ttl() for more details. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000105">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The time-to-live setting on <em>socket</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a175fe732c02ea3e861a86e6c7d690ba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static GType Gio::Socket::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get the GType for this class, for use with the underlying GObject type system. </p>

</div>
</div>
<a class="anchor" id="a1d51f7bcd83450331d7261898e9007d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">GSocket* Gio::Socket::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a class="anchor" id="a51c7fa832ce1c984a7bbceb4d7ba93a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const GSocket* Gio::Socket::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a class="anchor" id="ae2fe06b1a579c40b596933da0ded4e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">GSocket* Gio::Socket::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a7ac925f7e6592ad4a96afe0f75411a96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::is_closed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks whether a socket is closed. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000110">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if socket is closed, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aea9561511b77e652271705fbfdb2f8f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::is_connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Check whether the socket is connected. </p>
<p>This is only useful for connection-oriented sockets.</p>
<p>If using g_socket_shutdown(), this function will return <code>true</code> until the socket has been shut down for reading and writing. If you do a non-blocking connect, this function will not return <code>true</code> until after you call g_socket_check_connect_result().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000112">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if socket is connected, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afded8c4757a4f2f8a89b6550e48531db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::join_multicast_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>source_specific</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>iface</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Registers <em>socket</em> to receive multicast messages sent to <em>group</em>. </p>
<p><em>socket</em> must be a <a class="el" href="classGio_1_1Socket.html#gae7e2589ae30817878ac885a60b0d1461a77531d7905cb7b4e343ca868f98312f3" title="Connectionless, unreliable datagram passing. ">Gio::Socket::Type::DATAGRAM</a> socket, and must have been bound to an appropriate interface and port with g_socket_bind().</p>
<p>If <em>iface</em> is <code>nullptr</code>, the system will automatically pick an interface to bind to based on <em>group</em>.</p>
<p>If <em>source_specific</em> is <code>true</code>, source-specific multicast as defined in RFC 4604 is used. Note that on older platforms this may fail with a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134ae71d1cb1e1e36c3653f1a4f176ec3459" title="Operation (or one of its parameters) not supported. ">Gio::Error::NOT_SUPPORTED</a> error.</p>
<p>To bind to a given source-specific multicast address, use g_socket_join_multicast_group_ssm() instead.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000113">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">group</td><td>A <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address. ">InetAddress</a> specifying the group address to join. </td></tr>
    <tr><td class="paramname">iface</td><td>Name of the interface to use, or <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">source_specific</td><td><code>true</code> if source-specific multicast should be used. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8db138a424b8b2ab26d62a9ef2b29656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::join_multicast_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>source_specific</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#afded8c4757a4f2f8a89b6550e48531db" title="Registers socket to receive multicast messages sent to group. ">join_multicast_group()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a5c7e7ee9703f5f92dafa0a49cc47ca91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::leave_multicast_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>source_specific</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01512.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp; </td>
          <td class="paramname"><em>iface</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Removes <em>socket</em> from the multicast group defined by <em>group</em>, <em>iface</em>, and <em>source_specific</em> (which must all have the same values they had when you joined the group). </p>
<p><em>socket</em> remains bound to its address and port, and can still receive unicast messages after calling this.</p>
<p>To unbind to a given source-specific multicast address, use g_socket_leave_multicast_group_ssm() instead.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000114">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">group</td><td>A <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address. ">InetAddress</a> specifying the group address to leave. </td></tr>
    <tr><td class="paramname">iface</td><td>Interface used. </td></tr>
    <tr><td class="paramname">source_specific</td><td><code>true</code> if source-specific multicast was used. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6648bc6b4d15ac95903ff47bb8e140f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::leave_multicast_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>source_specific</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a5c7e7ee9703f5f92dafa0a49cc47ca91" title="Removes socket from the multicast group defined by group, iface, and source_specific (which must all ...">leave_multicast_group()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="af16eed3fd42f3769b5e608f96db214fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::listen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Marks the socket as a server socket - a socket that is used to accept incoming requests using <a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888" title="A accept() convenience overload. ">Socket::accept()</a>. </p>
<p>Before calling this the socket must be bound to a local address using <a class="el" href="classGio_1_1Socket.html#a16044bba5924c183cff90f0a4cf47394" title="When a socket is created it is attached to an address family, but it doesn't have an address in this ...">Socket::bind()</a>.</p>
<p>To set the maximum amount of outstanding clients, use <a class="el" href="classGio_1_1Socket.html#adc7b9d6cecc1c2234f9979b2ffb1b309" title="Sets the maximum number of outstanding connections allowed when listening on this socket...">Socket::set_listen_backlog()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab713c206146db8f718377e4cd3609c27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGio_1_1Socket.html">Socket</a>&amp; Gio::Socket::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGio_1_1Socket.html">Socket</a>&amp;&amp; </td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a33e80070bf40ed9bff3d6e82fd6bc403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; Gio::Socket::property_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Whether or not I/O on this socket is blocking. </p>
<p>Default value: <code>true</code></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d697455cc099f37e06550d9a6b244c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; Gio::Socket::property_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Whether or not I/O on this socket is blocking. </p>
<p>Default value: <code>true</code></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a870a59c1f58b2c4b28aa402e7c824cf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; Gio::Socket::property_broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Whether the socket should allow sending to broadcast addresses. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000115">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<p>Default value: <code>false</code></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa74338dcee4fb6ef6e3d3db36e0a6347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; Gio::Socket::property_broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Whether the socket should allow sending to broadcast addresses. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000116">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<p>Default value: <code>false</code></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a83a9ca8602e7d1c500cf9f4f4ab45aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> &gt; Gio::Socket::property_family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>The sockets address family. </p>
<p>Default value: <a class="el" href="namespaceGio.html#ga0ba69e14ad979bf9b2073ad122e38d48accc0377a8afbf50e7094f5c23a8af223" title="No address family. ">Gio::SocketFamily::INVALID</a></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a92f0ebc8891cdcccf8e16d0845921beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt; Gio::Socket::property_fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>The sockets file descriptor. </p>
<p>Default value: -1</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aab16cc7a80fbbf288732298017f21a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; Gio::Socket::property_keepalive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Keep connection alive by sending periodic pings. </p>
<p>Default value: <code>false</code></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a545a19bc5664e66900d1ca8c29f7d0e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; Gio::Socket::property_keepalive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Keep connection alive by sending periodic pings. </p>
<p>Default value: <code>false</code></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c7ef3aff95f2f829af2d3ce2ef36836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; int &gt; Gio::Socket::property_listen_backlog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Outstanding connections in the listen queue. </p>
<p>Default value: 10</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ad08f21c5f7bd408e63815581bbfb48ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt; Gio::Socket::property_listen_backlog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Outstanding connections in the listen queue. </p>
<p>Default value: 10</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ac52bc9e13993758922ce0d3683f336af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; &gt; Gio::Socket::property_local_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>The local address the socket is bound to. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a067aa46a4f9950001e56a315f4313add"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; Gio::Socket::property_multicast_loopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Whether outgoing multicast packets loop back to the local host. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000119">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<p>Default value: <code>true</code></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="abe4b46a4077d1889099cf2f11ba92a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; Gio::Socket::property_multicast_loopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Whether outgoing multicast packets loop back to the local host. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000120">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<p>Default value: <code>true</code></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a669af953e00f1041a0088e1da6c7787d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; Gio::Socket::property_multicast_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Time-to-live out outgoing multicast packets. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000121">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<p>Default value: 1</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a756aad409d9845505a20069923415179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; Gio::Socket::property_multicast_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Time-to-live out outgoing multicast packets. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000122">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<p>Default value: 1</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a251771227ec93ff3b4f98c6e747dd479"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga7a8e15d48d30611ccbdf260950057830">Protocol</a> &gt; Gio::Socket::property_protocol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>The id of the protocol to use, or -1 for unknown. </p>
<p>Default value: <a class="el" href="classGio_1_1Socket.html#ga7a8e15d48d30611ccbdf260950057830a696b031073e74bf2cb98e5ef201d4aa3" title="The protocol type is unknown. ">Gio::Socket::Protocol::UNKNOWN</a></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0affc1f63146a265a1d1c2b884091708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; &gt; Gio::Socket::property_remote_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>The remote address the socket is connected to. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a4042172bae49d0a2721546e31141d572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; Gio::Socket::property_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>The timeout in seconds on socket I/O. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000314">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<p>Default value: 0</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a19433af6a2d3b85920a709559d81e4a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; Gio::Socket::property_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>The timeout in seconds on socket I/O. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000315">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<p>Default value: 0</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7c54b763b8637fb06f4c03c4796e1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; Gio::Socket::property_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Time-to-live for outgoing unicast packets. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000117">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<p>Default value: 0</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aba76e739cbfd9a6bb69efa3a908b718f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; Gio::Socket::property_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Time-to-live for outgoing unicast packets. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000118">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<p>Default value: 0</p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="adeb2295f5040a0f8a4709c40fb38ec2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#gae7e2589ae30817878ac885a60b0d1461">Type</a> &gt; Gio::Socket::property_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>The sockets type. </p>
<p>Default value: <a class="el" href="classGio_1_1Socket.html#gae7e2589ae30817878ac885a60b0d1461a2f05998d2a71cdc19b7109549bbe2646" title="Reliable connection-based byte streams (e.g. ">Gio::Socket::Type::STREAM</a></p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a742403f4d076ba9050a435d95fea5d1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::receive </td>
          <td>(</td>
          <td class="paramtype">char * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Receive data (up to <em>size</em> bytes) from a socket. </p>
<p>This is mainly used by connection-oriented sockets; it is identical to g_socket_receive_from() with <em>address</em> set to <code>nullptr</code>.</p>
<p>For <a class="el" href="classGio_1_1Socket.html#gae7e2589ae30817878ac885a60b0d1461a77531d7905cb7b4e343ca868f98312f3" title="Connectionless, unreliable datagram passing. ">Gio::Socket::Type::DATAGRAM</a> and <a class="el" href="classGio_1_1Socket.html#gae7e2589ae30817878ac885a60b0d1461ab2b74031ec7ab401a06dc71d87906ed2" title="Reliable connection-based passing of datagrams of fixed maximum length (e.g. ">Gio::Socket::Type::SEQPACKET</a> sockets, g_socket_receive() will always read either 0 or 1 complete messages from the socket. If the received message is too large to fit in <em>buffer</em>, then the data beyond <em>size</em> bytes will be discarded, without any explicit indication that this has occurred.</p>
<p>For <a class="el" href="classGio_1_1Socket.html#gae7e2589ae30817878ac885a60b0d1461a2f05998d2a71cdc19b7109549bbe2646" title="Reliable connection-based byte streams (e.g. ">Gio::Socket::Type::STREAM</a> sockets, g_socket_receive() can return any number of bytes, up to <em>size</em>. If more than <em>size</em> bytes have been received, the additional data will be returned in future calls to g_socket_receive().</p>
<p>If the socket is in blocking mode the call will block until there is some data to receive, the connection is closed, or there is an error. If there is no data available and the socket is in non-blocking mode, a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa82d49f23243e248a965673ef9a18fcd" title="Operation would block. ">Gio::Error::WOULD_BLOCK</a> error will be returned. To be notified when data is available, wait for the Glib::IOCondition::IN condition.</p>
<p>On error -1 is returned and <em>error</em> is set accordingly.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000106">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least <em>size</em> bytes long). </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes you want to read from the socket. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73463b7677ffdfddaced49bdf170b4b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::receive </td>
          <td>(</td>
          <td class="paramtype">char * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c" title="Receive data (up to size bytes) from a socket. ">receive()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a4d2d4382139553881ae139920e8db93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::receive_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a056fd2c3609971d5befcf2b4ccf51aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::receive_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa22e284f58d0ee09b34644dbd0f291b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::receive_with_blocking </td>
          <td>(</td>
          <td class="paramtype">gchar * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This behaves exactly the same as g_socket_receive(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000312">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least <em>size</em> bytes long). </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes you want to read from the socket. </td></tr>
    <tr><td class="paramname">blocking</td><td>Whether to do blocking or non-blocking I/O. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="adc5c3145109841e0406150ad0b7f547c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::send </td>
          <td>(</td>
          <td class="paramtype">const gchar * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Tries to send <em>size</em> bytes from <em>buffer</em> on the socket. </p>
<p>This is mainly used by connection-oriented sockets; it is identical to g_socket_send_to() with <em>address</em> set to <code>nullptr</code>.</p>
<p>If the socket is in blocking mode the call will block until there is space for the data in the socket queue. If there is no space available and the socket is in non-blocking mode a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa82d49f23243e248a965673ef9a18fcd" title="Operation would block. ">Gio::Error::WOULD_BLOCK</a> error will be returned. To be notified when space is available, wait for the Glib::IOCondition::OUT condition. Note though that you may still receive <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa82d49f23243e248a965673ef9a18fcd" title="Operation would block. ">Gio::Error::WOULD_BLOCK</a> from g_socket_send() even if you were previously notified of a Glib::IOCondition::OUT condition. (On Windows in particular, this is very common due to the way the underlying APIs work.)</p>
<p>On error -1 is returned and <em>error</em> is set accordingly.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000107">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">buffer</td><td>The buffer containing the data to send. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a986efa2a33528ce5aba0d7c6a7be1b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::send </td>
          <td>(</td>
          <td class="paramtype">const gchar * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c" title="Tries to send size bytes from buffer on the socket. ">send()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a8b2d4ff883535e696b6cdaacd730f729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::send_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Tries to send <em>size</em> bytes from <em>buffer</em> to <em>address</em>. </p>
<p>If <em>address</em> is <code>nullptr</code> then the message is sent to the default receiver (set by g_socket_connect()).</p>
<p>See g_socket_send() for additional information.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000108">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">address</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication. ">SocketAddress</a>, or <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to send. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a929c8c4e0c10a39d65358853e94d9c4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::send_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; </td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729" title="Tries to send size bytes from buffer to address. ">send_to()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a02b6a6ca54619cf0a990ff9497eb9990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gssize Gio::Socket::send_with_blocking </td>
          <td>(</td>
          <td class="paramtype">gchar * </td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize </td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; </td>
          <td class="paramname"><em>cancellable</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This behaves exactly the same as g_socket_send(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000313">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">buffer</td><td>The buffer containing the data to send. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">blocking</td><td>Whether to do blocking or non-blocking I/O. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a51d5a174441c255b69be9e809cdb96b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::set_blocking </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>blocking</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets the blocking mode of the socket. </p>
<p>In blocking mode all operations (which don’t take an explicit blocking parameter) block until they succeed or there is an error. In non-blocking mode all functions return results immediately or with a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134aa82d49f23243e248a965673ef9a18fcd" title="Operation would block. ">Gio::Error::WOULD_BLOCK</a> error.</p>
<p>All sockets are created in blocking mode. However, note that the platform level socket is always non-blocking, and blocking mode is a GSocket level feature.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000117">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">blocking</td><td>Whether to use blocking I/O or not. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacaf83216c9c5c127b6b5f8de425db4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::set_broadcast </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>broadcast</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets whether <em>socket</em> should allow sending to broadcast addresses. </p>
<p>This is <code>false</code> by default.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000108">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">broadcast</td><td>Whether <em>socket</em> should allow sending to broadcast addresses. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cfac67927584ae7afe53006eebb06d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::set_keepalive </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>keepalive</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets or unsets the SO_KEEPALIVE flag on the underlying socket. </p>
<p>When this flag is set on a socket, the system will attempt to verify that the remote socket endpoint is still present if a sufficiently long period of time passes with no data being exchanged. If the system is unable to verify the presence of the remote endpoint, it will automatically close the connection.</p>
<p>This option is only functional on certain kinds of sockets. (Notably, <a class="el" href="classGio_1_1Socket.html#ga7a8e15d48d30611ccbdf260950057830ab136ef5f6a01d816991fe3cf7a6ac763" title="TCP over IP. ">Gio::Socket::Protocol::TCP</a> sockets.)</p>
<p>The exact time between pings is system- and protocol-dependent, but will normally be at least two hours. Most commonly, you would set this flag on a server socket if you want to allow clients to remain idle for long periods of time, but also want to ensure that connections are eventually garbage-collected if clients crash or become unreachable.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000119">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">keepalive</td><td>Value for the keepalive flag. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc7b9d6cecc1c2234f9979b2ffb1b309"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::set_listen_backlog </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>backlog</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets the maximum number of outstanding connections allowed when listening on this socket. </p>
<p>If more clients than this are connecting to the socket and the application is not handling them on time then the new connections will be refused.</p>
<p>Note that this must be called before g_socket_listen() and has no effect if called after that.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000115">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">backlog</td><td>The maximum number of pending connections. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2e4493d31588bb9175b090a061dbd5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::set_multicast_loopback </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>loopback</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets whether outgoing multicast packets will be received by sockets listening on that multicast address on the same host. </p>
<p>This is <code>true</code> by default.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000110">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">loopback</td><td>Whether <em>socket</em> should receive messages sent to its multicast groups from the local host. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac946c14f5f92326c3f062f23ed1d5837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::set_multicast_ttl </td>
          <td>(</td>
          <td class="paramtype">guint </td>
          <td class="paramname"><em>ttl</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets the time-to-live for outgoing multicast datagrams on <em>socket</em>. </p>
<p>By default, this is 1, meaning that multicast packets will not leave the local network.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000112">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ttl</td><td>The time-to-live value for all multicast datagrams on <em>socket</em>. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13116c8ad9db97e3c04a370a8a7ec7d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::set_option </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>value</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets the value of an integer-valued option on <em>socket</em>, as with setsockopt(). </p>
<p>(If you need to set a non-integer-valued option, you will need to call setsockopt() directly.)</p>
<p>The [&lt;gio/gnetworking.h&gt;][gio-gnetworking.h] header pulls in system headers that will define most of the standard/portable socket options. For unusual socket protocols or platform-dependent options, you may need to include additional headers.</p>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000023">Since glibmm 2.36:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">level</td><td>The "API level" of the option (eg, <code>SOL_SOCKET</code>). </td></tr>
    <tr><td class="paramname">optname</td><td>The "name" of the option (eg, <code>SO_BROADCAST</code>). </td></tr>
    <tr><td class="paramname">value</td><td>The value to set the option to. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success or failure. On failure, <em>error</em> will be set, and the system error value (<code>errno</code> or WSAGetLastError()) will still be set to the result of the setsockopt() call.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe942e5157528b217d7af4a7839a9e7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::set_timeout </td>
          <td>(</td>
          <td class="paramtype">guint </td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets the time in seconds after which I/O operations on <em>socket</em> will time out if they have not yet completed. </p>
<p>On a blocking socket, this means that any blocking <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object. ">Socket</a> operation will time out after <em>timeout</em> seconds of inactivity, returning <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134ad9be2d9a98ef25458c32ac424264d963" title="Operation timed out. ">Gio::Error::TIMED_OUT</a>.</p>
<p>On a non-blocking socket, calls to g_socket_condition_wait() will also fail with <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134ad9be2d9a98ef25458c32ac424264d963" title="Operation timed out. ">Gio::Error::TIMED_OUT</a> after the given time. Sources created with g_socket_create_source() will trigger after <em>timeout</em> seconds of inactivity, with the requested condition set, at which point calling g_socket_receive(), g_socket_send(), g_socket_check_connect_result(), etc, will fail with <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134ad9be2d9a98ef25458c32ac424264d963" title="Operation timed out. ">Gio::Error::TIMED_OUT</a>.</p>
<p>If <em>timeout</em> is 0 (the default), operations will never time out on their own.</p>
<p>Note that if an I/O operation is interrupted by a signal, this may cause the timeout to be reset.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000311">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">timeout</td><td>The timeout for <em>socket</em>, in seconds, or 0 for none. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afce7afa0966858f85979cbb884294007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::set_ttl </td>
          <td>(</td>
          <td class="paramtype">guint </td>
          <td class="paramname"><em>ttl</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets the time-to-live for outgoing unicast packets on <em>socket</em>. </p>
<p>By default the platform-specific default value is used.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000106">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ttl</td><td>The time-to-live value for all unicast packets on <em>socket</em>. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f685bc040e9e10abe093deec0719fd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gio::Socket::shutdown </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>shutdown_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>shutdown_write</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Shut down part or all of a full-duplex connection. </p>
<p>If <em>shutdown_read</em> is <code>true</code> then the receiving side of the connection is shut down, and further reading is disallowed.</p>
<p>If <em>shutdown_write</em> is <code>true</code> then the sending side of the connection is shut down, and further writing is disallowed.</p>
<p>It is allowed for both <em>shutdown_read</em> and <em>shutdown_write</em> to be <code>true</code>.</p>
<p>One example where it is useful to shut down only one side of a connection is graceful disconnect for TCP connections where you close the sending side, then wait for the other side to close the connection, thus ensuring that the other side saw all sent data.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000111">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">shutdown_read</td><td>Whether to shut down the read side. </td></tr>
    <tr><td class="paramname">shutdown_write</td><td>Whether to shut down the write side.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae33e646694bf6c5062683ba4b79d4fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gio::Socket::speaks_ipv4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks if a socket is capable of speaking IPv4. </p>
<p>IPv4 sockets are capable of speaking IPv4. On some operating systems and under some combinations of circumstances IPv6 sockets are also capable of speaking IPv4. See RFC 3493 section 3.7 for more information.</p>
<p>No other types of sockets are currently considered as being capable of speaking IPv4.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000127">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this socket can be used with IPv4. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a4b4f2145105f84580f0a2659a9e8e5db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Gio::Socket</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GSocket * </td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>take_copy</em> = <code>false</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div></div></div><div id="footer_art" class="default"> </div></div><div class="clearfix"></div><div id="footer_grass">   </div><div id="footer"><div class="container_12"><div class="links grid_9"><div class="menu-footer-1-container"><ul id="menu-footer-1" class="menu"><li id="menu-item-88" class="menu-item menu-item-type-custom menu-item-home menu-item-88"><a href="https://www.gnome.org/">The GNOME Project</a><ul class="sub-menu"><li id="menu-item-89" class="menu-item menu-item-type-post_type menu-item-89"><a href="https://www.gnome.org/about/">About Us</a></li><li id="menu-item-90" class="menu-item menu-item-type-custom menu-item-90"><a href="https://www.gnome.org/get-involved/">Get Involved</a></li><li id="menu-item-91" class="menu-item menu-item-type-custom menu-item-91"><a href="https://www.gnome.org/teams/">Teams</a></li><li id="menu-item-92" class="menu-item menu-item-type-custom menu-item-92"><a href="https://foundation.gnome.org">The GNOME Foundation</a></li><li><a href="https://www.gnome.org/support-gnome/">Support GNOME</a></li><li><a href="https://www.gnome.org/contact/">Contact</a></li></ul></li></ul></div><div class="menu-footer-2-container"><ul id="menu-footer-2" class="menu"><li id="menu-item-99" class="menu-item menu-item-type-post_type current-menu-item page_item page-item-20 current_page_item menu-item-99"><a href="classGio_1_1Socket.html#">Resources</a><ul class="sub-menu"><li><a href="https://help.gnome.org">Documentation</a></li><li><a href="https://wiki.gnome.org">Wiki</a></li><li><a href="https://mail.gnome.org/mailman/listinfo">Mailing Lists</a></li><li><a href="https://wiki.gnome.org/GnomeIrcChannels">IRC Channels</a></li><li><a href="https://gitlab.gnome.org/">Bug Tracker</a></li><li><a href="https://gitlab.gnome.org/">Development Code</a></li><li><a href="https://wiki.gnome.org/Jhbuild">Build Tool</a></li></ul></li></ul></div><div class="menu-footer-4-container"><ul id="menu-footer-4" class="menu"><li id="menu-item-104" class="menu-item menu-item-type-custom menu-item-104"><a href="http://www.gnome.org/news/">News</a><ul class="sub-menu"><li><a href="https://www.gnome.org/start/stable">Latest Release</a></li><li><a href="https://planet.gnome.org">Planet GNOME</a></li><li><a href="https://news.gnome.org">Development News</a></li><li><a href="https://twitter.com/gnome">Twitter</a></li></ul></li></ul></div></div><div class="links grid_3 right"><div><ul class="menu available_languages"><li><strong>This website is available in many languages</strong><ul class="sub-menu"><li><a href="../../languages.html" title="Switching Language">Switch Language</a></li></ul></li></ul><script type="text/javascript" src="../../js/language.js"></script></div></div><div id="footnotes" class="grid_9">
                Copyright © 2005‒2014 <strong class="gnome_logo">The GNOME Project</strong><br></br><small>Optimised for standards. Hosted by <a href="http://redhat.com">Red Hat</a>.</small></div><div class="clear"></div></div></div><script type="text/javascript">
$(document).ready(function() {
    // Get browser
    $.each($.browser, function(i) {
        $('body').addClass(i);
        return false;
    });

    // Get OS and add it as class to body tag, this then allows forcing some
    // customisation in the CSS rules.
    var match = navigator.userAgent.toLowerCase().match(/(win|mac|linux)/);
    if (match) {
        $('body').addClass(match[0]);
    }
});
</script><script type="text/javascript">
      var _paq = _paq || [];
      _paq.push(['disableCookies']);
      _paq.push(["trackPageView"]);
      _paq.push(["enableLinkTracking"]);

      (function() {
        var u=(("https:" == document.location.protocol) ? "https" : "http") + "://webstats.gnome.org/";
        _paq.push(["setTrackerUrl", u+"piwik.php"]);
        _paq.push(["setSiteId", "6"]);
        var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";
        g.defer=true; g.async=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);
      })();
    </script></body></html>
