<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:html="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8"></meta><link rel="stylesheet" href="../../skin/doxygen.css" type="text/css"></link><link rel="stylesheet" type="text/css" media="all" href="https://static.gnome.org/css/grass-theme-style.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/lgo2010.css"></link><link rel="icon" type="image/png" href="../../skin/gnome-16.png"></link><link rel="SHORTCUT ICON" type="image/png" href="../../skin/gnome-16.png"></link><link rel="search" type="application/opensearchdescription+xml" href="../../gnome-library-search.xml" title="GNOME Library Search"></link><link rel="stylesheet" type="text/css" href="../../skin/jquery.autocomplete.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script><title>gtkmm: Gtk::TextIterBase Class Reference</title><link rel="stylesheet" type="text/css" media="all" href="../../skin/jquery.autocomplete.css"></link><link rel="stylesheet" type="text/css" media="all" href="../../skin/960_24_col.css"></link><script type="text/javascript" src="../../js/jquery.js"></script><script type="text/javascript" src="https://developer-old.gnome.org/js/jquery.jcarousel.min.js"></script><script type="text/javascript" src="../../js/jquery.autocomplete.js"></script></head><body><div id="accessibility_access"><ul><li><a href="classGtk_1_1TextIterBase.html#container">Go to page content</a></li><li><a href="classGtk_1_1TextIterBase.html#top_bar">Go to main menu</a></li><li><a href="classGtk_1_1TextIterBase.html#s" onclick="$('#s').focus(); return false;">Go to the search field</a></li></ul></div><div id="global_domain_bar"><div class="maxwidth"><div class="tab"><a class="root" href="https://www.gnome.org/">GNOME.org</a></div></div></div><div id="header" class="container_12"><div id="logo" class="grid_3"><a title="Go to home page" href="../../index.html"><img alt="GNOME: The Free Software Desktop Project" src="../../skin/gnome-logo-devcenter.png"></img></a></div><div id="top_bar" class="grid_9"><div class="left"><div class="menu-globalnav-container"><ul id="menu-globalnav" class="menu"><li class="menu-item menu-item-type-post_type menu-item-6"><a href="../../about/index.html">About</a></li><li class="menu-item menu-item-type-post_type menu-item-23"><a href="https://help.gnome.org/users/">Users</a></li><li class="menu-item menu-item-type-post_type menu-item-40"><a href="https://help.gnome.org/admin/">Administrators</a></li><li class="current-menu-item"><a href="https://developer.gnome.org/">Developers</a></li></ul></div></div><div class="right"><form role="search" method="get" id="searchform" action="https://developer-old.gnome.org/symbols/"><div><label class="hidden" for="q">Search:
                        </label><input type="text" value="" name="q" id="s" placeholder="Search"></input></div></form><script type="text/javascript">
$('#s').autocomplete('/symbols/lookup/',
        { minChars:3, matchSubset:1, matchContains:1, cacheLength:10,
          selectOnly:1, rowsLimit:25 });
              </script></div></div></div><div class="clearfix"></div><div id="container" class="gtkmm"><div class="content"><h1 class="lgotitle">gtkmm: Gtk::TextIterBase Class Reference</h1><div id="content"><div class="tabs" id="navrow1">
    <ul class="tablist">
      <li><a href="index.html"><span>Main Page</span></a></li>
      <li><a href="pages.html"><span>Related Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div><div class="contents">

<p>Common base class of <a class="el" href="classGtk_1_1TextIter.html" title="Typedefed as Gtk::TextBuffer::iterator. ">TextIter</a> and <a class="el" href="classGtk_1_1TextConstIter.html" title="Typedefed as Gtk::TextBuffer::const_iterator. ">TextConstIter</a>.  
 <a href="classGtk_1_1TextIterBase.html#details">More...</a></p>

<p><code>#include &lt;gtkmm/textiter.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gtk::TextIterBase:</div>
<div class="dyncontent">
<div class="center"><img alt="Inheritance graph" border="0" src="classGtk_1_1TextIterBase__inherit__graph.png" usemap="#Gtk_1_1TextIterBase_inherit__map"></img></div>
<map id="Gtk_1_1TextIterBase_inherit__map" name="Gtk_1_1TextIterBase_inherit__map">
<area alt="" coords="5,80,144,107" href="classGtk_1_1TextConstIter.html" id="node2" shape="rect" title="Typedefed as Gtk::TextBuffer::const_iterator. "></area>
<area alt="" coords="169,80,271,107" href="classGtk_1_1TextIter.html" id="node3" shape="rect" title="Typedefed as Gtk::TextBuffer::iterator. "></area>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a24cf4782995313610de7fc48a5eccbce"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a24cf4782995313610de7fc48a5eccbce">iterator_category</a> = <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06664.html">std::bidirectional_iterator_tag</a></td></tr>
<tr class="separator:a24cf4782995313610de7fc48a5eccbce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7210161f767759c833fcbf713cf598cf"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a7210161f767759c833fcbf713cf598cf">value_type</a> = gunichar</td></tr>
<tr class="separator:a7210161f767759c833fcbf713cf598cf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b14d8cd72db71666ed620f8bf0b4991"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a3b14d8cd72db71666ed620f8bf0b4991">difference_type</a> = int</td></tr>
<tr class="separator:a3b14d8cd72db71666ed620f8bf0b4991"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afee0a5ffbece6c265dd888b8c1550f60"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#afee0a5ffbece6c265dd888b8c1550f60">reference</a> = <a class="el" href="classGtk_1_1TextIterBase.html#a7210161f767759c833fcbf713cf598cf">value_type</a></td></tr>
<tr class="separator:afee0a5ffbece6c265dd888b8c1550f60"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a53fd6bd11b7a916b56858a579ce72e0c"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a53fd6bd11b7a916b56858a579ce72e0c">pointer</a> = void</td></tr>
<tr class="separator:a53fd6bd11b7a916b56858a579ce72e0c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a59ffbed80d87748aaaf6b83d920c33cf"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">SlotFindChar</a> = sigc::slot&lt; bool(gunichar)&gt;</td></tr>
<tr class="memdesc:a59ffbed80d87748aaaf6b83d920c33cf"><td class="mdescLeft"> </td><td class="mdescRight">A slot that will be called on each consecutive character.  <a href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">More...</a><br></br></td></tr>
<tr class="separator:a59ffbed80d87748aaaf6b83d920c33cf"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89fa55a08a7dd17e8e0f62fc68f2c7e8"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a89fa55a08a7dd17e8e0f62fc68f2c7e8">TextIterBase</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; other) noexcept</td></tr>
<tr class="separator:a89fa55a08a7dd17e8e0f62fc68f2c7e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a66d574142957ea8c32f74c6eb7a59653"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a66d574142957ea8c32f74c6eb7a59653">operator=</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; other) noexcept</td></tr>
<tr class="separator:a66d574142957ea8c32f74c6eb7a59653"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02f0e13c5507c7497e9fc16550bff724"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a02f0e13c5507c7497e9fc16550bff724">TextIterBase</a> (<a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;&amp; other) noexcept</td></tr>
<tr class="separator:a02f0e13c5507c7497e9fc16550bff724"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b8b52eb048dc0eb03939ec0831caf8c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a5b8b52eb048dc0eb03939ec0831caf8c">operator=</a> (<a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;&amp; other) noexcept</td></tr>
<tr class="separator:a5b8b52eb048dc0eb03939ec0831caf8c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca42ac8be6f14bb9bd389d3e32a39880"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#aca42ac8be6f14bb9bd389d3e32a39880">TextIterBase</a> ()</td></tr>
<tr class="separator:aca42ac8be6f14bb9bd389d3e32a39880"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af9999bc88a460c8e74fbd1a99ac313ef"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#af9999bc88a460c8e74fbd1a99ac313ef">TextIterBase</a> (const GtkTextIter* gobject)</td></tr>
<tr class="separator:af9999bc88a460c8e74fbd1a99ac313ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe3ed2742a24672a4ed263f6ec3a2567"><td align="right" class="memItemLeft" valign="top">GtkTextIter* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#afe3ed2742a24672a4ed263f6ec3a2567">gobj</a> ()</td></tr>
<tr class="memdesc:afe3ed2742a24672a4ed263f6ec3a2567"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C instance.  <a href="classGtk_1_1TextIterBase.html#afe3ed2742a24672a4ed263f6ec3a2567">More...</a><br></br></td></tr>
<tr class="separator:afe3ed2742a24672a4ed263f6ec3a2567"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ae481258259e71ef67dc9519f6069a0"><td align="right" class="memItemLeft" valign="top">const GtkTextIter* </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a4ae481258259e71ef67dc9519f6069a0">gobj</a> () const </td></tr>
<tr class="memdesc:a4ae481258259e71ef67dc9519f6069a0"><td class="mdescLeft"> </td><td class="mdescRight">Provides access to the underlying C instance.  <a href="classGtk_1_1TextIterBase.html#a4ae481258259e71ef67dc9519f6069a0">More...</a><br></br></td></tr>
<tr class="separator:a4ae481258259e71ef67dc9519f6069a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5f7b581dc5c9261ff5ef287e41245ef9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGtk_1_1TextIterBase.html#a7210161f767759c833fcbf713cf598cf">value_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a5f7b581dc5c9261ff5ef287e41245ef9">operator*</a> () const </td></tr>
<tr class="memdesc:a5f7b581dc5c9261ff5ef287e41245ef9"><td class="mdescLeft"> </td><td class="mdescRight">Alias for <a class="el" href="classGtk_1_1TextIterBase.html#a7df2c6d63c0f2eadfa74d49bc7e8048d" title="The Unicode character at this iterator is returned. ">get_char()</a>.  <a href="classGtk_1_1TextIterBase.html#a5f7b581dc5c9261ff5ef287e41245ef9">More...</a><br></br></td></tr>
<tr class="separator:a5f7b581dc5c9261ff5ef287e41245ef9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a21978967b14b3140eb1c2ebf13cb177e"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a21978967b14b3140eb1c2ebf13cb177e">operator bool</a> () const </td></tr>
<tr class="memdesc:a21978967b14b3140eb1c2ebf13cb177e"><td class="mdescLeft"> </td><td class="mdescRight">Alias for !is_end().  <a href="classGtk_1_1TextIterBase.html#a21978967b14b3140eb1c2ebf13cb177e">More...</a><br></br></td></tr>
<tr class="separator:a21978967b14b3140eb1c2ebf13cb177e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec3a77b92f3a7918668fe6038a51113b"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#aec3a77b92f3a7918668fe6038a51113b">get_offset</a> () const </td></tr>
<tr class="memdesc:aec3a77b92f3a7918668fe6038a51113b"><td class="mdescLeft"> </td><td class="mdescRight">Returns the character offset of an iterator.  <a href="classGtk_1_1TextIterBase.html#aec3a77b92f3a7918668fe6038a51113b">More...</a><br></br></td></tr>
<tr class="separator:aec3a77b92f3a7918668fe6038a51113b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a60c0c66696c8dcaa2445b383e089ded5"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a60c0c66696c8dcaa2445b383e089ded5">get_line</a> () const </td></tr>
<tr class="memdesc:a60c0c66696c8dcaa2445b383e089ded5"><td class="mdescLeft"> </td><td class="mdescRight">Returns the line number containing the iterator.  <a href="classGtk_1_1TextIterBase.html#a60c0c66696c8dcaa2445b383e089ded5">More...</a><br></br></td></tr>
<tr class="separator:a60c0c66696c8dcaa2445b383e089ded5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a89791fc2f47b169bb9817009ae1ae59d"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a89791fc2f47b169bb9817009ae1ae59d">get_line_offset</a> () const </td></tr>
<tr class="memdesc:a89791fc2f47b169bb9817009ae1ae59d"><td class="mdescLeft"> </td><td class="mdescRight">Returns the character offset of the iterator, counting from the start of a newline-terminated line.  <a href="classGtk_1_1TextIterBase.html#a89791fc2f47b169bb9817009ae1ae59d">More...</a><br></br></td></tr>
<tr class="separator:a89791fc2f47b169bb9817009ae1ae59d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adf071172096a9f8e04dabe972529d54f"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#adf071172096a9f8e04dabe972529d54f">get_line_index</a> () const </td></tr>
<tr class="memdesc:adf071172096a9f8e04dabe972529d54f"><td class="mdescLeft"> </td><td class="mdescRight">Returns the byte index of the iterator, counting from the start of a newline-terminated line.  <a href="classGtk_1_1TextIterBase.html#adf071172096a9f8e04dabe972529d54f">More...</a><br></br></td></tr>
<tr class="separator:adf071172096a9f8e04dabe972529d54f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae4001f06243a9431869b472fae172f22"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ae4001f06243a9431869b472fae172f22">get_visible_line_offset</a> () const </td></tr>
<tr class="memdesc:ae4001f06243a9431869b472fae172f22"><td class="mdescLeft"> </td><td class="mdescRight">Returns the offset in characters from the start of the line to the given <em>iter</em>, not counting characters that are invisible due to tags with the “invisible” flag toggled on.  <a href="classGtk_1_1TextIterBase.html#ae4001f06243a9431869b472fae172f22">More...</a><br></br></td></tr>
<tr class="separator:ae4001f06243a9431869b472fae172f22"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a378f91255ecdea2739f7c88bb78500c6"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a378f91255ecdea2739f7c88bb78500c6">get_visible_line_index</a> () const </td></tr>
<tr class="memdesc:a378f91255ecdea2739f7c88bb78500c6"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of bytes from the start of the line to the given <em>iter</em>, not counting bytes that are invisible due to tags with the “invisible” flag toggled on.  <a href="classGtk_1_1TextIterBase.html#a378f91255ecdea2739f7c88bb78500c6">More...</a><br></br></td></tr>
<tr class="separator:a378f91255ecdea2739f7c88bb78500c6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7df2c6d63c0f2eadfa74d49bc7e8048d"><td align="right" class="memItemLeft" valign="top">gunichar </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a7df2c6d63c0f2eadfa74d49bc7e8048d">get_char</a> () const </td></tr>
<tr class="memdesc:a7df2c6d63c0f2eadfa74d49bc7e8048d"><td class="mdescLeft"> </td><td class="mdescRight">The Unicode character at this iterator is returned.  <a href="classGtk_1_1TextIterBase.html#a7df2c6d63c0f2eadfa74d49bc7e8048d">More...</a><br></br></td></tr>
<tr class="separator:a7df2c6d63c0f2eadfa74d49bc7e8048d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7599b9af7b359732200a2d5a7014372a"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/classGlib_1_1ustring.html">Glib::ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a7599b9af7b359732200a2d5a7014372a">get_slice</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#gab777d802b5dfa668d030039c2fd78b3b">end</a>) const </td></tr>
<tr class="memdesc:a7599b9af7b359732200a2d5a7014372a"><td class="mdescLeft"> </td><td class="mdescRight">Returns the text in the given range.  <a href="classGtk_1_1TextIterBase.html#a7599b9af7b359732200a2d5a7014372a">More...</a><br></br></td></tr>
<tr class="separator:a7599b9af7b359732200a2d5a7014372a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afdcecd70c167b7207e402843ece1b7da"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/classGlib_1_1ustring.html">Glib::ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#afdcecd70c167b7207e402843ece1b7da">get_text</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#gab777d802b5dfa668d030039c2fd78b3b">end</a>) const </td></tr>
<tr class="memdesc:afdcecd70c167b7207e402843ece1b7da"><td class="mdescLeft"> </td><td class="mdescRight">Returns text in the given range.  <a href="classGtk_1_1TextIterBase.html#afdcecd70c167b7207e402843ece1b7da">More...</a><br></br></td></tr>
<tr class="separator:afdcecd70c167b7207e402843ece1b7da"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69480d8e37f507242596de65927c60f7"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/classGlib_1_1ustring.html">Glib::ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a69480d8e37f507242596de65927c60f7">get_visible_slice</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#gab777d802b5dfa668d030039c2fd78b3b">end</a>) const </td></tr>
<tr class="memdesc:a69480d8e37f507242596de65927c60f7"><td class="mdescLeft"> </td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIterBase.html#a7599b9af7b359732200a2d5a7014372a" title="Returns the text in the given range. ">get_slice()</a>, but invisible text is not included.  <a href="classGtk_1_1TextIterBase.html#a69480d8e37f507242596de65927c60f7">More...</a><br></br></td></tr>
<tr class="separator:a69480d8e37f507242596de65927c60f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a03b8a846cd377e2567bf0039e6025712"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/classGlib_1_1ustring.html">Glib::ustring</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a03b8a846cd377e2567bf0039e6025712">get_visible_text</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#gab777d802b5dfa668d030039c2fd78b3b">end</a>) const </td></tr>
<tr class="memdesc:a03b8a846cd377e2567bf0039e6025712"><td class="mdescLeft"> </td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIterBase.html#afdcecd70c167b7207e402843ece1b7da" title="Returns text in the given range. ">get_text()</a>, but invisible text is not included.  <a href="classGtk_1_1TextIterBase.html#a03b8a846cd377e2567bf0039e6025712">More...</a><br></br></td></tr>
<tr class="separator:a03b8a846cd377e2567bf0039e6025712"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb30c5be90fae424416ed40e3b5218f5"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#abb30c5be90fae424416ed40e3b5218f5">starts_tag</a> (const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; tag={}) const </td></tr>
<tr class="memdesc:abb30c5be90fae424416ed40e3b5218f5"><td class="mdescLeft"> </td><td class="mdescRight">Returns <code>true</code> if <em>tag</em> is toggled on at exactly this point.  <a href="classGtk_1_1TextIterBase.html#abb30c5be90fae424416ed40e3b5218f5">More...</a><br></br></td></tr>
<tr class="separator:abb30c5be90fae424416ed40e3b5218f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a25531f837a424962c81024b0f0d25d"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a3a25531f837a424962c81024b0f0d25d">ends_tag</a> (const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; tag={}) const </td></tr>
<tr class="memdesc:a3a25531f837a424962c81024b0f0d25d"><td class="mdescLeft"> </td><td class="mdescRight">Returns <code>true</code> if <em>tag</em> is toggled off at exactly this point.  <a href="classGtk_1_1TextIterBase.html#a3a25531f837a424962c81024b0f0d25d">More...</a><br></br></td></tr>
<tr class="separator:a3a25531f837a424962c81024b0f0d25d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a9f93661c9a4ceea57a3babbe2d566b"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a6a9f93661c9a4ceea57a3babbe2d566b">toggles_tag</a> (const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; tag={}) const </td></tr>
<tr class="memdesc:a6a9f93661c9a4ceea57a3babbe2d566b"><td class="mdescLeft"> </td><td class="mdescRight">This is equivalent to (<a class="el" href="classGtk_1_1TextIterBase.html#abb30c5be90fae424416ed40e3b5218f5" title="Returns true if tag is toggled on at exactly this point. ">starts_tag()</a> || <a class="el" href="classGtk_1_1TextIterBase.html#a3a25531f837a424962c81024b0f0d25d" title="Returns true if tag is toggled off at exactly this point. ">ends_tag()</a>), i.e. it tells you whether a range with <em>tag</em> applied to it begins or ends at <em>iter</em>.  <a href="classGtk_1_1TextIterBase.html#a6a9f93661c9a4ceea57a3babbe2d566b">More...</a><br></br></td></tr>
<tr class="separator:a6a9f93661c9a4ceea57a3babbe2d566b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae30ff4e7be20ba14ee4c4a05fe8615e7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ae30ff4e7be20ba14ee4c4a05fe8615e7">has_tag</a> (const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; tag) const </td></tr>
<tr class="memdesc:ae30ff4e7be20ba14ee4c4a05fe8615e7"><td class="mdescLeft"> </td><td class="mdescRight">Returns <code>true</code> if <em>iter</em> points to a character that is part of a range tagged with <em>tag</em>.  <a href="classGtk_1_1TextIterBase.html#ae30ff4e7be20ba14ee4c4a05fe8615e7">More...</a><br></br></td></tr>
<tr class="separator:ae30ff4e7be20ba14ee4c4a05fe8615e7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a967859094a69a01f8937a432bcff35db"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a967859094a69a01f8937a432bcff35db">editable</a> (bool default_setting=true) const </td></tr>
<tr class="memdesc:a967859094a69a01f8937a432bcff35db"><td class="mdescLeft"> </td><td class="mdescRight">Returns whether the character at <em>iter</em> is within an editable region of text.  <a href="classGtk_1_1TextIterBase.html#a967859094a69a01f8937a432bcff35db">More...</a><br></br></td></tr>
<tr class="separator:a967859094a69a01f8937a432bcff35db"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac60559326dbbac2ddd95bed2f91169f4"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ac60559326dbbac2ddd95bed2f91169f4">can_insert</a> (bool default_editability=true) const </td></tr>
<tr class="memdesc:ac60559326dbbac2ddd95bed2f91169f4"><td class="mdescLeft"> </td><td class="mdescRight">Considering the default editability of the buffer, and tags that affect editability, determines whether text inserted at <em>iter</em> would be editable.  <a href="classGtk_1_1TextIterBase.html#ac60559326dbbac2ddd95bed2f91169f4">More...</a><br></br></td></tr>
<tr class="separator:ac60559326dbbac2ddd95bed2f91169f4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69188fcb922219032f650ad399b8b46c"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a69188fcb922219032f650ad399b8b46c">starts_word</a> () const </td></tr>
<tr class="memdesc:a69188fcb922219032f650ad399b8b46c"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether <em>iter</em> begins a natural-language word.  <a href="classGtk_1_1TextIterBase.html#a69188fcb922219032f650ad399b8b46c">More...</a><br></br></td></tr>
<tr class="separator:a69188fcb922219032f650ad399b8b46c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47667346d417d72907b44c0eb6cfd64f"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a47667346d417d72907b44c0eb6cfd64f">ends_word</a> () const </td></tr>
<tr class="memdesc:a47667346d417d72907b44c0eb6cfd64f"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether <em>iter</em> ends a natural-language word.  <a href="classGtk_1_1TextIterBase.html#a47667346d417d72907b44c0eb6cfd64f">More...</a><br></br></td></tr>
<tr class="separator:a47667346d417d72907b44c0eb6cfd64f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a14dc8e8fdef8ebfad2cba226d56e07ea"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a14dc8e8fdef8ebfad2cba226d56e07ea">inside_word</a> () const </td></tr>
<tr class="memdesc:a14dc8e8fdef8ebfad2cba226d56e07ea"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether the character pointed by <em>iter</em> is part of a natural-language word (as opposed to say inside some whitespace).  <a href="classGtk_1_1TextIterBase.html#a14dc8e8fdef8ebfad2cba226d56e07ea">More...</a><br></br></td></tr>
<tr class="separator:a14dc8e8fdef8ebfad2cba226d56e07ea"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a311c37bb5916810d67bb72f33226f756"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a311c37bb5916810d67bb72f33226f756">starts_sentence</a> () const </td></tr>
<tr class="memdesc:a311c37bb5916810d67bb72f33226f756"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether <em>iter</em> begins a sentence.  <a href="classGtk_1_1TextIterBase.html#a311c37bb5916810d67bb72f33226f756">More...</a><br></br></td></tr>
<tr class="separator:a311c37bb5916810d67bb72f33226f756"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab609fc4debe58acceccaa5594157c586"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ab609fc4debe58acceccaa5594157c586">ends_sentence</a> () const </td></tr>
<tr class="memdesc:ab609fc4debe58acceccaa5594157c586"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether <em>iter</em> ends a sentence.  <a href="classGtk_1_1TextIterBase.html#ab609fc4debe58acceccaa5594157c586">More...</a><br></br></td></tr>
<tr class="separator:ab609fc4debe58acceccaa5594157c586"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4143d1a36c154e1d65ccbbe3730abd9f"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a4143d1a36c154e1d65ccbbe3730abd9f">inside_sentence</a> () const </td></tr>
<tr class="memdesc:a4143d1a36c154e1d65ccbbe3730abd9f"><td class="mdescLeft"> </td><td class="mdescRight">Determines whether <em>iter</em> is inside a sentence (as opposed to in between two sentences, e.g. after a period and before the first letter of the next sentence).  <a href="classGtk_1_1TextIterBase.html#a4143d1a36c154e1d65ccbbe3730abd9f">More...</a><br></br></td></tr>
<tr class="separator:a4143d1a36c154e1d65ccbbe3730abd9f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af770823f0947c77a4d630b3900822c91"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#af770823f0947c77a4d630b3900822c91">starts_line</a> () const </td></tr>
<tr class="memdesc:af770823f0947c77a4d630b3900822c91"><td class="mdescLeft"> </td><td class="mdescRight">Returns <code>true</code> if <em>iter</em> begins a paragraph, i.e. if <a class="el" href="classGtk_1_1TextIterBase.html#a89791fc2f47b169bb9817009ae1ae59d" title="Returns the character offset of the iterator, counting from the start of a newline-terminated line...">get_line_offset()</a> would return 0.  <a href="classGtk_1_1TextIterBase.html#af770823f0947c77a4d630b3900822c91">More...</a><br></br></td></tr>
<tr class="separator:af770823f0947c77a4d630b3900822c91"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a3b414fdd61e7f0f7cb727470364a61"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a6a3b414fdd61e7f0f7cb727470364a61">ends_line</a> () const </td></tr>
<tr class="memdesc:a6a3b414fdd61e7f0f7cb727470364a61"><td class="mdescLeft"> </td><td class="mdescRight">Returns <code>true</code> if <em>iter</em> points to the start of the paragraph delimiter characters for a line (delimiters will be either a newline, a carriage return, a carriage return followed by a newline, or a Unicode paragraph separator character).  <a href="classGtk_1_1TextIterBase.html#a6a3b414fdd61e7f0f7cb727470364a61">More...</a><br></br></td></tr>
<tr class="separator:a6a3b414fdd61e7f0f7cb727470364a61"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac9d6bfef7ca2c832c151bd2f8e831975"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ac9d6bfef7ca2c832c151bd2f8e831975">is_cursor_position</a> () const </td></tr>
<tr class="memdesc:ac9d6bfef7ca2c832c151bd2f8e831975"><td class="mdescLeft"> </td><td class="mdescRight">See <a class="el" href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228" title="Moves iter forward by a single cursor position. ">forward_cursor_position()</a> or <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html#ab0b3468a9efcaec7022885d46fd43d09">Pango::LogAttr</a> or pango_break() for details on what a cursor position is.  <a href="classGtk_1_1TextIterBase.html#ac9d6bfef7ca2c832c151bd2f8e831975">More...</a><br></br></td></tr>
<tr class="separator:ac9d6bfef7ca2c832c151bd2f8e831975"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa59610daceb49a42c38f74381efc03be"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#aa59610daceb49a42c38f74381efc03be">get_chars_in_line</a> () const </td></tr>
<tr class="memdesc:aa59610daceb49a42c38f74381efc03be"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of characters in the line containing <em>iter</em>, including the paragraph delimiters.  <a href="classGtk_1_1TextIterBase.html#aa59610daceb49a42c38f74381efc03be">More...</a><br></br></td></tr>
<tr class="separator:aa59610daceb49a42c38f74381efc03be"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adefbb3301d329c20f696e6b6147349aa"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#adefbb3301d329c20f696e6b6147349aa">get_bytes_in_line</a> () const </td></tr>
<tr class="memdesc:adefbb3301d329c20f696e6b6147349aa"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of bytes in the line containing <em>iter</em>, including the paragraph delimiters.  <a href="classGtk_1_1TextIterBase.html#adefbb3301d329c20f696e6b6147349aa">More...</a><br></br></td></tr>
<tr class="separator:adefbb3301d329c20f696e6b6147349aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c55ac5b91d25568f9f6e42b59c518c3"><td align="right" class="memItemLeft" valign="top"><a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/classPango_1_1Language.html">Pango::Language</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a5c55ac5b91d25568f9f6e42b59c518c3">get_language</a> () const </td></tr>
<tr class="memdesc:a5c55ac5b91d25568f9f6e42b59c518c3"><td class="mdescLeft"> </td><td class="mdescRight">Returns the language in effect at <em>iter</em>.  <a href="classGtk_1_1TextIterBase.html#a5c55ac5b91d25568f9f6e42b59c518c3">More...</a><br></br></td></tr>
<tr class="separator:a5c55ac5b91d25568f9f6e42b59c518c3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a26d57f9b3ba0b1e6cf689c3176524d85"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a26d57f9b3ba0b1e6cf689c3176524d85">is_end</a> () const </td></tr>
<tr class="memdesc:a26d57f9b3ba0b1e6cf689c3176524d85"><td class="mdescLeft"> </td><td class="mdescRight">Returns <code>true</code> if <em>iter</em> is the end iterator, i.e. one past the last dereferenceable iterator in the buffer.  <a href="classGtk_1_1TextIterBase.html#a26d57f9b3ba0b1e6cf689c3176524d85">More...</a><br></br></td></tr>
<tr class="separator:a26d57f9b3ba0b1e6cf689c3176524d85"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab37fb8d7bd27d7dae5866d4d355aa8c1"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ab37fb8d7bd27d7dae5866d4d355aa8c1">is_start</a> () const </td></tr>
<tr class="memdesc:ab37fb8d7bd27d7dae5866d4d355aa8c1"><td class="mdescLeft"> </td><td class="mdescRight">Returns <code>true</code> if <em>iter</em> is the first iterator in the buffer, that is if <em>iter</em> has a character offset of 0.  <a href="classGtk_1_1TextIterBase.html#ab37fb8d7bd27d7dae5866d4d355aa8c1">More...</a><br></br></td></tr>
<tr class="separator:ab37fb8d7bd27d7dae5866d4d355aa8c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab007920db6e0c73a3b8253a0599f30e4"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ab007920db6e0c73a3b8253a0599f30e4">forward_char</a> ()</td></tr>
<tr class="memdesc:ab007920db6e0c73a3b8253a0599f30e4"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> forward by one character offset.  <a href="classGtk_1_1TextIterBase.html#ab007920db6e0c73a3b8253a0599f30e4">More...</a><br></br></td></tr>
<tr class="separator:ab007920db6e0c73a3b8253a0599f30e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a079225b6f2f24884a28fc0a1acc789a7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a079225b6f2f24884a28fc0a1acc789a7">backward_char</a> ()</td></tr>
<tr class="memdesc:a079225b6f2f24884a28fc0a1acc789a7"><td class="mdescLeft"> </td><td class="mdescRight">Moves backward by one character offset.  <a href="classGtk_1_1TextIterBase.html#a079225b6f2f24884a28fc0a1acc789a7">More...</a><br></br></td></tr>
<tr class="separator:a079225b6f2f24884a28fc0a1acc789a7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a179b2d7d56dd4bfeeb81add9bd425a15"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a179b2d7d56dd4bfeeb81add9bd425a15">forward_chars</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a179b2d7d56dd4bfeeb81add9bd425a15"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>count</em> characters if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="classGtk_1_1TextIterBase.html#a179b2d7d56dd4bfeeb81add9bd425a15">More...</a><br></br></td></tr>
<tr class="separator:a179b2d7d56dd4bfeeb81add9bd425a15"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaede9258af84aade77b11f2c206928d9"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#aaede9258af84aade77b11f2c206928d9">backward_chars</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:aaede9258af84aade77b11f2c206928d9"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>count</em> characters backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="classGtk_1_1TextIterBase.html#aaede9258af84aade77b11f2c206928d9">More...</a><br></br></td></tr>
<tr class="separator:aaede9258af84aade77b11f2c206928d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b2c18fbbf08f24e3c6d5696f4bb3bd7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a4b2c18fbbf08f24e3c6d5696f4bb3bd7">forward_line</a> ()</td></tr>
<tr class="memdesc:a4b2c18fbbf08f24e3c6d5696f4bb3bd7"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> to the start of the next line.  <a href="classGtk_1_1TextIterBase.html#a4b2c18fbbf08f24e3c6d5696f4bb3bd7">More...</a><br></br></td></tr>
<tr class="separator:a4b2c18fbbf08f24e3c6d5696f4bb3bd7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a998e7bf0bcf2efe553dbec4f3339988b"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a998e7bf0bcf2efe553dbec4f3339988b">backward_line</a> ()</td></tr>
<tr class="memdesc:a998e7bf0bcf2efe553dbec4f3339988b"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> to the start of the previous line.  <a href="classGtk_1_1TextIterBase.html#a998e7bf0bcf2efe553dbec4f3339988b">More...</a><br></br></td></tr>
<tr class="separator:a998e7bf0bcf2efe553dbec4f3339988b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6348f43fb950836bf672fe52091c5c71"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a6348f43fb950836bf672fe52091c5c71">forward_lines</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a6348f43fb950836bf672fe52091c5c71"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>count</em> lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="classGtk_1_1TextIterBase.html#a6348f43fb950836bf672fe52091c5c71">More...</a><br></br></td></tr>
<tr class="separator:a6348f43fb950836bf672fe52091c5c71"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af9ca948bcb9d2a94d9f09c4590ccd7e6"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#af9ca948bcb9d2a94d9f09c4590ccd7e6">backward_lines</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:af9ca948bcb9d2a94d9f09c4590ccd7e6"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>count</em> lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="classGtk_1_1TextIterBase.html#af9ca948bcb9d2a94d9f09c4590ccd7e6">More...</a><br></br></td></tr>
<tr class="separator:af9ca948bcb9d2a94d9f09c4590ccd7e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad1cd8150472655327bc0b8466d0a8965"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ad1cd8150472655327bc0b8466d0a8965">forward_word_end</a> ()</td></tr>
<tr class="memdesc:ad1cd8150472655327bc0b8466d0a8965"><td class="mdescLeft"> </td><td class="mdescRight">Moves forward to the next word end.  <a href="classGtk_1_1TextIterBase.html#ad1cd8150472655327bc0b8466d0a8965">More...</a><br></br></td></tr>
<tr class="separator:ad1cd8150472655327bc0b8466d0a8965"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac0413363c0f8d312cb348eb1997ab236"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ac0413363c0f8d312cb348eb1997ab236">backward_word_start</a> ()</td></tr>
<tr class="memdesc:ac0413363c0f8d312cb348eb1997ab236"><td class="mdescLeft"> </td><td class="mdescRight">Moves backward to the previous word start.  <a href="classGtk_1_1TextIterBase.html#ac0413363c0f8d312cb348eb1997ab236">More...</a><br></br></td></tr>
<tr class="separator:ac0413363c0f8d312cb348eb1997ab236"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2a9396d6eb8157b403206738cbf16059"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a2a9396d6eb8157b403206738cbf16059">forward_word_ends</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a2a9396d6eb8157b403206738cbf16059"><td class="mdescLeft"> </td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIterBase.html#ad1cd8150472655327bc0b8466d0a8965" title="Moves forward to the next word end. ">forward_word_end()</a> up to <em>count</em> times.  <a href="classGtk_1_1TextIterBase.html#a2a9396d6eb8157b403206738cbf16059">More...</a><br></br></td></tr>
<tr class="separator:a2a9396d6eb8157b403206738cbf16059"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad16c143d708a80a0b12b5cd13b121a0d"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ad16c143d708a80a0b12b5cd13b121a0d">backward_word_starts</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:ad16c143d708a80a0b12b5cd13b121a0d"><td class="mdescLeft"> </td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIterBase.html#ac0413363c0f8d312cb348eb1997ab236" title="Moves backward to the previous word start. ">backward_word_start()</a> up to <em>count</em> times.  <a href="classGtk_1_1TextIterBase.html#ad16c143d708a80a0b12b5cd13b121a0d">More...</a><br></br></td></tr>
<tr class="separator:ad16c143d708a80a0b12b5cd13b121a0d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9aa78f4b7841b0b89ff699cd763550ba"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a9aa78f4b7841b0b89ff699cd763550ba">forward_visible_line</a> ()</td></tr>
<tr class="memdesc:a9aa78f4b7841b0b89ff699cd763550ba"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> to the start of the next visible line.  <a href="classGtk_1_1TextIterBase.html#a9aa78f4b7841b0b89ff699cd763550ba">More...</a><br></br></td></tr>
<tr class="separator:a9aa78f4b7841b0b89ff699cd763550ba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b9ab4d23ce5479798be23dc25318d24"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a6b9ab4d23ce5479798be23dc25318d24">backward_visible_line</a> ()</td></tr>
<tr class="memdesc:a6b9ab4d23ce5479798be23dc25318d24"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> to the start of the previous visible line.  <a href="classGtk_1_1TextIterBase.html#a6b9ab4d23ce5479798be23dc25318d24">More...</a><br></br></td></tr>
<tr class="separator:a6b9ab4d23ce5479798be23dc25318d24"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d3ed69725d8dd86653f8d7d3d73abb0"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a9d3ed69725d8dd86653f8d7d3d73abb0">forward_visible_lines</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a9d3ed69725d8dd86653f8d7d3d73abb0"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>count</em> visible lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="classGtk_1_1TextIterBase.html#a9d3ed69725d8dd86653f8d7d3d73abb0">More...</a><br></br></td></tr>
<tr class="separator:a9d3ed69725d8dd86653f8d7d3d73abb0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acc4cb0640cad0724b8987f4c824814c7"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#acc4cb0640cad0724b8987f4c824814c7">backward_visible_lines</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:acc4cb0640cad0724b8987f4c824814c7"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>count</em> visible lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer).  <a href="classGtk_1_1TextIterBase.html#acc4cb0640cad0724b8987f4c824814c7">More...</a><br></br></td></tr>
<tr class="separator:acc4cb0640cad0724b8987f4c824814c7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac6f8245c0e1a645e5ba4a9f99103a891"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ac6f8245c0e1a645e5ba4a9f99103a891">forward_visible_word_end</a> ()</td></tr>
<tr class="memdesc:ac6f8245c0e1a645e5ba4a9f99103a891"><td class="mdescLeft"> </td><td class="mdescRight">Moves forward to the next visible word end.  <a href="classGtk_1_1TextIterBase.html#ac6f8245c0e1a645e5ba4a9f99103a891">More...</a><br></br></td></tr>
<tr class="separator:ac6f8245c0e1a645e5ba4a9f99103a891"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a31b89dffd6f670d5ee82acc2849a7f24"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a31b89dffd6f670d5ee82acc2849a7f24">backward_visible_word_start</a> ()</td></tr>
<tr class="memdesc:a31b89dffd6f670d5ee82acc2849a7f24"><td class="mdescLeft"> </td><td class="mdescRight">Moves backward to the previous visible word start.  <a href="classGtk_1_1TextIterBase.html#a31b89dffd6f670d5ee82acc2849a7f24">More...</a><br></br></td></tr>
<tr class="separator:a31b89dffd6f670d5ee82acc2849a7f24"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad1cb81f34aace00181ebe92124bcea96"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ad1cb81f34aace00181ebe92124bcea96">forward_visible_word_ends</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:ad1cb81f34aace00181ebe92124bcea96"><td class="mdescLeft"> </td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIterBase.html#ac6f8245c0e1a645e5ba4a9f99103a891" title="Moves forward to the next visible word end. ">forward_visible_word_end()</a> up to <em>count</em> times.  <a href="classGtk_1_1TextIterBase.html#ad1cb81f34aace00181ebe92124bcea96">More...</a><br></br></td></tr>
<tr class="separator:ad1cb81f34aace00181ebe92124bcea96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a220feba1ddef6584eb4687564cc2d3cb"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a220feba1ddef6584eb4687564cc2d3cb">backward_visible_word_starts</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a220feba1ddef6584eb4687564cc2d3cb"><td class="mdescLeft"> </td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIterBase.html#a31b89dffd6f670d5ee82acc2849a7f24" title="Moves backward to the previous visible word start. ">backward_visible_word_start()</a> up to <em>count</em> times.  <a href="classGtk_1_1TextIterBase.html#a220feba1ddef6584eb4687564cc2d3cb">More...</a><br></br></td></tr>
<tr class="separator:a220feba1ddef6584eb4687564cc2d3cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abc310bacc8205fb1a7320ddace92b6c6"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#abc310bacc8205fb1a7320ddace92b6c6">forward_sentence_end</a> ()</td></tr>
<tr class="memdesc:abc310bacc8205fb1a7320ddace92b6c6"><td class="mdescLeft"> </td><td class="mdescRight">Moves forward to the next sentence end.  <a href="classGtk_1_1TextIterBase.html#abc310bacc8205fb1a7320ddace92b6c6">More...</a><br></br></td></tr>
<tr class="separator:abc310bacc8205fb1a7320ddace92b6c6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a983d679c56c180d3e9e7a81a008d9c85"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a983d679c56c180d3e9e7a81a008d9c85">backward_sentence_start</a> ()</td></tr>
<tr class="memdesc:a983d679c56c180d3e9e7a81a008d9c85"><td class="mdescLeft"> </td><td class="mdescRight">Moves backward to the previous sentence start; if <em>iter</em> is already at the start of a sentence, moves backward to the next one.  <a href="classGtk_1_1TextIterBase.html#a983d679c56c180d3e9e7a81a008d9c85">More...</a><br></br></td></tr>
<tr class="separator:a983d679c56c180d3e9e7a81a008d9c85"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ba37a05e6b756c1922dd4307202c3a5"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a1ba37a05e6b756c1922dd4307202c3a5">forward_sentence_ends</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a1ba37a05e6b756c1922dd4307202c3a5"><td class="mdescLeft"> </td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIterBase.html#abc310bacc8205fb1a7320ddace92b6c6" title="Moves forward to the next sentence end. ">forward_sentence_end()</a> <em>count</em> times (or until <a class="el" href="classGtk_1_1TextIterBase.html#abc310bacc8205fb1a7320ddace92b6c6" title="Moves forward to the next sentence end. ">forward_sentence_end()</a> returns <code>false</code>).  <a href="classGtk_1_1TextIterBase.html#a1ba37a05e6b756c1922dd4307202c3a5">More...</a><br></br></td></tr>
<tr class="separator:a1ba37a05e6b756c1922dd4307202c3a5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7a5108a85f61250e57577f94cfc1010c"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a7a5108a85f61250e57577f94cfc1010c">backward_sentence_starts</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a7a5108a85f61250e57577f94cfc1010c"><td class="mdescLeft"> </td><td class="mdescRight">Calls <a class="el" href="classGtk_1_1TextIterBase.html#a983d679c56c180d3e9e7a81a008d9c85" title="Moves backward to the previous sentence start; if iter is already at the start of a sentence...">backward_sentence_start()</a> up to <em>count</em> times, or until it returns <code>false</code>.  <a href="classGtk_1_1TextIterBase.html#a7a5108a85f61250e57577f94cfc1010c">More...</a><br></br></td></tr>
<tr class="separator:a7a5108a85f61250e57577f94cfc1010c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8fb3cdc8bd73a7767913a4afded83228"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228">forward_cursor_position</a> ()</td></tr>
<tr class="memdesc:a8fb3cdc8bd73a7767913a4afded83228"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> forward by a single cursor position.  <a href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228">More...</a><br></br></td></tr>
<tr class="separator:a8fb3cdc8bd73a7767913a4afded83228"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9ddafe916c1a15d00ed230f56913dc4b"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a9ddafe916c1a15d00ed230f56913dc4b">backward_cursor_position</a> ()</td></tr>
<tr class="memdesc:a9ddafe916c1a15d00ed230f56913dc4b"><td class="mdescLeft"> </td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228" title="Moves iter forward by a single cursor position. ">forward_cursor_position()</a>, but moves backward.  <a href="classGtk_1_1TextIterBase.html#a9ddafe916c1a15d00ed230f56913dc4b">More...</a><br></br></td></tr>
<tr class="separator:a9ddafe916c1a15d00ed230f56913dc4b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae5846d82ed8fbfaed86f76ab32e6f91f"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ae5846d82ed8fbfaed86f76ab32e6f91f">forward_cursor_positions</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:ae5846d82ed8fbfaed86f76ab32e6f91f"><td class="mdescLeft"> </td><td class="mdescRight">Moves up to <em>count</em> cursor positions.  <a href="classGtk_1_1TextIterBase.html#ae5846d82ed8fbfaed86f76ab32e6f91f">More...</a><br></br></td></tr>
<tr class="separator:ae5846d82ed8fbfaed86f76ab32e6f91f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3ac8ee9a21dfb85e4c9c61e12fd70678"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a3ac8ee9a21dfb85e4c9c61e12fd70678">backward_cursor_positions</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a3ac8ee9a21dfb85e4c9c61e12fd70678"><td class="mdescLeft"> </td><td class="mdescRight">Moves up to <em>count</em> cursor positions.  <a href="classGtk_1_1TextIterBase.html#a3ac8ee9a21dfb85e4c9c61e12fd70678">More...</a><br></br></td></tr>
<tr class="separator:a3ac8ee9a21dfb85e4c9c61e12fd70678"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af9b87383b3699399bf389da5a1faa2cb"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#af9b87383b3699399bf389da5a1faa2cb">forward_visible_cursor_position</a> ()</td></tr>
<tr class="memdesc:af9b87383b3699399bf389da5a1faa2cb"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> forward to the next visible cursor position.  <a href="classGtk_1_1TextIterBase.html#af9b87383b3699399bf389da5a1faa2cb">More...</a><br></br></td></tr>
<tr class="separator:af9b87383b3699399bf389da5a1faa2cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9b81d4a724e8d1689e39b9df70ea9a0"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#aa9b81d4a724e8d1689e39b9df70ea9a0">backward_visible_cursor_position</a> ()</td></tr>
<tr class="memdesc:aa9b81d4a724e8d1689e39b9df70ea9a0"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> forward to the previous visible cursor position.  <a href="classGtk_1_1TextIterBase.html#aa9b81d4a724e8d1689e39b9df70ea9a0">More...</a><br></br></td></tr>
<tr class="separator:aa9b81d4a724e8d1689e39b9df70ea9a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae696b84202a7cb0ee5545def7f2283bc"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ae696b84202a7cb0ee5545def7f2283bc">forward_visible_cursor_positions</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:ae696b84202a7cb0ee5545def7f2283bc"><td class="mdescLeft"> </td><td class="mdescRight">Moves up to <em>count</em> visible cursor positions.  <a href="classGtk_1_1TextIterBase.html#ae696b84202a7cb0ee5545def7f2283bc">More...</a><br></br></td></tr>
<tr class="separator:ae696b84202a7cb0ee5545def7f2283bc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4eff0e6bfbf8c99cbec217a3ce86733e"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a4eff0e6bfbf8c99cbec217a3ce86733e">backward_visible_cursor_positions</a> (int <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01487.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a4eff0e6bfbf8c99cbec217a3ce86733e"><td class="mdescLeft"> </td><td class="mdescRight">Moves up to <em>count</em> visible cursor positions.  <a href="classGtk_1_1TextIterBase.html#a4eff0e6bfbf8c99cbec217a3ce86733e">More...</a><br></br></td></tr>
<tr class="separator:a4eff0e6bfbf8c99cbec217a3ce86733e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae789c6c326524c99aa9cb49bfefb036f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ae789c6c326524c99aa9cb49bfefb036f">set_offset</a> (int char_offset)</td></tr>
<tr class="memdesc:ae789c6c326524c99aa9cb49bfefb036f"><td class="mdescLeft"> </td><td class="mdescRight">Sets <em>iter</em> to point to <em>char_offset</em>.  <a href="classGtk_1_1TextIterBase.html#ae789c6c326524c99aa9cb49bfefb036f">More...</a><br></br></td></tr>
<tr class="separator:ae789c6c326524c99aa9cb49bfefb036f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aef262d087a7fbbc76b670b6cc31c97bb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#aef262d087a7fbbc76b670b6cc31c97bb">set_line</a> (int line_number)</td></tr>
<tr class="memdesc:aef262d087a7fbbc76b670b6cc31c97bb"><td class="mdescLeft"> </td><td class="mdescRight">Moves iterator <em>iter</em> to the start of the line <em>line_number</em>.  <a href="classGtk_1_1TextIterBase.html#aef262d087a7fbbc76b670b6cc31c97bb">More...</a><br></br></td></tr>
<tr class="separator:aef262d087a7fbbc76b670b6cc31c97bb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad9b0c94a3f7519a3c86dae8123d3a4c1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ad9b0c94a3f7519a3c86dae8123d3a4c1">set_line_offset</a> (int char_on_line)</td></tr>
<tr class="memdesc:ad9b0c94a3f7519a3c86dae8123d3a4c1"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> within a line, to a new character (not byte) offset.  <a href="classGtk_1_1TextIterBase.html#ad9b0c94a3f7519a3c86dae8123d3a4c1">More...</a><br></br></td></tr>
<tr class="separator:ad9b0c94a3f7519a3c86dae8123d3a4c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acf4cd3a96205d5dd738fa9c245e49a84"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#acf4cd3a96205d5dd738fa9c245e49a84">set_line_index</a> (int byte_on_line)</td></tr>
<tr class="memdesc:acf4cd3a96205d5dd738fa9c245e49a84"><td class="mdescLeft"> </td><td class="mdescRight">Same as <a class="el" href="classGtk_1_1TextIterBase.html#ad9b0c94a3f7519a3c86dae8123d3a4c1" title="Moves iter within a line, to a new character (not byte) offset. ">set_line_offset()</a>, but works with a byte index.  <a href="classGtk_1_1TextIterBase.html#acf4cd3a96205d5dd738fa9c245e49a84">More...</a><br></br></td></tr>
<tr class="separator:acf4cd3a96205d5dd738fa9c245e49a84"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1cbc6d4c29cc97a40c6b7e4fe7a8af9a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a1cbc6d4c29cc97a40c6b7e4fe7a8af9a">forward_to_end</a> ()</td></tr>
<tr class="memdesc:a1cbc6d4c29cc97a40c6b7e4fe7a8af9a"><td class="mdescLeft"> </td><td class="mdescRight">Moves <em>iter</em> forward to the “end iterator,” which points one past the last valid character in the buffer.  <a href="classGtk_1_1TextIterBase.html#a1cbc6d4c29cc97a40c6b7e4fe7a8af9a">More...</a><br></br></td></tr>
<tr class="separator:a1cbc6d4c29cc97a40c6b7e4fe7a8af9a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a132dc342083ec55747f4da82939ad3dd"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a132dc342083ec55747f4da82939ad3dd">forward_to_line_end</a> ()</td></tr>
<tr class="memdesc:a132dc342083ec55747f4da82939ad3dd"><td class="mdescLeft"> </td><td class="mdescRight">Moves the iterator to point to the paragraph delimiter characters, which will be either a newline, a carriage return, a carriage return/newline in sequence, or the Unicode paragraph separator character.  <a href="classGtk_1_1TextIterBase.html#a132dc342083ec55747f4da82939ad3dd">More...</a><br></br></td></tr>
<tr class="separator:a132dc342083ec55747f4da82939ad3dd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad11a4e5a9214ffa4cdc97ddfdf2dd580"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ad11a4e5a9214ffa4cdc97ddfdf2dd580">set_visible_line_offset</a> (int char_on_line)</td></tr>
<tr class="memdesc:ad11a4e5a9214ffa4cdc97ddfdf2dd580"><td class="mdescLeft"> </td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIterBase.html#ad9b0c94a3f7519a3c86dae8123d3a4c1" title="Moves iter within a line, to a new character (not byte) offset. ">set_line_offset()</a>, but the offset is in visible characters, i.e. text with a tag making it invisible is not counted in the offset.  <a href="classGtk_1_1TextIterBase.html#ad11a4e5a9214ffa4cdc97ddfdf2dd580">More...</a><br></br></td></tr>
<tr class="separator:ad11a4e5a9214ffa4cdc97ddfdf2dd580"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a12bb9f47b003667ba0cccdf18274739d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a12bb9f47b003667ba0cccdf18274739d">set_visible_line_index</a> (int byte_on_line)</td></tr>
<tr class="memdesc:a12bb9f47b003667ba0cccdf18274739d"><td class="mdescLeft"> </td><td class="mdescRight">Like <a class="el" href="classGtk_1_1TextIterBase.html#acf4cd3a96205d5dd738fa9c245e49a84" title="Same as set_line_offset(), but works with a byte index. ">set_line_index()</a>, but the index is in visible bytes, i.e. text with a tag making it invisible is not counted in the index.  <a href="classGtk_1_1TextIterBase.html#a12bb9f47b003667ba0cccdf18274739d">More...</a><br></br></td></tr>
<tr class="separator:a12bb9f47b003667ba0cccdf18274739d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a54c9a7a3cc9326132693ea1998eb91"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a6a54c9a7a3cc9326132693ea1998eb91">forward_to_tag_toggle</a> (const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; tag={})</td></tr>
<tr class="memdesc:a6a54c9a7a3cc9326132693ea1998eb91"><td class="mdescLeft"> </td><td class="mdescRight">Moves forward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>nullptr</code>.  <a href="classGtk_1_1TextIterBase.html#a6a54c9a7a3cc9326132693ea1998eb91">More...</a><br></br></td></tr>
<tr class="separator:a6a54c9a7a3cc9326132693ea1998eb91"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac86d88bbe9560d23b65c29aa6f525afb"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ac86d88bbe9560d23b65c29aa6f525afb">backward_to_tag_toggle</a> (const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; tag={})</td></tr>
<tr class="memdesc:ac86d88bbe9560d23b65c29aa6f525afb"><td class="mdescLeft"> </td><td class="mdescRight">Moves backward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>nullptr</code>.  <a href="classGtk_1_1TextIterBase.html#ac86d88bbe9560d23b65c29aa6f525afb">More...</a><br></br></td></tr>
<tr class="separator:ac86d88bbe9560d23b65c29aa6f525afb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9f15b78f7ea7731f274452c3a04a7ce8"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a9f15b78f7ea7731f274452c3a04a7ce8">forward_find_char</a> (const <a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">SlotFindChar</a>&amp; slot, const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; limit)</td></tr>
<tr class="memdesc:a9f15b78f7ea7731f274452c3a04a7ce8"><td class="mdescLeft"> </td><td class="mdescRight">Advances this iterator, calling <em>slot</em> on each character.  <a href="classGtk_1_1TextIterBase.html#a9f15b78f7ea7731f274452c3a04a7ce8">More...</a><br></br></td></tr>
<tr class="separator:a9f15b78f7ea7731f274452c3a04a7ce8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7419357fe161baa9c2d24874d0fb8b28"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a7419357fe161baa9c2d24874d0fb8b28">forward_find_char</a> (const <a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">SlotFindChar</a>&amp; slot)</td></tr>
<tr class="memdesc:a7419357fe161baa9c2d24874d0fb8b28"><td class="mdescLeft"> </td><td class="mdescRight">Advances this iterator, calling <em>slot</em> on each character.  <a href="classGtk_1_1TextIterBase.html#a7419357fe161baa9c2d24874d0fb8b28">More...</a><br></br></td></tr>
<tr class="separator:a7419357fe161baa9c2d24874d0fb8b28"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9492f9caa441f36226df539839cdb49"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#aa9492f9caa441f36226df539839cdb49">backward_find_char</a> (const <a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">SlotFindChar</a>&amp; slot, const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; limit)</td></tr>
<tr class="memdesc:aa9492f9caa441f36226df539839cdb49"><td class="mdescLeft"> </td><td class="mdescRight">Same as <a class="el" href="classGtk_1_1TextIterBase.html#a9f15b78f7ea7731f274452c3a04a7ce8" title="Advances this iterator, calling slot on each character. ">forward_find_char(const SlotFindChar&amp; slot, const TextIterBase&amp; limit)</a>, but goes backward.  <a href="classGtk_1_1TextIterBase.html#aa9492f9caa441f36226df539839cdb49">More...</a><br></br></td></tr>
<tr class="separator:aa9492f9caa441f36226df539839cdb49"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a582571ab51fe64ad79cd6cec3744bc5b"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a582571ab51fe64ad79cd6cec3744bc5b">backward_find_char</a> (const <a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">SlotFindChar</a>&amp; slot)</td></tr>
<tr class="memdesc:a582571ab51fe64ad79cd6cec3744bc5b"><td class="mdescLeft"> </td><td class="mdescRight">Same as <a class="el" href="classGtk_1_1TextIterBase.html#a7419357fe161baa9c2d24874d0fb8b28" title="Advances this iterator, calling slot on each character. ">forward_find_char(const SlotFindChar&amp; slot)</a>, but goes backward.  <a href="classGtk_1_1TextIterBase.html#a582571ab51fe64ad79cd6cec3744bc5b">More...</a><br></br></td></tr>
<tr class="separator:a582571ab51fe64ad79cd6cec3744bc5b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a525ca51d7b8054e733673f2d5b58a6cc"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a525ca51d7b8054e733673f2d5b58a6cc">compare</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; rhs) const </td></tr>
<tr class="memdesc:a525ca51d7b8054e733673f2d5b58a6cc"><td class="mdescLeft"> </td><td class="mdescRight">A qsort()-style function that returns negative if <em>lhs</em> is less than <em>rhs</em>, positive if <em>lhs</em> is greater than <em>rhs</em>, and 0 if they’re equal.  <a href="classGtk_1_1TextIterBase.html#a525ca51d7b8054e733673f2d5b58a6cc">More...</a><br></br></td></tr>
<tr class="separator:a525ca51d7b8054e733673f2d5b58a6cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69e256644b947425c5a4a77a170189fa"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a69e256644b947425c5a4a77a170189fa">in_range</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#gac5e75a2dd40a49ee555fc35d0eeacc1a">start</a>, const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#gab777d802b5dfa668d030039c2fd78b3b">end</a>) const </td></tr>
<tr class="memdesc:a69e256644b947425c5a4a77a170189fa"><td class="mdescLeft"> </td><td class="mdescRight">Checks whether <em>iter</em> falls in the range [ <em>start</em>, <em>end</em>).  <a href="classGtk_1_1TextIterBase.html#a69e256644b947425c5a4a77a170189fa">More...</a><br></br></td></tr>
<tr class="separator:a69e256644b947425c5a4a77a170189fa"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6ded33e7a8069725ed7d8551b54eaddf"><td align="right" class="memItemLeft" valign="top">static GType </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a6ded33e7a8069725ed7d8551b54eaddf">get_type</a> ()</td></tr>
<tr class="memdesc:a6ded33e7a8069725ed7d8551b54eaddf"><td class="mdescLeft"> </td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="classGtk_1_1TextIterBase.html#a6ded33e7a8069725ed7d8551b54eaddf">More...</a><br></br></td></tr>
<tr class="separator:a6ded33e7a8069725ed7d8551b54eaddf"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a40b07b144c8fa7922be1ac1c53d50892"><td align="right" class="memItemLeft" valign="top">GtkTextIter </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a40b07b144c8fa7922be1ac1c53d50892">gobject_</a></td></tr>
<tr class="separator:a40b07b144c8fa7922be1ac1c53d50892"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a74610f4836e1985249cc2cb575d3f41e"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a74610f4836e1985249cc2cb575d3f41e">operator==</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; rhs)</td></tr>
<tr class="separator:a74610f4836e1985249cc2cb575d3f41e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a77a1d3193a8d7f162fd0b90a7ec4a299"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a77a1d3193a8d7f162fd0b90a7ec4a299">operator!=</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; rhs)</td></tr>
<tr class="separator:a77a1d3193a8d7f162fd0b90a7ec4a299"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a059c36f4776bdd1006a721053bbbfdf5"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a059c36f4776bdd1006a721053bbbfdf5">operator&lt;</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; rhs)</td></tr>
<tr class="separator:a059c36f4776bdd1006a721053bbbfdf5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9cb8ebb1e4aad5eb5fdd5793e9b5c439"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a9cb8ebb1e4aad5eb5fdd5793e9b5c439">operator&gt;</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; rhs)</td></tr>
<tr class="separator:a9cb8ebb1e4aad5eb5fdd5793e9b5c439"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4fe6974bbeba69d994411d6dc35198f8"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a4fe6974bbeba69d994411d6dc35198f8">operator&lt;=</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; rhs)</td></tr>
<tr class="separator:a4fe6974bbeba69d994411d6dc35198f8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeaa24b659c4f9bfbc5540c41a69e53fc"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#aeaa24b659c4f9bfbc5540c41a69e53fc">operator&gt;=</a> (const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; lhs, const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; rhs)</td></tr>
<tr class="separator:aeaa24b659c4f9bfbc5540c41a69e53fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac8967ac142df1dec5c8c8c194c3cee61"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classGtk_1_1TextIterBase.html">Gtk::TextIterBase</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#ac8967ac142df1dec5c8c8c194c3cee61">wrap</a> (GtkTextIter* object)</td></tr>
<tr class="separator:ac8967ac142df1dec5c8c8c194c3cee61"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a12c1154f4b4bab08ea9111cb72b2641f"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classGtk_1_1TextIterBase.html">Gtk::TextIterBase</a>&amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIterBase.html#a12c1154f4b4bab08ea9111cb72b2641f">wrap</a> (const GtkTextIter* object)</td></tr>
<tr class="separator:a12c1154f4b4bab08ea9111cb72b2641f"><td class="memSeparator" colspan="2"> </td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common base class of <a class="el" href="classGtk_1_1TextIter.html" title="Typedefed as Gtk::TextBuffer::iterator. ">TextIter</a> and <a class="el" href="classGtk_1_1TextConstIter.html" title="Typedefed as Gtk::TextBuffer::const_iterator. ">TextConstIter</a>. </p>
<p>You don't create objects of this base class. Objects shall be either <a class="el" href="classGtk_1_1TextIter.html" title="Typedefed as Gtk::TextBuffer::iterator. ">TextIter</a> or <a class="el" href="classGtk_1_1TextConstIter.html" title="Typedefed as Gtk::TextBuffer::const_iterator. ">TextConstIter</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classGtk_1_1TextIter.html" title="Typedefed as Gtk::TextBuffer::iterator. ">TextIter</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a3b14d8cd72db71666ed620f8bf0b4991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classGtk_1_1TextIterBase.html#a3b14d8cd72db71666ed620f8bf0b4991">Gtk::TextIterBase::difference_type</a> =  int</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a24cf4782995313610de7fc48a5eccbce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classGtk_1_1TextIterBase.html#a24cf4782995313610de7fc48a5eccbce">Gtk::TextIterBase::iterator_category</a> =  <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a06664.html">std::bidirectional_iterator_tag</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a53fd6bd11b7a916b56858a579ce72e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classGtk_1_1TextIterBase.html#a53fd6bd11b7a916b56858a579ce72e0c">Gtk::TextIterBase::pointer</a> =  void</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afee0a5ffbece6c265dd888b8c1550f60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classGtk_1_1TextIterBase.html#afee0a5ffbece6c265dd888b8c1550f60">Gtk::TextIterBase::reference</a> =  <a class="el" href="classGtk_1_1TextIterBase.html#a7210161f767759c833fcbf713cf598cf">value_type</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a59ffbed80d87748aaaf6b83d920c33cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">Gtk::TextIterBase::SlotFindChar</a> =  sigc::slot&lt;bool(gunichar)&gt;</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A slot that will be called on each consecutive character. </p>
<p><a class="el" href="classGtk_1_1TextIterBase.html#a9f15b78f7ea7731f274452c3a04a7ce8" title="Advances this iterator, calling slot on each character. ">forward_find_char()</a> and <a class="el" href="classGtk_1_1TextIterBase.html#aa9492f9caa441f36226df539839cdb49" title="Same as forward_find_char(const SlotFindChar&amp; slot, const TextIterBase&amp; limit), but goes backward...">backward_find_char()</a> advance the iterator one character at a time until the slot returns <code>true</code>.</p>
<p>For instance, </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> on_find_char(gunichar ch);</div></div><!-- fragment --><dl class="since_3_90"><dt><b><a class="el" href="since_3_90.html#_since_3_90000006">Since gtkmm 3.90:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7210161f767759c833fcbf713cf598cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">using <a class="el" href="classGtk_1_1TextIterBase.html#a7210161f767759c833fcbf713cf598cf">Gtk::TextIterBase::value_type</a> =  gunichar</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a89fa55a08a7dd17e8e0f62fc68f2c7e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gtk::TextIterBase::TextIterBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a02f0e13c5507c7497e9fc16550bff724"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gtk::TextIterBase::TextIterBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;&amp; </td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aca42ac8be6f14bb9bd389d3e32a39880"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gtk::TextIterBase::TextIterBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af9999bc88a460c8e74fbd1a99ac313ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gtk::TextIterBase::TextIterBase </td>
          <td>(</td>
          <td class="paramtype">const GtkTextIter * </td>
          <td class="paramname"><em>gobject</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a079225b6f2f24884a28fc0a1acc789a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_char </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves backward by one character offset. </p>
<p>Returns <code>true</code> if movement was possible; if <em>iter</em> was the first in the buffer (character offset 0), <a class="el" href="classGtk_1_1TextIterBase.html#a079225b6f2f24884a28fc0a1acc789a7" title="Moves backward by one character offset. ">backward_char()</a> returns <code>false</code> for convenience when writing loops.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether movement was possible. </dd></dl>

</div>
</div>
<a class="anchor" id="aaede9258af84aade77b11f2c206928d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_chars </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>count</em> characters backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). </p>
<p>The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of characters to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ddafe916c1a15d00ed230f56913dc4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Like <a class="el" href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228" title="Moves iter forward by a single cursor position. ">forward_cursor_position()</a>, but moves backward. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ac8ee9a21dfb85e4c9c61e12fd70678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_cursor_positions </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves up to <em>count</em> cursor positions. </p>
<p>See <a class="el" href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228" title="Moves iter forward by a single cursor position. ">forward_cursor_position()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of positions to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9492f9caa441f36226df539839cdb49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_find_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">SlotFindChar</a>&amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>limit</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classGtk_1_1TextIterBase.html#a9f15b78f7ea7731f274452c3a04a7ce8" title="Advances this iterator, calling slot on each character. ">forward_find_char(const SlotFindChar&amp; slot, const TextIterBase&amp; limit)</a>, but goes backward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>Function to be called on each character. </td></tr>
    <tr><td class="paramname">limit</td><td>Search limit. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a match was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a582571ab51fe64ad79cd6cec3744bc5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_find_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">SlotFindChar</a>&amp; </td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classGtk_1_1TextIterBase.html#a7419357fe161baa9c2d24874d0fb8b28" title="Advances this iterator, calling slot on each character. ">forward_find_char(const SlotFindChar&amp; slot)</a>, but goes backward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>Function to be called on each character. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a match was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a998e7bf0bcf2efe553dbec4f3339988b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> to the start of the previous line. </p>
<p>Returns <code>true</code> if <em>iter</em> could be moved; i.e. if <em>iter</em> was at character offset 0, this function returns <code>false</code>. Therefore if <em>iter</em> was already on line 0, but not at the start of the line, <em>iter</em> is snapped to the start of the line and the function returns <code>true</code>. (Note that this implies that in a loop calling this function, the line number may not change on every iteration, if your first iteration is on line 0.)</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved. </dd></dl>

</div>
</div>
<a class="anchor" id="af9ca948bcb9d2a94d9f09c4590ccd7e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_lines </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>count</em> lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). </p>
<p>The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves forward by 0 - <em>count</em> lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of lines to move backward. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="a983d679c56c180d3e9e7a81a008d9c85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_sentence_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves backward to the previous sentence start; if <em>iter</em> is already at the start of a sentence, moves backward to the next one. </p>
<p>Sentence boundaries are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a5108a85f61250e57577f94cfc1010c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_sentence_starts </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classGtk_1_1TextIterBase.html#a983d679c56c180d3e9e7a81a008d9c85" title="Moves backward to the previous sentence start; if iter is already at the start of a sentence...">backward_sentence_start()</a> up to <em>count</em> times, or until it returns <code>false</code>. </p>
<p>If <em>count</em> is negative, moves forward instead of backward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of sentences to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ac86d88bbe9560d23b65c29aa6f525afb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_to_tag_toggle </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; </td>
          <td class="paramname"><em>tag</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves backward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>nullptr</code>. </p>
<p>If no matching tag toggles are found, returns <code>false</code>, otherwise <code>true</code>. Does not return toggles located at <em>iter</em>, only toggles before <em>iter</em>. Sets <em>iter</em> to the location of the toggle, or the start of the buffer if no toggle is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a>, or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we found a tag toggle before <em>iter</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9b81d4a724e8d1689e39b9df70ea9a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_visible_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> forward to the previous visible cursor position. </p>
<p>See <a class="el" href="classGtk_1_1TextIterBase.html#a9ddafe916c1a15d00ed230f56913dc4b" title="Like forward_cursor_position(), but moves backward. ">backward_cursor_position()</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="a4eff0e6bfbf8c99cbec217a3ce86733e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_visible_cursor_positions </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves up to <em>count</em> visible cursor positions. </p>
<p>See <a class="el" href="classGtk_1_1TextIterBase.html#a9ddafe916c1a15d00ed230f56913dc4b" title="Like forward_cursor_position(), but moves backward. ">backward_cursor_position()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of positions to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b9ab4d23ce5479798be23dc25318d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_visible_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> to the start of the previous visible line. </p>
<p>Returns <code>true</code> if <em>iter</em> could be moved; i.e. if <em>iter</em> was at character offset 0, this function returns <code>false</code>. Therefore if <em>iter</em> was already on line 0, but not at the start of the line, <em>iter</em> is snapped to the start of the line and the function returns <code>true</code>. (Note that this implies that in a loop calling this function, the line number may not change on every iteration, if your first iteration is on line 0.)</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved. </dd></dl>

</div>
</div>
<a class="anchor" id="acc4cb0640cad0724b8987f4c824814c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_visible_lines </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>count</em> visible lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). </p>
<p>The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves forward by 0 - <em>count</em> lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of lines to move backward. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="a31b89dffd6f670d5ee82acc2849a7f24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_visible_word_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves backward to the previous visible word start. </p>
<p>(If <em>iter</em> is currently on a word start, moves backward to the next one after that.) Word breaks are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a220feba1ddef6584eb4687564cc2d3cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_visible_word_starts </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classGtk_1_1TextIterBase.html#a31b89dffd6f670d5ee82acc2849a7f24" title="Moves backward to the previous visible word start. ">backward_visible_word_start()</a> up to <em>count</em> times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of times to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0413363c0f8d312cb348eb1997ab236"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_word_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves backward to the previous word start. </p>
<p>(If <em>iter</em> is currently on a word start, moves backward to the next one after that.) Word breaks are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ad16c143d708a80a0b12b5cd13b121a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::backward_word_starts </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classGtk_1_1TextIterBase.html#ac0413363c0f8d312cb348eb1997ab236" title="Moves backward to the previous word start. ">backward_word_start()</a> up to <em>count</em> times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of times to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ac60559326dbbac2ddd95bed2f91169f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::can_insert </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>default_editability</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Considering the default editability of the buffer, and tags that affect editability, determines whether text inserted at <em>iter</em> would be editable. </p>
<p>If text inserted at <em>iter</em> would be editable then the user should be allowed to insert text at <em>iter</em>. <a class="el" href="classGtk_1_1TextBuffer.html#a5ae3a0c42cf66591c116dbb5ab3efd5f" title="Like insert(), but the insertion will not occur if iter is at a non-editable location in the buffer...">Gtk::TextBuffer::insert_interactive()</a> uses this function to decide whether insertions are allowed at a given position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">default_editability</td><td><code>true</code> if text is editable by default. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether text inserted at <em>iter</em> would be editable. </dd></dl>

</div>
</div>
<a class="anchor" id="a525ca51d7b8054e733673f2d5b58a6cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gtk::TextIterBase::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>A qsort()-style function that returns negative if <em>lhs</em> is less than <em>rhs</em>, positive if <em>lhs</em> is greater than <em>rhs</em>, and 0 if they’re equal. </p>
<p>Ordering is in character offset order, i.e. the first character in the buffer is less than the second character in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">rhs</td><td>Another <a class="el" href="classGtk_1_1TextIter.html" title="Typedefed as Gtk::TextBuffer::iterator. ">Gtk::TextIter</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <em>lhs</em> is less than <em>rhs</em>, 1 if <em>lhs</em> is greater, 0 if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a967859094a69a01f8937a432bcff35db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::editable </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>default_setting</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns whether the character at <em>iter</em> is within an editable region of text. </p>
<p>Non-editable text is “locked” and can’t be changed by the user via <a class="el" href="classGtk_1_1TextView.html" title="Multi-line text editing widget. ">Gtk::TextView</a>. If no tags applied to this text affect editability, <em>default_setting</em> will be returned.</p>
<p>You don’t want to use this function to decide whether text can be inserted at <em>iter</em>, because for insertion you don’t want to know whether the char at <em>iter</em> is inside an editable range, you want to know whether a new character inserted at <em>iter</em> would be inside an editable range. Use <a class="el" href="classGtk_1_1TextIterBase.html#ac60559326dbbac2ddd95bed2f91169f4" title="Considering the default editability of the buffer, and tags that affect editability, determines whether text inserted at iter would be editable. ">can_insert()</a> to handle this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">default_setting</td><td><code>true</code> if text is editable by default. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is inside an editable range. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a3b414fdd61e7f0f7cb727470364a61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::ends_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <em>iter</em> points to the start of the paragraph delimiter characters for a line (delimiters will be either a newline, a carriage return, a carriage return followed by a newline, or a Unicode paragraph separator character). </p>
<p>Note that an iterator pointing to the \n of a \r\n pair will not be counted as the end of a line, the line ends before the \r. The end iterator is considered to be at the end of a line, even though there are no paragraph delimiter chars there.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is at the end of a line. </dd></dl>

</div>
</div>
<a class="anchor" id="ab609fc4debe58acceccaa5594157c586"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::ends_sentence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Determines whether <em>iter</em> ends a sentence. </p>
<p>Sentence boundaries are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is at the end of a sentence. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a25531f837a424962c81024b0f0d25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::ends_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; </td>
          <td class="paramname"><em>tag</em> = <code>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <em>tag</em> is toggled off at exactly this point. </p>
<p>If <em>tag</em> is <code>nullptr</code>, returns <code>true</code> if any tag is toggled off at this point.</p>
<p>Note that if <a class="el" href="classGtk_1_1TextIterBase.html#a3a25531f837a424962c81024b0f0d25d" title="Returns true if tag is toggled off at exactly this point. ">ends_tag()</a> returns <code>true</code>, it means that <em>iter</em> is at the end of the tagged range, but that the character at <em>iter</em> is outside the tagged range. In other words, unlike <a class="el" href="classGtk_1_1TextIterBase.html#abb30c5be90fae424416ed40e3b5218f5" title="Returns true if tag is toggled on at exactly this point. ">starts_tag()</a>, if <a class="el" href="classGtk_1_1TextIterBase.html#a3a25531f837a424962c81024b0f0d25d" title="Returns true if tag is toggled off at exactly this point. ">ends_tag()</a> returns <code>true</code>, <a class="el" href="classGtk_1_1TextIterBase.html#ae30ff4e7be20ba14ee4c4a05fe8615e7" title="Returns true if iter points to a character that is part of a range tagged with tag. ">has_tag()</a> will return <code>false</code> for the same parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a>, or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is the end of a range tagged with <em>tag</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a47667346d417d72907b44c0eb6cfd64f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::ends_word </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Determines whether <em>iter</em> ends a natural-language word. </p>
<p>Word breaks are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is at the end of a word. </dd></dl>

</div>
</div>
<a class="anchor" id="ab007920db6e0c73a3b8253a0599f30e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_char </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> forward by one character offset. </p>
<p>Note that images embedded in the buffer occupy 1 character slot, so <a class="el" href="classGtk_1_1TextIterBase.html#ab007920db6e0c73a3b8253a0599f30e4" title="Moves iter forward by one character offset. ">forward_char()</a> may actually move onto an image instead of a character, if you have images in your buffer. If <em>iter</em> is the end iterator or one character before it, <em>iter</em> will now point at the end iterator, and <a class="el" href="classGtk_1_1TextIterBase.html#ab007920db6e0c73a3b8253a0599f30e4" title="Moves iter forward by one character offset. ">forward_char()</a> returns <code>false</code> for convenience when writing loops.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="a179b2d7d56dd4bfeeb81add9bd425a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_chars </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>count</em> characters if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). </p>
<p>The return value indicates whether the new position of <em>iter</em> is different from its original position, and dereferenceable (the last iterator in the buffer is not dereferenceable). If <em>count</em> is 0, the function does nothing and returns <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of characters to move, may be negative. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fb3cdc8bd73a7767913a4afded83228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> forward by a single cursor position. </p>
<p>Cursor positions are (unsurprisingly) positions where the cursor can appear. Perhaps surprisingly, there may not be a cursor position between all characters. The most common example for European languages would be a carriage return/newline sequence. For some Unicode characters, the equivalent of say the letter “a” with an accent mark will be represented as two characters, first the letter then a "combining
mark" that causes the accent to be rendered; so the cursor can’t go between those two characters. See also the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html#ab0b3468a9efcaec7022885d46fd43d09">Pango::LogAttr</a>-struct and pango_break() function.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5846d82ed8fbfaed86f76ab32e6f91f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_cursor_positions </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves up to <em>count</em> cursor positions. </p>
<p>See <a class="el" href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228" title="Moves iter forward by a single cursor position. ">forward_cursor_position()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of positions to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f15b78f7ea7731f274452c3a04a7ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_find_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">SlotFindChar</a>&amp; </td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>limit</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Advances this iterator, calling <em>slot</em> on each character. </p>
<p>If <em>slot</em> returns <code>true</code>, forward_find_char() returns <code>true</code> and stops scanning. If <em>slot</em> never returns <code>true</code>, this iterator is set to <em>limit</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A function to be called on each character. </td></tr>
    <tr><td class="paramname">limit</td><td>Search limit. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a match was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a7419357fe161baa9c2d24874d0fb8b28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_find_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html#a59ffbed80d87748aaaf6b83d920c33cf">SlotFindChar</a>&amp; </td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Advances this iterator, calling <em>slot</em> on each character. </p>
<p>If <em>slot</em> returns <code>true</code>, forward_find_char() returns <code>true</code> and stops scanning. If <em>slot</em> never returns <code>true</code>, this iterator is set to the end iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">slot</td><td>A function to be called on each character. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a match was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b2c18fbbf08f24e3c6d5696f4bb3bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> to the start of the next line. </p>
<p>If the iter is already on the last line of the buffer, moves the iter to the end of the current line. If after the operation, the iter is at the end of the buffer and not dereferenceable, returns <code>false</code>. Otherwise, returns <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> can be dereferenced. </dd></dl>

</div>
</div>
<a class="anchor" id="a6348f43fb950836bf672fe52091c5c71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_lines </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>count</em> lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). </p>
<p>The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves backward by 0 - <em>count</em> lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of lines to move forward. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="abc310bacc8205fb1a7320ddace92b6c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_sentence_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves forward to the next sentence end. </p>
<p>(If <em>iter</em> is at the end of a sentence, moves to the next end of sentence.) Sentence boundaries are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ba37a05e6b756c1922dd4307202c3a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_sentence_ends </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classGtk_1_1TextIterBase.html#abc310bacc8205fb1a7320ddace92b6c6" title="Moves forward to the next sentence end. ">forward_sentence_end()</a> <em>count</em> times (or until <a class="el" href="classGtk_1_1TextIterBase.html#abc310bacc8205fb1a7320ddace92b6c6" title="Moves forward to the next sentence end. ">forward_sentence_end()</a> returns <code>false</code>). </p>
<p>If <em>count</em> is negative, moves backward instead of forward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of sentences to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cbc6d4c29cc97a40c6b7e4fe7a8af9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gtk::TextIterBase::forward_to_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> forward to the “end iterator,” which points one past the last valid character in the buffer. </p>
<p><a class="el" href="classGtk_1_1TextIterBase.html#a7df2c6d63c0f2eadfa74d49bc7e8048d" title="The Unicode character at this iterator is returned. ">get_char()</a> called on the end iterator returns 0, which is convenient for writing loops. </p>

</div>
</div>
<a class="anchor" id="a132dc342083ec55747f4da82939ad3dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_to_line_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves the iterator to point to the paragraph delimiter characters, which will be either a newline, a carriage return, a carriage return/newline in sequence, or the Unicode paragraph separator character. </p>
<p>If the iterator is already at the paragraph delimiter characters, moves to the paragraph delimiter characters for the next line. If <em>iter</em> is on the last line in the buffer, which does not end in paragraph delimiters, moves to the end iterator (end of the last line), and returns <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new location is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a54c9a7a3cc9326132693ea1998eb91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_to_tag_toggle </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; </td>
          <td class="paramname"><em>tag</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves forward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>nullptr</code>. </p>
<p>If no matching tag toggles are found, returns <code>false</code>, otherwise <code>true</code>. Does not return toggles located at <em>iter</em>, only toggles after <em>iter</em>. Sets <em>iter</em> to the location of the toggle, or to the end of the buffer if no toggle is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a>, or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we found a tag toggle after <em>iter</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="af9b87383b3699399bf389da5a1faa2cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_visible_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> forward to the next visible cursor position. </p>
<p>See <a class="el" href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228" title="Moves iter forward by a single cursor position. ">forward_cursor_position()</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="ae696b84202a7cb0ee5545def7f2283bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_visible_cursor_positions </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves up to <em>count</em> visible cursor positions. </p>
<p>See <a class="el" href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228" title="Moves iter forward by a single cursor position. ">forward_cursor_position()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of positions to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="a9aa78f4b7841b0b89ff699cd763550ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_visible_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> to the start of the next visible line. </p>
<p>Returns <code>true</code> if there was a next line to move to, and <code>false</code> if <em>iter</em> was simply moved to the end of the buffer and is now not dereferenceable, or if <em>iter</em> was already at the end of the buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> can be dereferenced. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d3ed69725d8dd86653f8d7d3d73abb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_visible_lines </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>count</em> visible lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). </p>
<p>The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves backward by 0 - <em>count</em> lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of lines to move forward. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6f8245c0e1a645e5ba4a9f99103a891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_visible_word_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves forward to the next visible word end. </p>
<p>(If <em>iter</em> is currently on a word end, moves forward to the next one after that.) Word breaks are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1cb81f34aace00181ebe92124bcea96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_visible_word_ends </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classGtk_1_1TextIterBase.html#ac6f8245c0e1a645e5ba4a9f99103a891" title="Moves forward to the next visible word end. ">forward_visible_word_end()</a> up to <em>count</em> times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of times to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1cd8150472655327bc0b8466d0a8965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_word_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves forward to the next word end. </p>
<p>(If <em>iter</em> is currently on a word end, moves forward to the next one after that.) Word breaks are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a9396d6eb8157b403206738cbf16059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::forward_word_ends </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classGtk_1_1TextIterBase.html#ad1cd8150472655327bc0b8466d0a8965" title="Moves forward to the next word end. ">forward_word_end()</a> up to <em>count</em> times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">count</td><td>Number of times to move. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="adefbb3301d329c20f696e6b6147349aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gtk::TextIterBase::get_bytes_in_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the number of bytes in the line containing <em>iter</em>, including the paragraph delimiters. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in the line. </dd></dl>

</div>
</div>
<a class="anchor" id="a7df2c6d63c0f2eadfa74d49bc7e8048d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">gunichar Gtk::TextIterBase::get_char </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>The Unicode character at this iterator is returned. </p>
<p>(Equivalent to operator* on a C++ iterator.) If the element at this iterator is a non-character element, such as an image embedded in the buffer, the Unicode “unknown” character 0xFFFC is returned. If invoked on the end iterator, zero is returned; zero is not a valid Unicode character. So you can write a loop which ends when <a class="el" href="classGtk_1_1TextIterBase.html#a7df2c6d63c0f2eadfa74d49bc7e8048d" title="The Unicode character at this iterator is returned. ">get_char()</a> returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>A Unicode character, or 0 if <em>iter</em> is not dereferenceable. </dd></dl>

</div>
</div>
<a class="anchor" id="aa59610daceb49a42c38f74381efc03be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gtk::TextIterBase::get_chars_in_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the number of characters in the line containing <em>iter</em>, including the paragraph delimiters. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of characters in the line. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c55ac5b91d25568f9f6e42b59c518c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/classPango_1_1Language.html">Pango::Language</a> Gtk::TextIterBase::get_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the language in effect at <em>iter</em>. </p>
<p>If no tags affecting language apply to <em>iter</em>, the return value is identical to that of gtk_get_default_language().</p>
<dl class="section return"><dt>Returns</dt><dd>Language in effect at <em>iter</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a60c0c66696c8dcaa2445b383e089ded5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gtk::TextIterBase::get_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the line number containing the iterator. </p>
<p>Lines in a <a class="el" href="classGtk_1_1TextBuffer.html" title="Multi-line attributed text that can be displayed by one or more Gtk::TextView widgets. ">Gtk::TextBuffer</a> are numbered beginning with 0 for the first line in the buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>A line number. </dd></dl>

</div>
</div>
<a class="anchor" id="adf071172096a9f8e04dabe972529d54f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gtk::TextIterBase::get_line_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the byte index of the iterator, counting from the start of a newline-terminated line. </p>
<p>Remember that <a class="el" href="classGtk_1_1TextBuffer.html" title="Multi-line attributed text that can be displayed by one or more Gtk::TextView widgets. ">Gtk::TextBuffer</a> encodes text in UTF-8, and that characters can require a variable number of bytes to represent.</p>
<dl class="section return"><dt>Returns</dt><dd>Distance from start of line, in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a89791fc2f47b169bb9817009ae1ae59d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gtk::TextIterBase::get_line_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the character offset of the iterator, counting from the start of a newline-terminated line. </p>
<p>The first character on the line has offset 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Offset from start of line. </dd></dl>

</div>
</div>
<a class="anchor" id="aec3a77b92f3a7918668fe6038a51113b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gtk::TextIterBase::get_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the character offset of an iterator. </p>
<p>Each character in a <a class="el" href="classGtk_1_1TextBuffer.html" title="Multi-line attributed text that can be displayed by one or more Gtk::TextView widgets. ">Gtk::TextBuffer</a> has an offset, starting with 0 for the first character in the buffer. Use <a class="el" href="classGtk_1_1TextBuffer.html#ae92edc6a06a9a5fae2ee99f762bb59ff">Gtk::TextBuffer::get_iter_at_offset()</a> to convert an offset back into an iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>A character offset. </dd></dl>

</div>
</div>
<a class="anchor" id="a7599b9af7b359732200a2d5a7014372a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/classGlib_1_1ustring.html">Glib::ustring</a> Gtk::TextIterBase::get_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the text in the given range. </p>
<p>A “slice” is an array of characters encoded in UTF-8 format, including the Unicode “unknown” character 0xFFFC for iterable non-character elements in the buffer, such as images. Because images are encoded in the slice, byte and character offsets in the returned array will correspond to byte offsets in the text buffer. Note that 0xFFFC can occur in normal text as well, so it is not a reliable indicator that a paintable or widget is in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">end</td><td>Iterator at end of a range. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Slice of text from the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="afdcecd70c167b7207e402843ece1b7da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/classGlib_1_1ustring.html">Glib::ustring</a> Gtk::TextIterBase::get_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns text in the given range. </p>
<p>If the range contains non-text elements such as images, the character and byte offsets in the returned string will not correspond to character and byte offsets in the buffer. If you want offsets to correspond, see <a class="el" href="classGtk_1_1TextIterBase.html#a7599b9af7b359732200a2d5a7014372a" title="Returns the text in the given range. ">get_slice()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">end</td><td>Iterator at end of a range. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of characters from the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ded33e7a8069725ed7d8551b54eaddf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static GType Gtk::TextIterBase::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get the GType for this class, for use with the underlying GObject type system. </p>

</div>
</div>
<a class="anchor" id="a378f91255ecdea2739f7c88bb78500c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gtk::TextIterBase::get_visible_line_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the number of bytes from the start of the line to the given <em>iter</em>, not counting bytes that are invisible due to tags with the “invisible” flag toggled on. </p>
<dl class="section return"><dt>Returns</dt><dd>Byte index of <em>iter</em> with respect to the start of the line. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4001f06243a9431869b472fae172f22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int Gtk::TextIterBase::get_visible_line_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the offset in characters from the start of the line to the given <em>iter</em>, not counting characters that are invisible due to tags with the “invisible” flag toggled on. </p>
<dl class="section return"><dt>Returns</dt><dd>Offset in visible characters from the start of the line. </dd></dl>

</div>
</div>
<a class="anchor" id="a69480d8e37f507242596de65927c60f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/classGlib_1_1ustring.html">Glib::ustring</a> Gtk::TextIterBase::get_visible_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Like <a class="el" href="classGtk_1_1TextIterBase.html#a7599b9af7b359732200a2d5a7014372a" title="Returns the text in the given range. ">get_slice()</a>, but invisible text is not included. </p>
<p>Invisible text is usually invisible because a <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a> with the “invisible” attribute turned on has been applied to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">end</td><td>Iterator at end of range. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Slice of text from the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a03b8a846cd377e2567bf0039e6025712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/classGlib_1_1ustring.html">Glib::ustring</a> Gtk::TextIterBase::get_visible_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Like <a class="el" href="classGtk_1_1TextIterBase.html#afdcecd70c167b7207e402843ece1b7da" title="Returns text in the given range. ">get_text()</a>, but invisible text is not included. </p>
<p>Invisible text is usually invisible because a <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a> with the “invisible” attribute turned on has been applied to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">end</td><td>Iterator at end of range. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing visible text in the range. </dd></dl>

</div>
</div>
<a class="anchor" id="afe3ed2742a24672a4ed263f6ec3a2567"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">GtkTextIter* Gtk::TextIterBase::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. </p>

</div>
</div>
<a class="anchor" id="a4ae481258259e71ef67dc9519f6069a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const GtkTextIter* Gtk::TextIterBase::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. </p>

</div>
</div>
<a class="anchor" id="ae30ff4e7be20ba14ee4c4a05fe8615e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::has_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; </td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <em>iter</em> points to a character that is part of a range tagged with <em>tag</em>. </p>
<p>See also <a class="el" href="classGtk_1_1TextIterBase.html#abb30c5be90fae424416ed40e3b5218f5" title="Returns true if tag is toggled on at exactly this point. ">starts_tag()</a> and <a class="el" href="classGtk_1_1TextIterBase.html#a3a25531f837a424962c81024b0f0d25d" title="Returns true if tag is toggled off at exactly this point. ">ends_tag()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is tagged with <em>tag</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a69e256644b947425c5a4a77a170189fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::in_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>end</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks whether <em>iter</em> falls in the range [ <em>start</em>, <em>end</em>). </p>
<p><em>start</em> and <em>end</em> must be in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">start</td><td>Start of range. </td></tr>
    <tr><td class="paramname">end</td><td>End of range. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is in the range. </dd></dl>

</div>
</div>
<a class="anchor" id="a4143d1a36c154e1d65ccbbe3730abd9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::inside_sentence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Determines whether <em>iter</em> is inside a sentence (as opposed to in between two sentences, e.g. after a period and before the first letter of the next sentence). </p>
<p>Sentence boundaries are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is inside a sentence. </dd></dl>

</div>
</div>
<a class="anchor" id="a14dc8e8fdef8ebfad2cba226d56e07ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::inside_word </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Determines whether the character pointed by <em>iter</em> is part of a natural-language word (as opposed to say inside some whitespace). </p>
<p>Word breaks are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> word break algorithms).</p>
<p>Note that if <a class="el" href="classGtk_1_1TextIterBase.html#a69188fcb922219032f650ad399b8b46c" title="Determines whether iter begins a natural-language word. ">starts_word()</a> returns <code>true</code>, then this function returns <code>true</code> too, since <em>iter</em> points to the first character of the word.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is inside a word. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9d6bfef7ca2c832c151bd2f8e831975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::is_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>See <a class="el" href="classGtk_1_1TextIterBase.html#a8fb3cdc8bd73a7767913a4afded83228" title="Moves iter forward by a single cursor position. ">forward_cursor_position()</a> or <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html#ab0b3468a9efcaec7022885d46fd43d09">Pango::LogAttr</a> or pango_break() for details on what a cursor position is. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the cursor can be placed at <em>iter</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a26d57f9b3ba0b1e6cf689c3176524d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::is_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <em>iter</em> is the end iterator, i.e. one past the last dereferenceable iterator in the buffer. </p>
<p><a class="el" href="classGtk_1_1TextIterBase.html#a26d57f9b3ba0b1e6cf689c3176524d85" title="Returns true if iter is the end iterator, i.e. one past the last dereferenceable iterator in the buff...">is_end()</a> is the most efficient way to check whether an iterator is the end iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is the end iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ab37fb8d7bd27d7dae5866d4d355aa8c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::is_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <em>iter</em> is the first iterator in the buffer, that is if <em>iter</em> has a character offset of 0. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is the first in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a21978967b14b3140eb1c2ebf13cb177e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Gtk::TextIterBase::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Alias for !is_end(). </p>
<p>For instance, </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (textiter)</div><div class="line">  do_something();</div></div><!-- fragment --><dl class="since_3_22"><dt><b><a class="el" href="since_3_22.html#_since_3_22000024">Since gtkmm 3.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5f7b581dc5c9261ff5ef287e41245ef9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIterBase.html#a7210161f767759c833fcbf713cf598cf">value_type</a> Gtk::TextIterBase::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="classGtk_1_1TextIterBase.html#a7df2c6d63c0f2eadfa74d49bc7e8048d" title="The Unicode character at this iterator is returned. ">get_char()</a>. </p>

</div>
</div>
<a class="anchor" id="a66d574142957ea8c32f74c6eb7a59653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; Gtk::TextIterBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b8b52eb048dc0eb03939ec0831caf8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; Gtk::TextIterBase::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp;&amp; </td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aef262d087a7fbbc76b670b6cc31c97bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gtk::TextIterBase::set_line </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>line_number</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves iterator <em>iter</em> to the start of the line <em>line_number</em>. </p>
<p>If <em>line_number</em> is negative or larger than the number of lines in the buffer, moves <em>iter</em> to the start of the last line in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">line_number</td><td>Line number (counted from 0). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf4cd3a96205d5dd738fa9c245e49a84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gtk::TextIterBase::set_line_index </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>byte_on_line</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classGtk_1_1TextIterBase.html#ad9b0c94a3f7519a3c86dae8123d3a4c1" title="Moves iter within a line, to a new character (not byte) offset. ">set_line_offset()</a>, but works with a byte index. </p>
<p>The given byte index must be at the start of a character, it can’t be in the middle of a UTF-8 encoded character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">byte_on_line</td><td>A byte index relative to the start of <em>iter’s</em> current line. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9b0c94a3f7519a3c86dae8123d3a4c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gtk::TextIterBase::set_line_offset </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>char_on_line</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Moves <em>iter</em> within a line, to a new character (not byte) offset. </p>
<p>The given character offset must be less than or equal to the number of characters in the line; if equal, <em>iter</em> moves to the start of the next line. See <a class="el" href="classGtk_1_1TextIterBase.html#acf4cd3a96205d5dd738fa9c245e49a84" title="Same as set_line_offset(), but works with a byte index. ">set_line_index()</a> if you have a byte index rather than a character offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">char_on_line</td><td>A character offset relative to the start of <em>iter’s</em> current line. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae789c6c326524c99aa9cb49bfefb036f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gtk::TextIterBase::set_offset </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>char_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Sets <em>iter</em> to point to <em>char_offset</em>. </p>
<p><em>char_offset</em> counts from the start of the entire text buffer, starting with 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">char_offset</td><td>A character number. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12bb9f47b003667ba0cccdf18274739d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gtk::TextIterBase::set_visible_line_index </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>byte_on_line</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Like <a class="el" href="classGtk_1_1TextIterBase.html#acf4cd3a96205d5dd738fa9c245e49a84" title="Same as set_line_offset(), but works with a byte index. ">set_line_index()</a>, but the index is in visible bytes, i.e. text with a tag making it invisible is not counted in the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">byte_on_line</td><td>A byte index. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad11a4e5a9214ffa4cdc97ddfdf2dd580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void Gtk::TextIterBase::set_visible_line_offset </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>char_on_line</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Like <a class="el" href="classGtk_1_1TextIterBase.html#ad9b0c94a3f7519a3c86dae8123d3a4c1" title="Moves iter within a line, to a new character (not byte) offset. ">set_line_offset()</a>, but the offset is in visible characters, i.e. text with a tag making it invisible is not counted in the offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">char_on_line</td><td>A character offset. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af770823f0947c77a4d630b3900822c91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::starts_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <em>iter</em> begins a paragraph, i.e. if <a class="el" href="classGtk_1_1TextIterBase.html#a89791fc2f47b169bb9817009ae1ae59d" title="Returns the character offset of the iterator, counting from the start of a newline-terminated line...">get_line_offset()</a> would return 0. </p>
<p>However this function is potentially more efficient than <a class="el" href="classGtk_1_1TextIterBase.html#a89791fc2f47b169bb9817009ae1ae59d" title="Returns the character offset of the iterator, counting from the start of a newline-terminated line...">get_line_offset()</a> because it doesn’t have to compute the offset, it just has to see whether it’s 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> begins a line. </dd></dl>

</div>
</div>
<a class="anchor" id="a311c37bb5916810d67bb72f33226f756"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::starts_sentence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Determines whether <em>iter</em> begins a sentence. </p>
<p>Sentence boundaries are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is at the start of a sentence. </dd></dl>

</div>
</div>
<a class="anchor" id="abb30c5be90fae424416ed40e3b5218f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::starts_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; </td>
          <td class="paramname"><em>tag</em> = <code>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <em>tag</em> is toggled on at exactly this point. </p>
<p>If <em>tag</em> is <code>nullptr</code>, returns <code>true</code> if any tag is toggled on at this point.</p>
<p>Note that if <a class="el" href="classGtk_1_1TextIterBase.html#abb30c5be90fae424416ed40e3b5218f5" title="Returns true if tag is toggled on at exactly this point. ">starts_tag()</a> returns <code>true</code>, it means that <em>iter</em> is at the beginning of the tagged range, and that the character at <em>iter</em> is inside the tagged range. In other words, unlike <a class="el" href="classGtk_1_1TextIterBase.html#a3a25531f837a424962c81024b0f0d25d" title="Returns true if tag is toggled off at exactly this point. ">ends_tag()</a>, if <a class="el" href="classGtk_1_1TextIterBase.html#abb30c5be90fae424416ed40e3b5218f5" title="Returns true if tag is toggled on at exactly this point. ">starts_tag()</a> returns <code>true</code>, <a class="el" href="classGtk_1_1TextIterBase.html#ae30ff4e7be20ba14ee4c4a05fe8615e7" title="Returns true if iter points to a character that is part of a range tagged with tag. ">has_tag()</a> will also return <code>true</code> for the same parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a>, or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is the start of a range tagged with <em>tag</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a69188fcb922219032f650ad399b8b46c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::starts_word </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Determines whether <em>iter</em> begins a natural-language word. </p>
<p>Word breaks are determined by <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> and should be correct for nearly any language (if not, the correct fix would be to the <a class="elRef" doxygen="pangomm-2.48.tag:http://library.gnome.org/devel/pangomm/unstable/" href="http://library.gnome.org/devel/pangomm/unstable/namespacePango.html">Pango</a> word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is at the start of a word. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a9f93661c9a4ceea57a3babbe2d566b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool Gtk::TextIterBase::toggles_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="glibmm-2.68.tag:http://library.gnome.org/devel/glibmm/unstable/" href="http://library.gnome.org/devel/glibmm/unstable/namespaceGlib.html#afa2fecfa732e9ec1107ace03a2911d63">Glib::RefPtr</a>&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt;&amp; </td>
          <td class="paramname"><em>tag</em> = <code>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>This is equivalent to (<a class="el" href="classGtk_1_1TextIterBase.html#abb30c5be90fae424416ed40e3b5218f5" title="Returns true if tag is toggled on at exactly this point. ">starts_tag()</a> || <a class="el" href="classGtk_1_1TextIterBase.html#a3a25531f837a424962c81024b0f0d25d" title="Returns true if tag is toggled off at exactly this point. ">ends_tag()</a>), i.e. it tells you whether a range with <em>tag</em> applied to it begins or ends at <em>iter</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html" title="Typedefed as Gtk::TextBuffer::Tag. ">Gtk::TextTag</a>, or <code>nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>tag</em> is toggled on or off at <em>iter</em>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a77a1d3193a8d7f162fd0b90a7ec4a299"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01484.html#ga8ae9cabed8e455713324dacd39bedef1">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>rhs</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="a059c36f4776bdd1006a721053bbbfdf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>rhs</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="a4fe6974bbeba69d994411d6dc35198f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>rhs</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="a74610f4836e1985249cc2cb575d3f41e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>rhs</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="a9cb8ebb1e4aad5eb5fdd5793e9b5c439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>rhs</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="aeaa24b659c4f9bfbc5540c41a69e53fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIterBase.html">TextIterBase</a>&amp; </td>
          <td class="paramname"><em>rhs</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="ac8967ac142df1dec5c8c8c194c3cee61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIterBase.html">Gtk::TextIterBase</a>&amp; wrap </td>
          <td>(</td>
          <td class="paramtype">GtkTextIter * </td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">object</td><td>The C instance </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a12c1154f4b4bab08ea9111cb72b2641f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">const <a class="el" href="classGtk_1_1TextIterBase.html">Gtk::TextIterBase</a>&amp; wrap </td>
          <td>(</td>
          <td class="paramtype">const GtkTextIter * </td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">object</td><td>The C instance </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a40b07b144c8fa7922be1ac1c53d50892"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">GtkTextIter Gtk::TextIterBase::gobject_</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
</div></div></div><div id="footer_art" class="default"> </div></div><div class="clearfix"></div><div id="footer_grass">   </div><div id="footer"><div class="container_12"><div class="links grid_9"><div class="menu-footer-1-container"><ul id="menu-footer-1" class="menu"><li id="menu-item-88" class="menu-item menu-item-type-custom menu-item-home menu-item-88"><a href="https://www.gnome.org/">The GNOME Project</a><ul class="sub-menu"><li id="menu-item-89" class="menu-item menu-item-type-post_type menu-item-89"><a href="https://www.gnome.org/about/">About Us</a></li><li id="menu-item-90" class="menu-item menu-item-type-custom menu-item-90"><a href="https://www.gnome.org/get-involved/">Get Involved</a></li><li id="menu-item-91" class="menu-item menu-item-type-custom menu-item-91"><a href="https://www.gnome.org/teams/">Teams</a></li><li id="menu-item-92" class="menu-item menu-item-type-custom menu-item-92"><a href="https://foundation.gnome.org">The GNOME Foundation</a></li><li><a href="https://www.gnome.org/support-gnome/">Support GNOME</a></li><li><a href="https://www.gnome.org/contact/">Contact</a></li></ul></li></ul></div><div class="menu-footer-2-container"><ul id="menu-footer-2" class="menu"><li id="menu-item-99" class="menu-item menu-item-type-post_type current-menu-item page_item page-item-20 current_page_item menu-item-99"><a href="classGtk_1_1TextIterBase.html#">Resources</a><ul class="sub-menu"><li><a href="https://help.gnome.org">Documentation</a></li><li><a href="https://wiki.gnome.org">Wiki</a></li><li><a href="https://mail.gnome.org/mailman/listinfo">Mailing Lists</a></li><li><a href="https://wiki.gnome.org/GnomeIrcChannels">IRC Channels</a></li><li><a href="https://gitlab.gnome.org/">Bug Tracker</a></li><li><a href="https://gitlab.gnome.org/">Development Code</a></li><li><a href="https://wiki.gnome.org/Jhbuild">Build Tool</a></li></ul></li></ul></div><div class="menu-footer-4-container"><ul id="menu-footer-4" class="menu"><li id="menu-item-104" class="menu-item menu-item-type-custom menu-item-104"><a href="http://www.gnome.org/news/">News</a><ul class="sub-menu"><li><a href="https://www.gnome.org/start/stable">Latest Release</a></li><li><a href="https://planet.gnome.org">Planet GNOME</a></li><li><a href="https://news.gnome.org">Development News</a></li><li><a href="https://twitter.com/gnome">Twitter</a></li></ul></li></ul></div></div><div class="links grid_3 right"><div><ul class="menu available_languages"><li><strong>This website is available in many languages</strong><ul class="sub-menu"><li><a href="../../languages.html" title="Switching Language">Switch Language</a></li></ul></li></ul><script type="text/javascript" src="../../js/language.js"></script></div></div><div id="footnotes" class="grid_9">
                Copyright © 2005‒2014 <strong class="gnome_logo">The GNOME Project</strong><br></br><small>Optimised for standards. Hosted by <a href="http://redhat.com">Red Hat</a>.</small></div><div class="clear"></div></div></div><script type="text/javascript">
$(document).ready(function() {
    // Get browser
    $.each($.browser, function(i) {
        $('body').addClass(i);
        return false;
    });

    // Get OS and add it as class to body tag, this then allows forcing some
    // customisation in the CSS rules.
    var match = navigator.userAgent.toLowerCase().match(/(win|mac|linux)/);
    if (match) {
        $('body').addClass(match[0]);
    }
});
</script><script type="text/javascript">
      var _paq = _paq || [];
      _paq.push(['disableCookies']);
      _paq.push(["trackPageView"]);
      _paq.push(["enableLinkTracking"]);

      (function() {
        var u=(("https:" == document.location.protocol) ? "https" : "http") + "://webstats.gnome.org/";
        _paq.push(["setTrackerUrl", u+"piwik.php"]);
        _paq.push(["setSiteId", "6"]);
        var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";
        g.defer=true; g.async=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);
      })();
    </script></body></html>
